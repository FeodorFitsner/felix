@title Strings
@tangler flx_strutil.hpp     = $PWD/src/rtl/flx_strutil.hpp
@tangler flx_strutil.cpp     = $PWD/src/rtl/flx_strutil.cpp
@tangler flx_i18n.hpp        = $PWD/src/rtl/flx_i18n.hpp
@tangler flx_i18n.cpp        = $PWD/src/rtl/flx_i18n.cpp


@tangler __init__.flx        = share/lib/std/strings/__init__.flx
@tangler string.flx          = share/lib/std/strings/string.flx
@tangler stringexpr.fsyn     = share/lib/std/strings/stringexpr.fsyn
@tangler re2.flx             = share/lib/std/strings/re2.flx
@tangler tre.flx             = share/lib/std/strings/tre.flx
@tangler regdef.flx          = share/lib/std/strings/regdef.flx
@tangler regexps.fsyn        = share/lib/std/strings/regexps.fsyn
@tangler lexer.flx           = share/lib/std/strings/lexer.flx

@h1 Core support

@h2 String utilities
@tangle flx_strutil.hpp

#ifndef __FLX_STRUTIL_HPP_
#define __FLX_STRUTIL_HPP_

#include <string>
#include <sstream>
#include <iomanip>
#include <stdarg.h>

#include "flx_rtl_config.hpp"

//RF: was only to commented out to fix macosx problem,
//but lets see what happens to all the other builds.
//#ifndef MACOSX
//template class RTL_EXTERN std::basic_string<char>;
//#endif

namespace flx { namespace rtl { namespace strutil {
  using namespace std;
  template<class T>
  basic_string<T> mul(basic_string<T> s, int n) {
    basic_string<T> r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  template<class T>
  basic_string<T> substr(basic_string<T> const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }

  template<class T>
  T subscript(basic_string<T> const &s, int i)
  {
    int n = s.size();
    if(i<0)  i=i+n;
    return i<0 || i >= n ? T(0) : s[i];
  }

  template<class T>
  string str(T const &t) {
    std::ostringstream x;
    x << t;
    return x.str();
  }

  template<class T>
  string fmt_default(T const &t, int w, int p) {
    std::ostringstream x;
    x << std::setw(w) << std::setprecision(p) << t;
    return x.str();
  }

  template<class T>
  string fmt_fixed(T const &t, int w, int p) {
    std::ostringstream x;
    x << std::fixed << std::setw(w) << std::setprecision(p) << t;
    return x.str();
  }

  template<class T>
  string fmt_scientific(T const &t, int w, int p) {
    std::ostringstream x;
    x << std::scientific << std::setw(w) << std::setprecision(p) << t;
    return x.str();
  }


  RTL_EXTERN string atostr(char const *a);
  RTL_EXTERN string flx_asprintf(char const *fmt,...);

  RTL_EXTERN string flxid_to_cid(string const&);
  RTL_EXTERN string filename_to_modulename (string const&);

}}}

#endif
@

@tangle flx_strutil.cpp

#include <stdio.h>

#include "flx_strutil.hpp"

namespace flx { namespace rtl { namespace strutil {

  string atostr(char const *a) {
    if(a) return a;
    else return "";
  }

  string flxid_to_cid (string const &s)
  {
    string out = "";
    int n = s.size();
    // leading digit
    if (n > 1 && s[0] >= '0' && s[0] <= '9') out += "_";
    for (int i = 0; i < n; ++i)
    {
      char ch = s[i];
      /* from http://www.w3.org/TR/html4/sgml/entities.html */
      switch (ch)
      {
        case ' ': out += "__sp_"; break;
        case '!': out += "__excl_"; break;
        case '"': out += "__quot_"; break;
        case '#': out += "__num_"; break;
        case '$': out += "__dollar_"; break;
        case '%': out += "__percnt_"; break;
        case '&': out += "__amp_"; break;
        case '\'':  out +=  "__apos_"; break;
        case '(': out += "__lpar_"; break;
        case ')': out += "__rpar_"; break;
        case '*': out += "__ast_"; break;
        case '+': out += "__plus_"; break;
        case ',': out += "__comma_"; break;
        case '-': out += "__hyphen_"; break;
        case '.': out += "__period_"; break;
        case '/': out += "__sol_"; break;
        case ':': out += "__colon_"; break;
        case ';': out += "__semi_"; break;
        case '<': out += "__lt_"; break;
        case '=': out += "__equals_"; break;
        case '>': out += "__gt_"; break;
        case '?': out += "__quest_"; break;
        case '@': out += "__commat_"; break;
        case '[': out += "__lsqb_"; break;
        case '\\': out += "__bsol_"; break;
        case ']': out += "__rsqb_"; break;
        case '^': out += "__caret_"; break;
        case '`': out += "__grave_"; break;
        case '{': out += "__lcub_"; break;
        case '|': out += "__verbar_"; break;
        case '}': out += "__rcub_"; break;
        case '~': out += "__tilde_"; break;
        default: out += string (1,ch);
      }
   }
   return out;
  }

  string chop_extension (string const &s)
  {
     int n = s.size();
     for(int i = n - 1; i >= 0; --i) 
     {
       if (s[i] == '/') return s;
       if (s[i] == '\\') return s;
       if (s[i] == '.') return s.substr(0,i);
     }
     return s;
  }

  string basename (string const &s) 
  {
     int n = s.size();
     for(int i = n - 1; i >= 0; --i) 
     {
       if (s[i] == '/') return s.substr (i+1,n-i);
       if (s[i] == '\\') return s.substr (i+1,n-i);
     }
     return s;
  }
  string filename_to_modulename (string const &s)
  {
     string a = basename (s);
     a = chop_extension (a);
     a = flxid_to_cid (a);
     return a; 
  }

#ifdef FLX_HAVE_VSNPRINTF
  string flx_asprintf(char const *fmt,...){
    va_list ap;
    va_start(ap,fmt);
    //printf("vsnprintf TRIAL\n");
    int n = vsnprintf(NULL,0,fmt,ap);
    //printf("vsnprintf size=%d\n",n);
    va_end(ap);
    char *res = new char[n + 1];
    va_start(ap,fmt);
    vsnprintf(res,n+1,fmt,ap);
    va_end(ap);
    string s = string(res);
    delete [] res;
    return s;
  }
#else
  // THIS IS UNSAFE .. but Windows sucks.
  // It documents vsnprintf .. but doesn't provide it
  string flx_asprintf(char const *fmt,...){
    //printf("vsnprintf EMULATION!\n");
    va_list ap;
    int n = 10000; // hack, WILL crash if not enough
    char *res = new char[n+1];
    va_start(ap,fmt);
    vsprintf(res,fmt,ap);
    va_end(ap);
    string s = string(res);
    delete [] res;
    return s;
  }
#endif

}}}
@

@h2 UTF codec.
@tangle flx_i18n.hpp

#ifndef __FLX_I18N_H__
#define __FLX_I18N_H__
#include <string>
#include "flx_rtl_config.hpp"

namespace flx { namespace rtl { namespace i18n {
   RTL_EXTERN std::string utf8(unsigned long);
}}}
#endif
@

@tangle flx_i18n.cpp

#include "flx_i18n.hpp"
namespace flx { namespace rtl { namespace i18n {
  std::string utf8(unsigned long i)
  {
    char s[7];
    if (i < 0x80UL )
    {
      s[0]= i;
      s[1]= 0;
    }
    else if (i < 0x800UL )
    {
      s[0]=0xC0u | (i >> 6ul)  & 0x1Fu;
      s[1]=0x80u | i           & 0x3Fu;
      s[2]=0;
    }
    else if (i < 0x10000UL )
    {
      s[0]=0xE0u | (i >> 12ul) & 0xFu;
      s[1]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[2]=0x80u | i           & 0x3F;
      s[3]=0;
    }
    else if (i < 0x200000UL )
    {
      s[0]=0xF0u | (i >> 18ul) & 0x7u;
      s[1]=0x80u | (i >> 12ul) & 0x3Fu;
      s[2]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[3]=0x80u | i           & 0x3F;
      s[4]=0;
    }
    else if (i < 0x4000000UL )
    {
      s[0]=0xF8u | (i >> 24ul) & 0x3u;
      s[1]=0x80u | (i >> 18ul) & 0x3Fu;
      s[2]=0x80u | (i >> 12ul) & 0x3Fu;
      s[3]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[4]=0x80u | i           & 0x3Fu;
      s[5]=0;
    }
    else
    {
      s[0]=0xFCu | (i >> 30ul) & 0x1u;
      s[1]=0x80u | (i >> 24ul) & 0x3Fu;
      s[2]=0x80u | (i >> 18ul) & 0x3Fu;
      s[3]=0x80u | (i >> 12ul) & 0x3Fu;
      s[4]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[5]=0x80u | i           & 0x3Fu;
      s[6]=0;
    }
    return s;
  }
}}}
@

@h1 String handling
@tangle __init__.flx
include "std/strings/string";
include "std/strings/re2";
include "std/strings/tre";
include "std/strings/regdef";
include "std/strings/lexer";

@h1 Strings
We have three string like things. @{cstring} is just 
an alias for a NTBS (Null Terminated Byte String).
The workhorse @{string} type based on C++ string.
A @{ustring} is a unicode representation using a 32 bit unsigned integer as
the character base.
This type is deprecated, to be repalced by C++11 unicode string type.
@tangle string.flx
typedef cstring = +char;
type string = "::std::basic_string<char>" 
  requires Cxx_headers::string,
  header '#include "flx_serialisers.hpp"',
  encoder "::flx::gc::generic::string_encoder",
  decoder "::flx::gc::generic::string_decoder"
;
typedef strings = typesetof (string);

class Str [T] {
  virtual fun str: T -> string;
}

class Repr [T with Str[T]] {
  virtual fun repr (t:T) : string => str t;
}

class Show [T] {
  inherit Str[T];
  inherit Repr[T];
}


@h2 Equality and total ordering
@tangle string.flx
instance[t in strings] Eq[t] {
  fun == : t * t -> bool = "$1==$2";
}
instance[t in strings] Tord[t] {
  fun < : t * t -> bool = "$1<$2";
}

open class String
{
  inherit Eq[string];

  inherit Tord[string];

@h2 Equality of @{string} and @{char}
@tangle string.flx
  fun == (s:string, c:char) => len s == 1uz and s.[0] == c;
  fun == (c:char, s:string) => len s == 1uz and s.[0] == c;
  fun != (s:string, c:char) => len s != 1uz or s.[0] != c;
  fun != (c:char, s:string) => len s != 1uz or s.[0] != c;

@h2 Append to @{string} object
@tangle string.flx
  proc  += : &string * string = "$1->append($2:assign);";
  proc  += : &string * +char = "$1->append($2:assign);";
  proc  += : &string * char = "*$1 += $2;";

@h2 Length of @{string}
@tangle string.flx
  // we need to cast to an int so that c++ won't complain
  fun len: string -> size = "$1.size()";

@h2 String concatenation.
@tangle string.flx
  fun + : string * string -> string = "$1+$2";
  fun + : string * carray[char] -> string = "$1+$2";
  fun + : string * char -> string = "$1+$2";
  fun + : char * string -> string = "$1+$2";
  //fun + : string * int -> string = "$1+::flx::rtl::i18n::utf8($2:assign)" is add requires package "flx_i18n";
  fun + ( x:string,  y: int) => x + str y;

  // may be a bit risky!
  // IT WAS: interferes with "hello" + list ("world","blah"): 
  // is this a string or a list of strings?
  //fun + [T with Str[T]] (x:string, y:T) => x + str y;

@h2 Repetition of @{string} or @{char}
@tangle string.flx
  fun * : string * int -> string = "::flx::rtl::strutil::mul($1:assign,$2:assign)" requires package "flx_strutil";
  fun * : char * int -> string = "::std::string($2:assign,$1:assign)";

@h2 Application of @{string} to @{string} or @{int} is concatenation
@tangle string.flx
  fun apply (x:string, y:string):string => x + y;
  fun apply (x:string, y:int):string => x + y;

@h2 Construct a char from first byte of a @{string}.
Returns nul char (code 0) if the string is empty.
@tangle string.flx
  ctor char (x:string) => x.[0];
@h2 Constructors for @{string}
@tangle string.flx
  ctor string (c:char) => ""+c;
  ctor string: +char = "::std::string($1:assign)";
  ctor string: +char  * !ints = "::std::string($1:assign,$2:assign)";
  fun utf8: int -> string = "::flx::rtl::i18n::utf8($1)" requires package "flx_i18n";

@h2 Substrings
@tangle string.flx
  fun subscript: string * !ints -> char =
    "::flx::rtl::strutil::subscript($1:assign,$2:assign)" requires package "flx_strutil";
  fun copyfrom: string * !ints -> string =
    "::flx::rtl::strutil::substr($1:assign,$2:assign,$1:postfix.size())" requires package "flx_strutil";
  fun copyto: string * !ints -> string =
    "::flx::rtl::strutil::substr($1:assign,0,$2:assign)" requires package "flx_strutil";
  fun substring: string * !ints * !ints -> string =
    "::flx::rtl::strutil::substr($1:assign,$2:assign,$3:assign)" requires package "flx_strutil";

  fun subscript (x:string, s:slice[int]):string =>
    match s with
    | #Slice_all => substring (x, 0, x.len.int)
    | Slice_from (start) => copyfrom (x, start)
    | Slice_to (end) => copyto (x, end)
    | Slice_range (start, end) => substring (x, start, end)
    | Slice_one (index) => string x.[index]
    endmatch
  ;

  proc store: &string * !ints * char = "(*$1)[$2] = $3;";

@h2 Map a string @{char} by @{char}
@tangle string.flx
  fun map (f:char->char) (var x:string): string = {
    if len x > 0uz do
      for var i in 0uz upto (len x) - 1uz do
        store(&x, i, f x.[i]);
      done
    done
    return x;
  }

@h2 STL string functions
These come in two flavours: the standard C++ operations
which return @{stl_npos} on failure, and a more Felix
like variant which uses an @{option} type.
@tangle string.flx
  const stl_npos: size = "::std::string::npos";

  fun stl_find: string * string -> int = "(int)$1.find($2)" is cast;
  fun stl_find: string * string * int -> int = "(int)$1.find($2,$3)" is cast;
  fun stl_find: string * +char -> int = "(int)$1.find($2)" is cast;
  fun stl_find: string * +char * int -> int = "(int)$1.find($2,$3)" is cast;
  fun stl_find: string * char -> int = "(int)$1.find($2)" is cast;
  fun stl_find: string * char * int -> int = "(int)$1.find($2,$3)" is cast;

  fun find (s:string, e:string) : opt[int] => match stl_find (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find (s:string, e:string, i:int) : opt[int] => match stl_find (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find (s:string, e:+char) : opt[int] => match stl_find (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find (s:string, e:+char, i:int) : opt[int] => match stl_find (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find (s:string, e:char) : opt[int] => match stl_find (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find (s:string, e:char, i:int) : opt[int] => match stl_find (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;

  fun stl_rfind: string * string -> int = "$1.rfind($2)";
  fun stl_rfind: string * string * int -> int = "$1.rfind($2,$3)";
  fun stl_rfind: string * +char-> int = "$1.rfind($2)";
  fun stl_rfind: string * +char * int -> int = "$1.rfind($2,$3)";
  fun stl_rfind: string * char -> int = "$1.rfind($2)";
  fun stl_rfind: string * char * int -> int = "$1.rfind($2,$3)";

  fun rfind (s:string, e:string) : opt[int] => match stl_rfind (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun rfind (s:string, e:string, i:int) : opt[int] => match stl_rfind (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun rfind (s:string, e:+char) : opt[int] => match stl_rfind (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun rfind (s:string, e:+char, i:int) : opt[int] => match stl_rfind (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun rfind (s:string, e:char) : opt[int] => match stl_rfind (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun rfind (s:string, e:char, i:int) : opt[int] => match stl_rfind (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;

  fun stl_find_first_of: string * string -> int = "$1.find_first_of($2)";
  fun stl_find_first_of: string * string * int -> int = "$1.find_first_of($2,$3)";
  fun stl_find_first_of: string * +char -> int = "$1.find_first_of($2)";
  fun stl_find_first_of: string * +char * int -> int = "$1.find_first_of($2,$3)";
  fun stl_find_first_of: string * char -> int = "$1.find_first_of($2)";
  fun stl_find_first_of: string * char * int -> int = "$1.find_first_of($2,$3)";

  fun find_first_of (s:string, e:string) : opt[int] => match stl_find_first_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_first_of (s:string, e:string, i:int) : opt[int] => match stl_find_first_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_first_of (s:string, e:+char) : opt[int] => match stl_find_first_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_first_of (s:string, e:+char, i:int) : opt[int] => match stl_find_first_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_first_of (s:string, e:char) : opt[int] => match stl_find_first_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_first_of (s:string, e:char, i:int) : opt[int] => match stl_find_first_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;

  fun stl_find_first_not_of: string * string -> int = "$1.find_first_not_of($2)";
  fun stl_find_first_not_of: string * string * int -> int = "$1.find_first_not_of($2,$3)";
  fun stl_find_first_not_of: string * +char -> int = "$1.find_first_not_of($2)";
  fun stl_find_first_not_of: string * +char * int -> int = "$1.find_first_not_of($2,$3)";
  fun stl_find_first_not_of: string * char -> int = "$1.find_first_not_of($2)";
  fun stl_find_first_not_of: string * char * int -> int = "$1.find_first_not_of($2,$3)";

  fun find_first_not_of (s:string, e:string) : opt[int] => match stl_find_first_not_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_first_not_of (s:string, e:string, i:int) : opt[int] => match stl_find_first_not_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_first_not_of (s:string, e:+char) : opt[int] => match stl_find_first_not_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_first_not_of (s:string, e:+char, i:int) : opt[int] => match stl_find_first_not_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_first_not_of (s:string, e:char) : opt[int] => match stl_find_first_not_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_first_not_of (s:string, e:char, i:int) : opt[int] => match stl_find_first_not_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;

  fun stl_find_last_of: string * string -> int = "$1.find_last_of($2)";
  fun stl_find_last_of: string * string * int -> int = "$1.find_last_of($2,$3)";
  fun stl_find_last_of: string * +char -> int = "$1.find_last_of($2)";
  fun stl_find_last_of: string * +char * int -> int = "$1.find_last_of($2,$3)";
  fun stl_find_last_of: string * char -> int = "$1.find_last_of($2)";
  fun stl_find_last_of: string * char * int -> int = "$1.find_last_of($2,$3)";

  fun find_last_of (s:string, e:string) : opt[int] => match stl_find_last_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_last_of (s:string, e:string, i:int) : opt[int] => match stl_find_last_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_last_of (s:string, e:+char) : opt[int] => match stl_find_last_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_last_of (s:string, e:+char, i:int) : opt[int] => match stl_find_last_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_last_of (s:string, e:char) : opt[int] => match stl_find_last_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_last_of (s:string, e:char, i:int) : opt[int] => match stl_find_last_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;

  fun stl_find_last_not_of: string * string -> int = "$1.find_last_not_of($2)";
  fun stl_find_last_not_of: string * string * int -> int = "$1.find_last_not_of($2,$3)";
  fun stl_find_last_not_of: string * +char -> int = "$1.find_last_not_of($2)";
  fun stl_find_last_not_of: string * +char * int -> int = "$1.find_last_not_of($2,$3)";
  fun stl_find_last_not_of: string * char -> int = "$1.find_last_not_of($2)";
  fun stl_find_last_not_of: string * char * int -> int = "$1.find_last_not_of($2,$3)";

  fun find_last_not_of (s:string, e:string) : opt[int] => match stl_find_last_not_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_last_not_of (s:string, e:string, i:int) : opt[int] => match stl_find_last_not_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_last_not_of (s:string, e:+char) : opt[int] => match stl_find_last_not_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_last_not_of (s:string, e:+char, i:int) : opt[int] => match stl_find_last_not_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_last_not_of (s:string, e:char) : opt[int] => match stl_find_last_not_of (s, e) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;
  fun find_last_not_of (s:string, e:char, i:int) : opt[int] => match stl_find_last_not_of (s, e, i) with | i when i.size == stl_npos => None[int] | i => Some i endmatch;

  
@h2 Construe @{string} as set of @{char}
@tangle string.flx
  instance Set[string,char] {
    fun \in (c:char, s:string) => stl_find (s,c) != stl_npos.int;
  }
  
@h2 Construe @{string} as stream of @{char}
@tangle string.flx
  instance Streamable[string, char] {
    gen iterator(var x:string) () = {
      for var i in 0 upto x.len.int - 1 do yield Some (x.[i]); done
      return None[char];
    }
  }
  inherit Streamable[string,char];

@h2 Test if a string has given prefix or suffix
@tangle string.flx
  fun prefix(arg:string,key:string)=>
    arg.[to len key]==key
  ;

  fun suffix (arg:string,key:string)=>
    arg.[-key.len to]==key
  ;


  fun startswith (x:string) (e:string) : bool => prefix (x,e);

  // as above: slices are faster
  fun endswith (x:string) (e:string) : bool => suffix (x,e);

  fun startswith (x:string) (e:char) : bool => x.[0] == e;
  fun endswith (x:string) (e:char) : bool => x.[-1] == e;

@h2 Trim off specified prefix or suffix or both
@tangle string.flx
  fun ltrim (x:string) (e:string) : string =>
    if startswith x e then
      x.[e.len.int to]
    else
      x
    endif
  ;

  fun rtrim (x:string) (e:string) : string =>
    if endswith x e then
      x.[to x.len.int - e.len.int]
    else
      x
    endif
  ;

  fun trim (x:string) (e:string) : string => ltrim (rtrim x e) e;

@h2 Strip characters from left, right, or both end of a string.
@tangle string.flx
  fun lstrip (x:string, e:string) : string =
  {
    if len x > 0uz do
      for var i in 0uz upto len x - 1uz do
        var found = false;
        for var j in 0uz upto len e - 1uz do
          if x.[i] == e.[j] do
            found = true;
          done
        done

        if not found do
          return x.[i to];
        done
      done;
    done
    return '';
  }

  fun rstrip (x:string, e:string) : string =
  {
    if len x > 0uz do
      for var i in len x - 1uz downto 0uz do
        var found = false;
        for var j in 0uz upto len e - 1uz do
          if x.[i] == e.[j] do
            found = true;
          done
        done

        if not found do
          return x.[to i.int + 1];
        done
      done
    done
    return '';
  }

  fun strip (x:string, e:string) : string => lstrip(rstrip(x, e), e);

  fun lstrip (x:string) : string => lstrip(x, " \t\n\r\f\v");
  fun rstrip (x:string) : string => rstrip(x, " \t\n\r\f\v");
  fun strip (x:string) : string => lstrip$ rstrip x;

@h2 Justify string contents
@tangle string.flx
  fun ljust(x:string, width:int) : string =>
    if x.len.int >= width
      then x
      else x + (' ' * (width - x.len.int))
    endif
  ;

  fun rjust(x:string, width:int) : string =>
    if x.len.int >= width
      then x
      else (' ' * (width - x.len.int)) + x
    endif
  ;

@h2 Split a string into a list on given separator
@tangle string.flx
  fun split (x:string, d:char): List::list[string] => List::rev (rev_split (x,d));

  fun rev_split (x:string, d:char): List::list[string] = {
    fun aux (x:string,y:List::list[string]) =>
      match find (x, d) with
      | #None => Cons (x, y)
      | Some n => aux$ x.[n+1 to], List::Cons (x.[to n],y)
      endmatch
    ;
    return aux$ x, List::Empty[string];
  }

  fun split (x:string, d:string): List::list[string] => List::rev (rev_split (x,d));

  fun rev_split (x:string, d:string): List::list[string] = {
    fun aux (pos:int,y:List::list[string]) =>
      match stl_find_first_of (x, d, pos) with
      | $(stl_npos.int) => List::Cons (x.[pos to],y)
      | n => aux$ (n+1), List::Cons (x.[pos to n],y)
      endmatch
    ;
    return aux$ 0, List::Empty[string];
  }

  fun split (x:string, d:+char): List::list[string] => List::rev (rev_split (x,d));

  fun rev_split (x:string, d:+char): List::list[string] = {
    fun aux (x:string,y:List::list[string]) =>
      match find_first_of (x, d) with
      | #None => List::Cons (x, y)
      | Some n => aux$ x.[n+1 to], List::Cons (x.[to n],y)
      endmatch
    ;
    return aux$ x, List::Empty[string];
  }

  fun split_first (x:string, d:string): opt[string*string] =>
    match find_first_of (x, d) with
    | #None => None[string*string]
    | Some n => Some (x.[to n],substring(x,n+1,(len x)))
    endmatch
  ;


  //$ Split a string on whitespace but respecting
  //$ double quotes, single quotes, and slosh escapes.
  // leading and trailing space is removed. Embedded
  // multiple spaces cause a single split.
  class RespectfulParser {
    union quote_action_t = 
      | ignore-quote
      | keep-quote
      | drop-quote
    ; 
    union dquote_action_t = 
      | ignore-dquote
      | keep-dquote
      | drop-dquote
    ; 
    union escape_action_t = 
      | ignore-escape
      | keep-escape
      | drop-escape
    ; 
    typedef action_t = (quote:quote_action_t, dquote:dquote_action_t, escape:escape_action_t);

    union mode_t = | copying | skipping | quote | dquote | escape-copying | escape-quote | escape-dquote;
    typedef state_t = (mode:mode_t, current:string, parsed: list[string] );

    noinline fun respectful_parse (action:action_t) (var state:state_t) (var s:string) : state_t = 
    {
      var mode = state.mode;
      var current = state.current;
      var result = Empty[string];

      noinline proc handlecopying(ch:char) {
        if ch == char "'" do
          match action.quote with
          | #ignore-quote => 
            current += ch;
          | #keep-quote =>
            current += ch;
            mode = quote;
          | #drop-quote =>
            mode = quote;
          endmatch;
        elif ch == char '"' do
          match action.dquote with
          | #ignore-dquote => 
            current += ch;
          | #keep-dquote =>
            current += ch;
            mode = dquote;
          | #drop-dquote =>
            mode = dquote;
          endmatch;
        elif ch == char '\\' do
          match action.escape with
          | #ignore-escape => 
            current += ch;
          | #keep-escape =>
            current += ch;
            mode = escape-copying;
          | #drop-escape =>
            mode = escape-copying;
          endmatch;
        elif ord ch <= ' '.char.ord  do // can't happen if called from skipping
          result += current;
          current = "";
          mode = skipping;
        else
          current += ch;
          mode = copying;
        done
      }

      for ch in s do 
        match mode with
        | #copying => handlecopying ch;
        | #quote =>
          if ch == char "'" do
            match action.quote with
            | #ignore-quote => 
              assert false;
              //current += ch;
            | #keep-quote =>
              current += ch;
              mode = copying;
            | #drop-quote =>
              mode = copying;
            endmatch;
          elif ch == char "\\" do
            match action.escape with
            | #ignore-escape => 
              current += ch;
            | #keep-escape =>
              current += ch;
              mode = escape-quote;
            | #drop-escape =>
              mode = escape-quote;
            endmatch;
          else
            current += ch;
          done 

        | #dquote =>
          if ch == char '"' do
            match action.dquote with
            | #ignore-dquote => 
              assert false;
              //current += ch;
            | #keep-dquote =>
              current += ch;
              mode = copying;
            | #drop-dquote =>
              mode = copying;
            endmatch;
          elif ch == char "\\" do
            match action.escape with
            | #ignore-escape => 
              current += ch;
            | #keep-escape =>
              current += ch;
              mode = escape-dquote;
            | #drop-escape =>
              mode = escape-dquote;
            endmatch;
          else
            current += ch;
          done 

        | #escape-copying =>
           current += ch;
           mode = copying;

        | #escape-quote =>
           current += ch;
           mode = quote;

        | #escape-dquote =>
           current += ch;
           mode = dquote;

        | #skipping =>
          if ord ch > ' '.char.ord  do
            handlecopying ch;
          done
        endmatch;
      done
      return (mode=mode, current=current, parsed=state.parsed + result);
    }
  }
  
  // simplified one shot parser.
  // ignores mismatched quotes and backslashes.
  fun respectful_split (action:RespectfulParser::action_t) (s:string) : list[string] = 
  {
    var state = RespectfulParser::respectful_parse
      action 
      (
        mode=RespectfulParser::skipping, 
        current="", 
        parsed=Empty[string]
      ) 
      s
    ;
    // ignore mismatched quotes and backslashes.
    match state.mode with 
    | #skipping => ;
    | _ => state.parsed = state.parsed + state.current;
    endmatch;
    return state.parsed;
 
  }

  fun respectful_split (s:string) : list[string] =>
    respectful_split (
      quote=RespectfulParser::keep-quote, 
      dquote=RespectfulParser::keep-dquote, 
      escape=RespectfulParser::keep-escape
    ) 
    s
  ; 

  // OO version of the parser.
  object respectfulParser (action:RespectfulParser::action_t) = {
    var state = (mode=RespectfulParser::skipping, current="", parsed=Empty[string]);
    method proc parse (s:string) {
      state = RespectfulParser::respectful_parse action state s;
    }
    method fun get_parsed () => state.parsed;
  }

@h2 erase, insert or replace substrings
@tangle string.flx
  // Note: pos, length!
  //$ mutators
  proc erase: &string * int * int = "$1->erase($2,$3);";
  proc insert: &string * int * string = "$1->insert($2,$3);";
  proc replace: &string * int * int * string = "$1->replace($2,$3,$4);";

  //$ functional
  fun erase: string * int * int -> string = "::std::string($1).erase($2,$3)";
  fun insert: string * int * string -> string = "::std::string($1).insert($2,$3)";
  fun replace: string * int * int * string -> string = "::std::string($1).replace($2,$3,$4)";


@h2 search and replace
Search and replace by string.
@tangle string.flx
  fun search_and_replace (x:string, var spos:size, s:string, r:string) : string =
  {
    val m = s.len;
    var o = x.[to spos];
    var n = (x,s,spos.int).stl_find.size;
    while n != stl_npos do
      o+=x.[spos to n]+r;
      spos = n+m;
      n = (x,s,spos.int).stl_find.size;
    done
    o+=x.[spos to];
    return o;
  }
  fun search_and_replace (x:string, s:string, r:string) : string => search_and_replace (x,0uz,s,r);

  fun search_and_replace (vs:list[string * string]) (var v:string) = {
    match k,b in vs do
      v = search_and_replace (v,k,b);
    done
    return v;
  }

@h2 Regexp search and replace
Uses Google RE2 engine.
@tangle string.flx
  // Replace \0 \1 \2 etc in s with text from v
  fun subst(s:string, v:varray[StringPiece]): string =
  {
  //println$ "Subst " + s +" with " + str v;
     enum mode_t {cp, ins};
     var b = "";
     var mode=cp;
     var j = 0;
     var count = 0;
     for var i in 0 upto s.len.int - 1 do
       match mode with
       | #cp => 
         if s.[i] == char "\\" do 
           mode = ins; 
           j=0; count = 0; 
         else 
          b += s.[i]; 
         done
       | #ins =>
         if s.[i] in "0123456789" do
           j = j * 10 + ord(s.[i]) - ord (char "0");
           ++count;
         else
           if count == 0 do
             b += "\\";
           elif j < v.len.int do
             b+= str v.stl_begin.j;
           done
           // adjacent insertion?
           if s.[i] == char "\\" do
             j=0; count=0;
           else
             mode = cp;
             b += s.[i]; 
           done
         done
       endmatch;
     done
     // run off end
     match mode with
     | #cp => ;
     | #ins =>
       if count == 0 do
         b += "\\";
       elif j < v.len.int do
         b+= str v.j;
       done
     endmatch;
     return b;
  }
  // Search for regex, replace by r with \0 \1 \2 etc replace by match groups.
  fun search_and_replace (x:string, var spos: size, re:Re2::RE2, r:string) : string =
  {
    var ngroups = re.NumberOfCapturingGroups + 1;
    var v = varray[StringPiece]$ (ngroups+1).size, StringPiece "";
    var o = x.[to spos];             // initial substring
    var sp = StringPiece(x);
    var base : +char = sp.data;      // base pointer of char array
    while Re2::Match(re, sp, spos.int, UNANCHORED, v.stl_begin, v.len.int) do
      var mpos = size(v.0.data - base);  // start of match
      o+= x.[spos to mpos];          // copy upto start of match
      o+= subst(r,v);                // copy replacement
      spos = mpos + v.0.len;       // advance over match
    done
    o+=x.[spos to];                  // rest of string
    return o;
  }
@h2 Parse string to numeric type
@tangle string.flx
  fun atoi: string -> int = "::std::atoi($1:postfix.c_str())"  requires Cxx_headers::cstdlib;
  fun atol: string -> long = "::std::atol($1:postfix.c_str())"  requires Cxx_headers::cstdlib;
  fun atoll: string -> long = "::std::atoll($1:postfix.c_str())"  requires Cxx_headers::cstdlib;
  fun atof: string -> double = "::std::atof($1:postfix.c_str())"  requires Cxx_headers::cstdlib;

@h2 Reserve store
@tangle string.flx
  proc reserve: &string * !ints = "$1->reserve($2);";

@h2 Fetch underlying cstring.
@tangle string.flx
  // Entirely unsafe because string could be an rvalue.
  fun _unsafe_cstr: string -> +char = "((char*)$1.c_str())" is atom;

  // partially unsafe because the string could be modified.
  fun stl_begin: &string -> +char = "((char*)$1->c_str())" is atom;
  fun stl_end: &string -> +char = "((char*)($1->c_str()+$1->size()))" is atom;

  // this operation is entirely safe because the char array
  // provided is copied (and garbage collected)
  fun cstr (x:string) : +char => (varray[char] x).stl_begin;

@h2 Polymorphic vsprintf hack
@tangle string.flx
  fun vsprintf[t]: +char  * t -> string =
    "::flx::rtl::strutil::flx_asprintf($1,$2)" requires package "flx_strutil"
  ;

  fun vsprintf[t]: string * t -> string =
    "::flx::rtl::strutil::flx_asprintf(const_cast<char*>($1.c_str()),$2)" requires package "flx_strutil"
  ;

@h2 Case translation
@tangle string.flx
  // Convert all characters to upper case  
  fun toupper(s:string):string => map (toupper of char) s;
  // Convert all characters to lower case
  fun tolower(s:string):string => map (tolower of char) s;
}


@h2 Transation to string
@tangle string.flx

instance Str[string] {
  fun str (s:string) : string => s;
}

instance Str[+char] {
  fun str: +char -> string = '::flx::rtl::strutil::atostr($1)' requires package "flx_strutil";
}

instance Repr[string] {
  fun repr (x:string) : string = {
    var o = "'";
    if len x > 0uz do
      for var i in 0uz upto (String::len x) - 1uz do
        o += repr x.[i];
      done
    done
    return o + "'";
  }
}

open[T in strings] Show[T];
open Set[string,char];

@h1 String syntax
@tangle stringexpr.fsyn
syntax stringexpr
{
  //$ String subscript.
  x[sfactor_pri] := x[sfactor_pri] "." "[" sexpr "]" =># "`(ast_apply ,_sr (,(noi 'subscript) (,_1 ,_4)))";

  //$ String substring.
  x[sfactor_pri] := x[sfactor_pri] "." "[" sexpr "to" sexpr "]" =># "`(ast_apply ,_sr (,(noi 'substring) (,_1 ,_4 ,_6)))";

  //$ String substring, to end of string.
  x[sfactor_pri] := x[sfactor_pri] "." "[" sexpr "to" "]" =># "`(ast_apply ,_sr (,(noi 'copyfrom) (,_1 ,_4)))";

  //$ String substring, from start of string.
  x[sfactor_pri] := x[sfactor_pri] "." "[" "to" sexpr "]" =># "`(ast_apply ,_sr (,(noi 'copyto) (,_1 ,_5)))";
}

@h1 RE2 regexps
@tangle re2.flx

include "stl/stl_map";

//$ Binding of Google RE2 regexp library.
open class Re2 {
  requires package "re2";

// This is an almost full binding of Google's re2 package.
// We do not support conversions of digits strings to integers
//
// TODO: we need to check the lvalue handling here
// The RE2, Options classes aren't copyable, so we may have
// to use pointers
//
// TODO: named group extractor

  // hackery because ::re2::RE2 isn't copyable, so we have to use a pointer
  // but we need the shape of RE2 to create on the heap
  private body RE2_serial = """
  static ::std::string RE2_encoder(void *p) { return ((::re2::RE2*)p)->pattern(); }

  static size_t RE2_decoder (void *p, char *s, size_t i) { 
    char tmp[sizeof(::std::string)];
    i = ::flx::gc::generic::string_decoder (&tmp,s,i);
    new(p) ::re2::RE2 (*(::std::string*)(&tmp));
    destroy((::std::string*)&tmp);
    return i;
  }
  """; 
  private type RE2_ = "::re2::RE2" 
    requires RE2_serial, encoder "RE2_encoder", decoder "RE2_decoder"
  ;
  _gc_pointer _gc_type RE2_ type RE2 = "::re2::RE2*";
  gen _ctor_RE2 : string -> RE2 = "new (*PTF gcp, @0, false) RE2($1)";


  type StringPiece = "::re2::StringPiece";
    ctor StringPiece: string = "::re2::StringPiece($1)";
    ctor StringPiece: unit = "::re2::StringPiece()";
    ctor string: StringPiece = "$1.as_string()";
    fun len: StringPiece -> size = "(size_t)$1.length()";
    fun data: StringPiece -> +char = "(char*)$1.data()"; // cast away const
 
 
    instance Container[StringPiece,char] {
      fun len: StringPiece -> size = "$1.size()";
    }
    instance Eq[StringPiece] {
      fun == : StringPiece * StringPiece -> bool = "$1==$2";
    }
    instance Tord[StringPiece] {
      fun < : StringPiece * StringPiece -> bool = "$1<$2";
    }
    instance Str[StringPiece] {
      fun str: StringPiece -> string ="$1.as_string()";
    }

  type Arg = "::re2::Arg";

  type Encoding = "::re2::RE2::Encoding";
    const EncodingUTF8: Encoding = "::re2::RE2::EncodingUTF8";
    const EncodingLatin1: Encoding = "::re2::RE2::EncodingLatin1";

  type RE2Options = "::re2::RE2::Options";

    proc Copy: RE2Options * RE2Options = "$1.Copy($2);";

    fun encoding: RE2Options -> Encoding = "$1.encoding()";
    proc set_encoding: RE2Options * Encoding = "$1.set_encoding($2);";
    
    fun posix_syntax: RE2Options -> bool = "$1.posix_syntax()";
    proc set_posix_syntax: RE2Options * bool = "$1.set_posix_syntax($2);";

    fun longest_match: RE2Options -> bool = "$1.longest_match()";
    proc set_longest_match: RE2Options * bool = "$1.set_longest_match($2);";
    
    fun log_errors: RE2Options -> bool = "$1.log_errors()";
    proc set_log_errors: RE2Options * bool = "$1.set_log_errors($2);";
    
    fun max_mem: RE2Options -> int = "$1.max_mem()";
    proc set_max_mem: RE2Options * int = "$1.set_max_mem($2);";
    
    fun literal: RE2Options -> bool = "$1.literal()";
    proc set_literal: RE2Options * bool = "$1.set_literal($2);";

    fun never_nl: RE2Options -> bool = "$1.never_nl()";
    proc set_never_nl: RE2Options * bool = "$1.set_never_nl($2);";
    
    fun case_sensitive: RE2Options -> bool = "$1.case_sensitive()";
    proc set_case_sensitive: RE2Options * bool = "$1.set_case_sensitive($2);";
    
    fun perl_classes: RE2Options -> bool = "$1.perl_classes()";
    proc set_perl_classes: RE2Options * bool = "$1.set_perl_classes($2);";
    
    fun word_boundary: RE2Options -> bool = "$1.word_boundary()";
    proc set_word_boundary: RE2Options * bool = "$1.set_word_boundary($2);";
    
    fun one_line: RE2Options -> bool = "$1.one_line()";
    proc set_one_line: RE2Options * bool = "$1.set_one_line($2);";

    fun ParseFlags: RE2Options -> int = "$1.ParseFlags()";
   
  type ErrorCode = "::re2::RE2::ErrorCode";
    const NoError : ErrorCode = "::re2::RE2::NoError";
    const ErrorInternal: ErrorCode = "::re2::RE2::ErrorInternal";
    const ErrorBadEscape : ErrorCode = "::re2::RE2::ErrorBadEscape";
    const ErrorBadCharClass : ErrorCode = "::re2::RE2::ErrorBadCharClass";
    const ErrorBadCharRange : ErrorCode = "::re2::RE2::ErrorBadCharRange";
    const ErrorMissingBracket : ErrorCode = "::re2::RE2::ErrorMissingBracket";
    const ErrorMissingParen : ErrorCode = "::re2::RE2::ErrorMissingParen";
    const ErrorTrailingBackslash : ErrorCode = "::re2::RE2::ErrorTrailingBackslash";
    const ErrorRepeatArgument : ErrorCode = "::re2::RE2::ErrorRepeatArgument";
    const ErrorRepeatSize : ErrorCode = "::re2::RE2::ErrorRepeatSize";
    const ErrorRepeatOp: ErrorCode = "::re2::RE2::ErrorRepeatOp";
    const ErrorBadPerlOp: ErrorCode = "::re2::RE2::ErrprBadPerlOp";
    const ErrorBadUTF8: ErrorCode = "::re2::RE2::ErrorBadUTF8";
    const ErrorBadNamedCapture: ErrorCode = "::re2::RE2::ErrorBadNamedCapture";
    const ErrorPatternTooLarge: ErrorCode = "::re2::RE2::ErrorPatternTooLarge";

  type Anchor = "::re2::RE2::Anchor";
    const UNANCHORED: Anchor = "::re2::RE2::UNANCHORED";
    const ANCHOR_START: Anchor = "::re2::RE2::ANCHOR_START";
    const ANCHOR_BOTH: Anchor = "::re2::RE2::ANCHOR_BOTH";

  fun pattern: RE2 -> string = "$1->pattern()";
  fun error: RE2 -> string = "$1->error()";
  fun error_code: RE2 -> ErrorCode = "$1->error_code()";
  fun error_arg: RE2 -> string = "$1->error_arg()";
  fun ok: RE2 -> bool = "$1->ok()";
  fun ProgramSize: RE2 -> int = "$1->ProgramSize()";

  gen GlobalReplace: &string * RE2 * StringPiece -> int = "::re2::RE2::GlobalReplace($1, *$2, $3)";
  gen Extract: StringPiece * RE2 * StringPiece * &string -> bool = "::re2::RE2::Extract($1, *$2, $3, $4)";

  fun QuoteMeta: StringPiece -> string = "::re2::RE2::QuoteMeta($1)";
 
  fun PossibleMatchRange: RE2 * &string * &string * int -> bool = "$1->PossibleMatchRange($2,$3,$3,$4)";
  fun NumberOfCapturingGroups: RE2 -> int = "$1->NumberOfCapturingGroups()";
  fun NamedCapturingGroups: RE2 -> Stl_Map::stl_map[string, int] = "$1->NamedCapturingGroups()";

  // this function is fully general, just needs an anchor
  gen Match: RE2 * StringPiece * int * Anchor * +StringPiece * int -> bool = 
    "$1->Match($2, $3, $2.length(),$4, $5, $6)"
   ;

  noinline gen Match(re:RE2, var s:string) : opt[varray[string]] = {
    var emptystring = "";
    var n = NumberOfCapturingGroups re;
    var v = varray[StringPiece] (n.size+1,StringPiece emptystring);
    var Match-result = Match (re, StringPiece s, 0, ANCHOR_BOTH, v.stl_begin, n+1);
    return 
      if Match-result then
        Some$ map string of (StringPiece) v
      else 
        None[varray[string]]
    ;
  }

  gen apply (re:RE2, s:string) => Match (re,s);

  fun CheckRewriteString: RE2 * StringPiece * &string -> bool = "$1->CheckRewriteString($2, $3)";

  instance Set[RE2, string] {
    fun \in : string * RE2 -> bool =
      "$2->Match(::re2::StringPiece($1),0, ::re2::StringPiece($1).length(),::re2::RE2::ANCHOR_BOTH, (::re2::StringPiece*)0, 0)"
    ;
  }

  gen iterator (re2:string, var target:string) => iterator (RE2 re2, target);

  instance Streamable[RE2 * string, varray[string]] {
    gen iterator (r:RE2, var target:string) () : opt[varray[string]] = {
      var emptystring = "";
      var l = len target;
      var s = StringPiece target;
      var p1 = s.data;  
      var p = 0;
      var n = NumberOfCapturingGroups(r)+1;
      var v1 = varray[StringPiece] (n.size,StringPiece emptystring);
      var v2 = varray[string] (n.size,"");
    again:>
      var result = Match(r, s, p, UNANCHORED,v1.stl_begin, n);
      if not result goto endoff;
      for var i in 0 upto n - 1 do set(v2, i.size, string(v1.i)); done
      var p2 = v1.0.data;
      assert(v1.0.len.int > 0); // prevent infinite loop
      p = (p2 - p1).int+v1.0.len.int;
      yield Some v2;
      goto again;
    endoff:>
      return None[varray[string]];
    }
  }
  inherit Streamable[RE2 * string, Varray::varray[string]];

  // Extract Some match array or None if not matching.
  fun extract (re2:string, target:string) : opt[varray[string]] => iterator (RE2 re2, target) ();
  fun extract (re2:RE2, target:string) : opt[varray[string]] => iterator (re2, target) ();

}

open Set[RE2, string];

@h1 TRE regexps
@tangle tre.flx

class Tre
{
  open C_hack;
  requires package 'tre';
  type tre_regex_t = "regex_t";

  const tre_version: string = "tre_version()";

  private fun _tre_regcomp: &tre_regex_t * string  -> int =
    "tre_regncomp($1,$2.c_str(),$2.size(),REG_EXTENDED)"
  ;

  fun tre_regcomp (x:string): opt[tre_regex_t] = {
    var cr: tre_regex_t;
    var res = _tre_regcomp(&cr, x);
    return
      if res == 0 then Some cr else None[tre_regex_t] endif
    ;
  }

  fun nsub: &tre_regex_t -> int = "$1->re_nsub+1";

  ctypes regoff_t;
  cstruct regmatch_t {
    rm_so: regoff_t;
    rm_eo: regoff_t;
  };

  fun add: +char * regoff_t -> +char = "$1+$2";
  fun sub: regoff_t * regoff_t -> int = "(int)($1-$2)";
  ctor int : regoff_t = "int($1)";

  private fun _tre_regexec:
    &tre_regex_t *     // the compiled regex
    string *               // string to search
    int *                  // number of matches to return
    +regmatch_t        // array to hold matches
    -> int
  =
    "tre_regnexec($1,$2.c_str(),$2.size(),$3,$4,0);"
  ;

  fun tre_regexec (re_in: tre_regex_t) (x:string): int * int * +regmatch_t =
  {
    var re = re_in;
    val nmatches = nsub$ &re;
    var matches = Carray::array_alloc[regmatch_t] nmatches;
    var res = _tre_regexec(&re, x, nmatches, matches);
    return res,nmatches,matches;
  }
}
@h1 Regular definitions
@tangle regdef.flx

class Regdef {
  union regex =
  | Alts of list[regex]
  | Seqs of list[regex]
  | Rpt of regex * int * int
  | Charset of string
  | String of string
  | Group of regex
  | Perl of string
  ;

  private fun prec: regex -> int =
  | Perl _ => 3
  | Alts _ => 3
  | Seqs _ => 2
  | String _ => 2
  | Rpt _ => 1
  | Charset _ => 0
  | Group _ => 0
  ;

  private fun hex_digit (i:int)=>
    if i<10 then string (char (ord (char "0") + i)) 
    else string (char (ord (char "A") + i - 10))
    endif
  ;
  private fun hex2(c:char)=>
    let i = ord c in
    "\\x" + hex_digit ( i / 16 ) + hex_digit ( i % 16 )
  ;
  private fun charset_quote(c:char)=>
    if c in "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstvuwxyz" then string c
    else hex2 c
    endif
  ;

  private fun hex(s:string when len s > 0uz)= {
    var r = ""; 
    for var i in 0uz upto len s - 1uz do
      r += charset_quote s.[i];
    done
    return r; 
  }

  fun ngrp (s:string)=> "(?:"+s+")";
  private fun cngrp (s:string, op: int, ip: int) => if ip > op then ngrp (s) else s endif; 

  fun render: regex -> string =
  | Alts rs => fold_left 
   (fun (acc:string) (elt:regex)=> 
     (if acc == "" then "" else acc + "|" endif) + (render elt)) 
    "" rs
  | Seqs rs => fold_left 
    (fun (acc:string) (elt:regex)=> acc + cngrp(render elt,2,prec elt))
    "" rs
  | Rpt (r,i,x) =>
    if i == 0 and x == -1 then ngrp (render r) + "*"
    elif i == 1 and x == -1 then ngrp (render r) + "+"
    elif i == 0 and x == 1 then ngrp (render r) + "?"
    else
      cngrp(render r,1,prec r) + "{" + str i + "," + if x < 0 then "" else str x endif + "}"
    endif

  | String s => hex(s)
  | Charset s => "[" + hex s + "]"
  | Group r => "(" + render r + ")"
  | Perl s => s
  ;
}

@h1 Syntax
@tangle regexps.fsyn

//$ Syntax for regular definitions.
//$ Binds to library class Regdef,
//$ which in turn binds to the binding of Google RE2.
SCHEME """(define (regdef x) `(ast_lookup (,(noi 'Regdef) ,x ())))""";

syntax regexps {
  priority 
    ralt_pri <
    rseq_pri <
    rpostfix_pri <
    ratom_pri
  ;

 
  //$ Regular definition binder.
  //$ Statement to name a regular expression.
  //$ The expression may contain names of previously named regular expressions.
  //$ Defines the LHS symbol as a value of type Regdef::regex.
  stmt := "regdef" sdeclname "=" sregexp[ralt_pri] ";" =># 
    """
    `(ast_val_decl ,_sr ,(first _2) ,(second _2) (some ,(regdef "regex" )) (some ,_4))
    """;

  //$ Inline regular expression.
  //$ Can be used anywhere in Felix code.
  //$ Returns a a value of type Regdef::regex.
  x[sapplication_pri] := "regexp" "(" sregexp[ralt_pri] ")" =># "_3";

  //$ Alternatives.
  private sregexp[ralt_pri] := sregexp[>ralt_pri] ("|" sregexp[>ralt_pri])+ =># 
    """`(ast_apply ,_sr (  
      ,(regdef "Alts")
      (ast_apply ,_sr (,(noi 'list) ,(cons _1 (map second _2))))))"""
  ;

  //$ Sequential concatenation.
  private sregexp[rseq_pri] := sregexp[>rseq_pri] (sregexp[>rseq_pri])+ =># 
    """`(ast_apply ,_sr ( 
      ,(regdef "Seqs")
      (ast_apply ,_sr (,(noi 'list) ,(cons _1 _2)))))"""
  ;


  //$ Postfix star (*).
  //$ Kleene closure: zero or more repetitions.
  private sregexp[rpostfix_pri] := sregexp[rpostfix_pri] "*" =># 
    """`(ast_apply ,_sr ( ,(regdef "Rpt") (,_1,0,-1)))"""
  ;

  //$ Postfix plus (+).
  //$ One or more repetitions.
  private sregexp[rpostfix_pri] := sregexp[rpostfix_pri] "+" =>#
    """`(ast_apply ,_sr ( ,(regdef "Rpt") (,_1,1,-1)))"""
  ;

  //$ Postfix question mark (?).
  //$ Optional. Zero or one repetitions.
  private sregexp[rpostfix_pri] := sregexp[rpostfix_pri] "?" =>#
    """`(ast_apply ,_sr (,(regdef "Rpt") (,_1,0,1)))"""
  ;

  //$ Parenthesis. Non-capturing group.
  private sregexp[ratom_pri] := "(" sregexp[ralt_pri] ")" =># "_2";

  //$ Group psuedo function.
  //$ Capturing group.
  private sregexp[ratom_pri] := "group" "(" sregexp[ralt_pri] ")" =># 
    """`(ast_apply ,_sr ( ,(regdef "Group") ,_3))"""
  ;

  //$ The charset prefix operator.
  //$ Treat the string as a set of characters,
  //$ that is, one of the contained characters.
  private sregexp[ratom_pri] := "charset" String =># 
    """`(ast_apply ,_sr ( ,(regdef "Charset") ,_2))"""
  ;

  //$ The string literal.
  //$ The given sequence of characters.
  //$ Any valid Felix string can be used here.
  private sregexp[ratom_pri] := String =># 
    """`(ast_apply ,_sr ( ,(regdef "String") ,_1)) """
  ;

  //$ The Perl psuedo function.
  //$ Treat the argument string expression as
  //$ a Perl regular expression, with constraints
  //$ as specified for Google RE2.
  private sregexp[ratom_pri] := "perl" "(" sexpr ")" =># 
    """`(ast_apply ,_sr ( ,(regdef "Perl") ,_3)) """
  ;

  //$ The regex psuedo function.
  //$ Treat the argument Felix expression of type Regdef::regex
  //$ as a regular expression.
  private sregexp[ratom_pri] := "regex" "(" sexpr ")" =># "_3";

  //$ Identifier.
  //$ Must name a previously defined variable of type Regdef:;regex.
  //$ For example, the LHS of a regdef binder.
  private sregexp[ratom_pri] := sname=># "`(ast_name ,_sr ,_1 ())";
 
}

@h1 Lexer
@tangle lexer.flx
class Lexer
{
  pod type lex_iterator = "char const*";
  fun start_iterator : string -> lex_iterator = "$1.c_str()";
  fun end_iterator: string -> lex_iterator = "$1.c_str()+$1.size()";
  fun bounds (x:string): lex_iterator * lex_iterator = {
    return
      start_iterator x,
      end_iterator x
    ;
  }
  fun string_between: lex_iterator * lex_iterator -> string =
   "::std::string($1,$2)";

  fun + : lex_iterator * int -> lex_iterator = "$1 + $2";
  fun - : lex_iterator * int -> lex_iterator = "$1 - $2";
  fun - : lex_iterator * lex_iterator -> int = "$1 - $2";
  fun deref: lex_iterator -> char = "*$1";
}

instance Eq[Lexer::lex_iterator] {
  fun == :Lexer::lex_iterator * Lexer::lex_iterator -> bool = "$1==$2";
}

instance Tord[Lexer::lex_iterator] {
  fun < :Lexer::lex_iterator * Lexer::lex_iterator -> bool = "$1<$2";
}

open Eq[Lexer::lex_iterator];


