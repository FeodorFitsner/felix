@title Program
@tangler __init__.flx   = share/lib/std/program/__init__.flx
@tangler env.flx   = share/lib/std/program/env.flx
@tangler cmdopt.flx   = share/lib/std/program/cmdopt.flx
@tangler shell.flx   = share/lib/std/program/shell.flx
@tangler process.flx   = share/lib/std/program/process.flx
@tangler signal.flx   = share/lib/std/program/signal.flx
@tangler system.flx   = share/lib/std/program/system.flx
@tangler dynlink.flx   = share/lib/std/program/dynlink.flx

@h1 Synopsis
@tangle __init__.flx

include "std/program/cmdopt";
include "std/program/system";
include "std/program/shell";
include "std/program/dynlink";
include "std/program/env";
include "std/program/process";
include "std/program/signal";


@h1 Environment Variables
@tangle env.flx
//$ Access environment variables.
class Env_class[os]
{
  //$ Separator for filename lists
  virtual fun pathsep: 1 -> string;

  //$ Get the value of a given variable.
  //$ Returns empty string if the variable doesn't exist.
  fun getenv:string -> string =
    "::flx::rtl::strutil::atostr(std::getenv($1.c_str()))"
    requires package "flx_strutil", Cxx_headers::cstdlib;

  //$ Get the value of a given variable.
  //$ Returns specified default if the variable doesn't exist.
  fun getenv(name:string,dflt:string):string=>let result = getenv(name) in 
    if String::len result != 0uz then result else dflt endif
  ;

  fun getenvlist (name:string) : list[string] =>
     split (getenv name, #pathsep)
  ;
}

instance Env_class[Win32] { fun pathsep() => ";"; }
instance Env_class[Posix] { fun pathsep() => ":"; }

class Env
{
  if PLAT_WIN32 do
    inherit Env_class[Win32];
  else
    inherit Env_class[Posix];
  done
}


@h1 Command Line Options
@tangle cmdopt.flx

open class CmdOpt 
{
  // Convert key/value pairs represented like -I path
  // into form --include=path
  noinline fun cvt-key-arg (keys: list[string * string]) (x:list[string]) = 
  {
     var out = Empty[string];
     var inp = x.iterator;
     for word in inp do
       match keys.find word with
       | #None => out = Cons (word,out);
       | Some prefix => 
         match inp() with
         | #None => println$ "Error, expected argument to option " + word;
         | Some arg => out = Cons (prefix+"=" + arg, out);
         endmatch;
       endmatch;
     done
     return rev out;
  }

  // Parse key value pairs represented by --key=value.
  // Allows multiple values to be given.
  // Stores reversed list of values.
  // Returns ordered list of non-handled elements.
  var rekv = RE2 "(--.*)=(.*)";
  noinline gen parse-key-multi-value (keys:list[string]) (d:strdict[list[string]]) (x:list[string]) =
  {
    var out = Empty[string];
    var va = varray[StringPiece] (StringPiece "", StringPiece "", StringPiece "");
    for opt in x do
      if Match (rekv, StringPiece (opt), 0,ANCHOR_BOTH, va.stl_begin, va.len.int) do
        var key = va . 1 . string;
        if key in keys do
          val value= va . 2 . string ;
          val nuval = Cons (value, d.get_dflt (key,Empty[string]));
          d.add key nuval;
        else
          out = Cons (opt, out);
        done
      else
        out = Cons (opt, out);
      done
    done
    return rev out;
  }

  // Parse key value pairs represented by --key=value.
  // Keys must be unique.
  // Stores reversed list of values.
  // Returns ordered list of non-handled elements.
  noinline gen parse-key-single-value (keys:list[string]) (d:strdict[string]) (x:list[string]) =
  {
    var out = Empty[string];
    var va = varray[StringPiece] (StringPiece "", StringPiece "", StringPiece "");
    for opt in x do
      if Match (rekv, StringPiece (opt), 0,ANCHOR_BOTH, va.stl_begin, va.len.int) do
        var key = va . 1 . string;
        if key in keys do
          val value= va . 2 . string ;
          match d.get key with
          | #None => d.add key value;
          | _ => println$ "Duplicate option '" + opt +"'";
          endmatch;
        else
          println$ "Invalid option '" + opt+"'";
        done
      else
        out = Cons (opt, out);
      done
    done
    return rev out;
  }


  // Parse keys given by --key.
  // Allows multiple values.
  // Stores count of occurences.
  var rek = RE2 "(--.*)";
  noinline gen parse-key (keys:list[string]) (d:strdict[int]) (x:list[string]) =
  {
    var out = Empty[string];
    var va = varray[StringPiece] (StringPiece "", StringPiece "");
    for opt in x do
      if Match (rek, StringPiece (opt), 0,ANCHOR_BOTH, va.stl_begin, va.len.int) do
        var key = va . 1 . string;
        if key in keys do
          val nuval =d.get_dflt (key,0) + 1;
          d.add key nuval;
        else
          println$ "Invalid option '" + opt+"'";
        done
      else
        out = Cons (opt, out);
      done
    done
    return rev out;
  }

  // Parse keys given by -abcd
  // Allows multiple values.
  // Stores count of occurences.
  // Replaces option letter with specified long option key.
  // Returns ordered list of non-handled elements.
  var resw = RE2 "(-.*)";
  noinline gen parse-switches (switchmap: list[char * string] ) (d:strdict[int]) (x:list[string]) =
  {
    var out = Empty[string];
    var va = varray[StringPiece] (StringPiece "", StringPiece "");
    for opt in x do
      if Match (resw, StringPiece (opt), 0,ANCHOR_BOTH, va.stl_begin, va.len.int) do
        var switches = va . 1 . string . [1 to];
        for switch in switches do
          match switchmap.find switch with
          | #None =>
            println$ "Invalid option " + opt + " char '" + str switch+"'";
          | Some key=>
            val nuval = d.get_dflt (key,0) + 1;
            d.add key nuval;
          endmatch;
        done
      else
        out = Cons (opt, out);
      done
    done
    return rev out;
  }

  typedef cmdspec_t = (
    split-key-value-spec: list[string * string],
    multi-valued-keys-spec: list[string], 
    single-valued-keys-spec: list[string], 
    switches-spec: list[string], 
    short-switch-map-spec: list[char * string]
  );

  typedef cmdopt-parse-result_t = (
     multi-valued-keys : strdict[list[string]],
     single-valued-keys : strdict[string],
     switches : strdict[int],
     positional : list[string]
  );

  ctor cmdopt-parse-result_t () =>
  (
    multi-valued-keys = strdict[list[string]](), 
    single-valued-keys = strdict[string](),
    switches = strdict[int](),
    positional = Empty[string]
  );

  noinline gen parse-cmdline (spec:cmdspec_t) (x:list[string]) : cmdopt-parse-result_t = {
    var result = cmdopt-parse-result_t ();
    var nonk = cvt-key-arg spec.split-key-value-spec x;
    nonk = parse-key-multi-value spec.multi-valued-keys-spec result.multi-valued-keys nonk;
    nonk = parse-key-single-value spec.single-valued-keys-spec result.single-valued-keys nonk;
    nonk = parse-key spec.switches-spec result.switches nonk;
    result.positional = parse-switches spec.short-switch-map-spec result.switches nonk;
    return result;
  }
}

@h1 Process
@tangle process.flx

class Process_class[os, process_status_t]
{
  virtual gen popen_in : string -> Cstdio::ifile;
  virtual gen pclose: Cstdio::ifile -> process_status_t; 
}

class Process {
if PLAT_WIN32 do
  inherit Win32Process;
else
  inherit PosixProcess;
done
}

@h1 System Call
@tangle system.flx

class System
{
  const argc:int = "PTF argc" requires property "needs_ptf";
  const _argv:&&char= "PTF argv" requires property "needs_ptf";

  fun argv:int -> string = '::std::string($1<0||$1>=PTF argc??"":PTF argv[$1])' 
    requires property "needs_ptf";
  fun argv_dflt (x:int) (y:string) => match argv x with | "" => y | a => a;

  fun args () => List::map (argv) (List::range argc);

  proc setargs : + (+char) * size = "PTF argc=$2; PTF argv=$1;" requires property "needs_ptf";
  proc setargs[N] (a:string^N) 
  {
    gen myget(i:size)=>a.i.cstr;
    var x = varray[+char] (a.len,a.len,myget);
    setargs (x.stl_begin,x.len);
  }

  gen system (cmd:string) : int => Shell::system(cmd);
  gen exit: int -> any = '::std::exit($1)' requires Cxx_headers::cstdlib;
  gen abort: 1 -> any = "::std::abort($1)" requires Cxx_headers::cstdlib;
  _gc_pointer type ptf_t = "thread_frame_t*";
  const ptf:ptf_t = "ptf" requires property "needs_ptf";

  //$ pexit examines the return code from a system call.
  //$ If the code is 0 it exists with 0.
  //$ On Windows:
  //$    if the code is -1, it exits with errno.
  //$    otherwise code 3
  //$ On Unix:
  //$   if the code is non-zero then
  //$     if the callout aborted, return its abort code.
  //$     if the callout died due to a signal, exit with code 2
  //$     otherwise exit with code 3
  //$ In both these cases a non-zero return causes a message
  //$ to be printed on stderr.

  if PLAT_WIN32 do
    proc pexit(e:int)
    {
      if e != 0 do
        if e == -1 do
          err :=  errno;
          eprintln$ "Error "+err.str+" in flx: " + strerror err;
          System::exit err.int;
        else
          eprintln$ "Unknown error in shell " + str e;
          System::exit 3;
        done
      done
      System::exit e;
    }
  else
    proc pexit(e:int)
    {
      if e != 0 do
        if PosixProcess::WIFEXITED e.PosixProcess::process_status_t do
          err :=  PosixProcess::WEXITSTATUS e.PosixProcess::process_status_t;
          eprintln$ "Error "+err.str+" in flx: " + strerror err.errno_t;
          System::exit err;
        elif PosixProcess::WIFSIGNALED e.PosixProcess::process_status_t do
          sig := Process::WTERMSIG e.PosixProcess::process_status_t;
          eprintln$ "Shell terminated by signal " + str sig;
          System::exit 2;
        else
          eprintln$ "Unknown error in shell " + str e;
          System::exit 3;
        done
      done
      System::exit e;
    }
  done

  gen get_stdout(x:string) : int * string => Shell::get_stdout x;

}

@h1 Shell
@tangle shell.flx

// Note Shell_class interface doesn't use process_status_t
// but the implementation does.

class Shell_class[OS, process_status_t]
{
  // Quote a single argument.
  // Note: kills Bash wildcard replacement.
  virtual fun quote_arg:string->string;

  // Mainly for Windows we need a way to quote command line strings too.
  virtual fun quote_line_for_system: string->string;
  virtual fun quote_line_for_popen: string -> string;

  virtual fun parse: string -> list[string];

  //$ System command is ISO C and C++ standard.
  gen raw_system: string -> int = "::std::system($1.c_str())"
    requires Cxx_headers::cstdlib
  ;

  //$ get_stdout is a synchronous version of popen_in/pclose pair.
  virtual gen raw_get_stdout : string -> int * string;

  //$ create prototype command strings from arg list.
  fun create_system_command (s:list[string]) : string =>
    quote_line_for_system $ catmap[string] ' ' quote_arg s
  ;
  fun create_popen_command (s:list[string]) : string =>
    quote_line_for_popen $ catmap[string] ' ' quote_arg s
  ;

  //$ basic command with line quoting.
  gen basic_system (cmd: string) :int => 
    cmd.quote_line_for_system.raw_system
  ;
  gen basic_get_stdout (cmd: string) : int * string =>
    cmd.quote_line_for_popen.raw_get_stdout
  ;

  // string argument
  gen system (cmd:string) = {
    if Env::getenv "FLX_SHELL_ECHO" != "" do
      eprintln$ "[system] " + cmd;
    done
    return basic_system cmd;
  }

  gen get_stdout (cmd:string) : int * string = {
    if Env::getenv "FLX_SHELL_ECHO" != "" do
      eprintln$ "[get_stdout] " + cmd;
    done
    return basic_get_stdout cmd;
  }

  // list of string argument
  gen system (args:list[string]) : int =>
    args.create_system_command.system
  ;

  gen system[T with Streamable[T,string]] (args:T) : int =
  {
    var lst = Empty[string];
    for arg in args do 
      lst = lst + arg; 
    done
    return system lst;
  }  


  // arbitrary Streamable argument
  gen get_stdout (args:list[string]) : int * string =>
    args.create_popen_command.get_stdout
  ;
 
  gen get_stdout[T with Streamable[T,string]] (args:T) : int * string =
  {
    var lst = Empty[string];
    for arg in args do 
      lst = lst + arg; 
    done
    return get_stdout lst;
  }  

}

class Shell {
if PLAT_WIN32 do
  inherit CmdExe;
else
  inherit Bash;
done
}

@h1 Signals
@tangle signal.flx

body ctrl_c_flag = """
  static bool ctrl_c_flag = false;
  bool get_ctrl_c_flag() { return ctrl_c_flag; }
  void set_ctrl_c_flag(int) { ctrl_c_flag = true; }
""";


class Signal_class [os] {
  gen get_ctrl_c_flag: 1 -> bool requires ctrl_c_flag;
  proc set_ctrl_c_flag: int requires ctrl_c_flag;
  virtual proc trap_ctrl_c: 1;

}

class Signal {
if PLAT_WIN32 do
  inherit Win32Signal;
else
  inherit PosixSignal;
done
}

@h1 Dynamic Linkage
@tangle dynlink.flx

@title Dynamic Loading
@h2 Synopsis
This subsystem provides the ability to load,link or otherwise
access program code at run time. We use the name @{DLL} to refer
to a dynamically loaded file containing executable instructions,
on Windows this is a dynamic link library which usually ends
in extension @{.dll} whilst on Linux we have shared libraries
with extension @{.so} and on OSX we use files with extension @{.dylib}.

There is a confusing array of operations provided here which will
require refactoring in the future. 

The core platform dependent operations are implemented in C++
and configuration and compile time choices determine the
platform supported.

These core operations are wrapped, in C++, to remove the
file loading dependencies, and provide resource control
integrated with the garbage collector. 

We use @{LoadLibrary} on Windows and @{dlopen} on Unix platforms
wrapped inside a C++ class @{flx_dynlink_t} that represents
a library, in Felix the type @{flx_library} is used.

Felix generated code does not permit variables to be
stored in static storage. Instead, a structure is used
to contain Felix top level variables. For historical
reasons objects are called <em>thread frames.</em>

Members of a thread frame are accessed in Felix bindings
to C++ using the macro @{PTF} which stands for <em>pointer
to thread frame.</em>

A Felix generated shared library requires an instance to be 
created which is a closure: a pair consisting of the library code
and a @{thread_frame_t} object which is allocated on the heap.
The closure object has the type @{flx_libinst_t} in C++
and @{flx_instance} in Felix.

Instances require a fixed protocol which involves
the library containing exported symbols which can
be linked using @{LoadProcAddress} on Windows
or @{dlsym} on unix, which can be used to construct
the required thread frame. High level Felix functions
require he thread frame because it contains a pointer
to the garbage collector which in turn provides the
system allocator.

Higher level abstractions require more fixed
symbols. In particular, there is a protocol
for loading a special kind of library 
called a <em>plugin</em> which make separate
compilation of and use of dynamic libraries
particularly convenient.

@h2 The dynamic link library @{Dynlink}
@tangle dynlink.flx
class Dynlink
{
@h3 C++ support package.
@tangle dynlink.flx
  requires package "flx_dynlink";

@h3 Error handling.
The current version of the library requires dynamic link attempts
to succeed. If they fail an exception is thrown which aborts
the program unless specifically caught. In future, we may
provide an interface based on option types which enforces
user level error checking as well.
@tangle dynlink.flx
  //$ Exception thrown if dynamic linkage fails.
  type flx_link_failure_t = "::flx::rtl::flx_link_failure_t";

  //$ Constructor for dynamic linkage exception.
  ctor flx_link_failure_t : string * string * string = "::flx::rtl::flx_link_failure_t($1,$2,$3)";

  //$ Extractors.
  fun filename : flx_link_failure_t -> string = "$1.filename";
  fun operation : flx_link_failure_t -> string = "$1.operation";
  fun what : flx_link_failure_t -> string = "$1.what";

  //$ Delete returned exception.
  proc delete : cptr[flx_link_failure_t] = "delete $1;";

  //$ This doesn't belong here but it will do for now
  fun get_debug_driver_flag : 1 -> bool = "PTF gcp->debug_driver" requires property "needs_gc"; 

@h2 Library handle @{flx_library}
A platform independent handle which can refer to a dynamic
link library object. Operations in this category are universal
and apply to all dynamic link libraries, whether or not they
were generated by Felix.
@tangle dynlink.flx
  //$ Type of a DLL (dynamic link library) object.
  _gc_pointer type flx_library = "::flx::rtl::flx_dynlink_t*";

@h3 Constructor for @{flx_library</code>: <code>create_library_handle}
The constructor makes an unpopulated library handle
not associated with any particular DLL.
@tangle dynlink.flx
  //$ Create a fresh DLL object.
  fun create_library_handle: bool ->flx_library=
    "new(*PTF gcp, ::flx::rtl::flx_dynlink_ptr_map, false) ::flx::rtl::flx_dynlink_t($1)";

@h3 Load a library @{dlopen}
This procedure associates a library handle with a particular
file name and also attempts to load the library.
@tangle dynlink.flx
  //$ Link a DLL using given filename.
  //$ May throw flx_link_failure_t.
  proc dlopen:flx_library * string = "$1->dynamic_link($2);";

  //$ Link a DLL using given filename and modulename.
  //$ May throw flx_link_failure_t.
  proc modopen:flx_library * string * string = 
    "$1->dynamic_link_with_modulename($2, $3);"
  ;

   //$ Link static 
  proc set_entry_points : flx_library * string * address * address =
    "$1->static_link($2,(::flx::rtl::thread_frame_creator_t)$3, (::flx::rtl::start_t)$4, NULL);"
  ;

@h3 Load a library from registry @{regopen}
Given a registry, simulate dynamic linkage.
@tangle dynlink.flx
  typedef module_dictionary_t = StrDict::strdict[address];
  typedef registry_t = StrDict::strdict[module_dictionary_t];
  fun get_module_registry_address_address: 1 -> &&registry_t = 
    "(void****)(void*)&(PTF gcp->collector->module_registry)"
    requires property "needs_gc";

  // severe hackery: if the registry isn't initialised,
  // create one, store its address in the GC object, and make
  // it a root so the GC scans it: the GC isn't owned by itself,
  // but the registry is owned by the GC.
  gen get_module_registry  () :registry_t = {
    var ppregistry : &&registry_t = #get_module_registry_address_address;
    var pregistry : &registry_t = *ppregistry;
    if C_hack::isNULL (pregistry) do
      pregistry = new (StrDict::strdict[module_dictionary_t] ());
      ppregistry <- pregistry;
      Gc::add_root (C_hack::cast[address] (pregistry));
    done
    return *pregistry;
  }

  noinline proc regopen (registry:registry_t) (lib:flx_library, modulename:string)
  {
     //println$ "regopen " + modulename;
     var mod = StrDict::get registry modulename;
     match mod with
     | #None => 
       //println$ "Not in registry, using dlopen for " + modulename;
       modopen$ lib, modulename+#Filename::dynamic_library_extension, modulename;
     | Some dict =>
       //println$ "Found module "+modulename+" in registry"; 
       var tfc = dict.get_dflt (modulename+"_create_thread_frame", NULL);
       //println$ "Thread frame creator = " + str tfc;
       if tfc == NULL do
         raise$ flx_link_failure_t(modulename,"regopen","Cannot find symbol " + modulename+"_create_thread_frame in module registry for " + modulename);
       done
       var start_sym = dict.get_dflt (modulename+"_flx_start",NULL);
       if start_sym == NULL do
         raise$ flx_link_failure_t(modulename,"regopen","Cannot find symbol " + modulename+"_flx_start in module registry for "+modulename);
       done
       //println$ "Start symbol = " + str start_sym;
       set_entry_points$ lib,modulename,tfc, start_sym;
     endmatch;
  }

@h3 Get the filename associated with a library handle: @{filename}
@tangle dynlink.flx
  //$ Get the filename of a DLL.
  fun filename : flx_library -> string = "$1->filename";

  //$ Get the modulename of a DLL.
  fun modulename : flx_library -> string = "$1->modulename";

  //$ Get the threadframe creator function
  fun get_thread_frame_creator_as_address: flx_library -> address  = "(void*)$1->thread_frame_creator";

  //$ Get start function
  fun get_start_as_address: flx_library -> address  = "(void*)$1->start_sym";

  noinline proc add_symbol  (modulename:string, symbolname:string, adr:address)
  {
     //println$ "add symbol " + symbolname + " to module " + modulename+ " value " + str adr;
     var registry = #Dynlink::get_module_registry;
     var mod = #{
       match get registry modulename with
       | #None =>
          var mod = #strdict[address];
          add registry modulename mod;
          return mod;
       | Some dict => return dict;
       endmatch;
     };
     mod.add symbolname adr;
  }


@h3 Unlink a dll : @{dlclose}.
This routine reduces the reference count of a library handle
by one, and if it drops to zero unloads the library at the
OS level.

References counts are increase by one when instances are created.
The initial @{dlopen} sets the reference count to 1.

Unlinking clears the association of the handle with the filename
and tells the platform linker to unlink the library.
However this does not necessarily unload the library because
the platform linker may also reference count the library,
and the user may link the same DLL twice using distinct
library handles.

Because of the badly designed structure of C programs,
unloading a library physically is not safe and cannot
be made safe. Even with tight control of library code
generation, it is very hard to ensure there are no references
left to a library. References include pointers to functions,
vtables, rtti objects, strings, other constants, and sometimes
even variables.
@tangle dynlink.flx
  //$ Unlink a DLL.
  //$ Unsafe! Use with extreme caution.
  //$ May cause pointers into the DLL code segment to dangle.
  proc dlclose:flx_library = "$1->unlink();";

@h3 Get the address of an exported symbol: @{dlsym}
This routine takes a library and a string argument
and tries to find the value associated with the string
in the library symbol table, using @{GetProcAddress}
on Windows or @{dlsym} on Unix. This action is independent
of whether the calling program was linked dynamically
or statically.

For functions, this operator returns a function
pointer. For variables, it returns the address of the variable.
DO not forget the extra dereference requires if the variable
is itself a pointer.
@tangle dynlink.flx
  //$ Find raw address of a symbol in a DLL.
  //$ This function now ALWAYS does a dlsym
  //$ (or Windows equivalent)
  //$ even for static linkage: after all 
  //$ statically linked executables can still
  //$ load DLLs at run time.
  fun raw_dlsym:flx_library * string->address =
      "FLX_SDLSYM($1->library,$2.c_str())";

  noinline fun find_sym(lib:flx_library, sym:string) : address =
  {
    if lib.filename == "" do
      var reg = #get_module_registry;
      match reg.get lib.modulename with
      | #None => return NULL;
      | Some dict =>
        match dict.get sym with
        | #None => return NULL;
        | Some sym => return sym;
        endmatch;
      endmatch; 
    else 
      return raw_dlsym (lib,sym);
    done
  }

@h2 Library instance type @{flx_instance}
A library instance is a closure consisting of the
library code, represent by a library handle, 
together with a pointer to an instance of the
libraries thread frame. Operations in this category
only work with Felix generated library objects.
@tangle dynlink.flx
  //$ Type of a DLL (dynamic link library) instance.
  //$ Conceptually this is a pair consisting of
  //$ a library object and a global data frame object.
  _gc_pointer type flx_instance = "::flx::rtl::flx_libinst_t*";

@h3 Library instance constructor @{create_instance_handle}
Create a new library instance handle unassociated with any
library or thread frame.
@tangle dynlink.flx
  //$ Create a fresh DLL instance object.
  fun create_instance_handle: bool->flx_instance=
    "new(*PTF gcp, ::flx::rtl::flx_libinst_ptr_map, false) ::flx::rtl::flx_libinst_t($1)";

@h3 Create a library instance from a library: @{create}
This procedure creates a thread frame from a library,
initialises it, and sets the given library instance
with the library handle and thread frame.
The instance handle should not already be associated with a library
or thread frame.
@tangle dynlink.flx 
  //$ Create a DLL instance from a DLL.
  //$ This is a procedure, so maybe the caller is too
  //$ which means the thread frame must be available.
  proc create: flx_library * flx_instance =
    "$2->create($1,PTF gcp,PTF argc,PTF argv,PTF flx_stdin, PTF flx_stdout, PTF flx_stderr, false);" 
    requires property "needs_gc"
  ;

  proc create_with_args: flx_library * flx_instance * int * + (+char) =
    "$2->create($1,PTF gcp,$3,$4,PTF flx_stdin, PTF flx_stdout, PTF flx_stderr, false);" 
    requires property "needs_gc"
  ;

  proc create_with_args (lib:flx_library, inst:flx_instance, args:list[string])
  {
    // convert list to a varray of strings
    var a = varray args; 

    // now convert to varray of char pointers
    gen myget(i:size)=>a.i.cstr; 
    var x = varray[+char] (a.len,a.len,myget); 
    create_with_args (lib,inst,x.len.int,x.stl_begin);
  }


@h3 Get the filename from an instance @{filename}.
@tangle dynlink.flx 
  //$ Get the filename of a DLL from an instance of it.
  fun filename : flx_instance -> string = "::std::string($1->lib->filename)";

@h3 Get the startup procedure from an instance @{filename}.
Felix generated libraries contain a symbol which is used
to initialise the thread frame. This initialisation is
in addition to that performed when the instance is created.
Typically the instance creation initialisation simply invokes
the C++ default constructor and sets a couple of critical
variables including a pointer to the garbage collector
and standard input/output streams.

The startup procedure we get here, on the other hand,
usually refers to the client program when using the
scripting model; the behaviour of the program is 
the observable side effects of this initialisation
procedure.

For plugin libraries, the initialisation procedure is used
to construct default values or initialise starting state.

The initialisation procedure is represent by a pointer
to a continuation object, type @{cont}, which has to be run
by a scheduler after associating it with a fibre:
the procedure is <em>not</em> a C function.
@tangle dynlink.flx 
  //$ Get the initialisation continuation of an instance.
  fun get_init: flx_instance -> cont = "$1->start_proc";

@h3 Get the library associated with an instance.
@tangle dynlink.flx
  //$ Get the DLL associated with an instance.
  fun get_library: flx_instance -> flx_library = "$1->lib";

@h3 Get the thread frame associated with an instance.
Since we don't know the type of the thread frame here,
it is returned as a pure address.
@tangle dynlink.flx
  //$ Get the thread frame (global data object) of an instance.
  fun get_thread_frame: flx_instance -> address = "(void*)$1->thread_frame";

@h3 Convenience constructor for an instance @{init_lib}
This function creates a library handle and instance handle
and loads the library given a filename, all in one operation.
Then it runs the startup initialisation procedure.
Finally the instance is returned.
@tangle dynlink.flx

  //$ Create, link, and prepare a DLL instance from a modulename.
  //$ NOTE: libraries created here do not need to be roots
  // The code is never deleted (due to design issues with C).
  // If the library isn't reachable, you can't create an instance.
  // If an instance is created, it reaches the library.
  noinline gen prepare_lib(modulename:string):flx_instance = {
    var library = create_library_handle(get_debug_driver_flag());
    //Gc::add_root (C_hack::cast[address] library);
    var linstance =  create_instance_handle(get_debug_driver_flag());
    regopen #get_module_registry (library,modulename);
    create (library,linstance);
    return linstance;
  }

  //$ Create, link, and prepare a DLL instance from a modulename.
  noinline gen prepare_lib_with_args(modulename:string, args:list[string]):flx_instance = {
    var library = create_library_handle(get_debug_driver_flag());
    //Gc::add_root (C_hack::cast[address] library);
    var linstance =  create_instance_handle(get_debug_driver_flag());
    regopen #get_module_registry (library,modulename);
    create_with_args (library,linstance,args);
    return linstance;
  }


  //$ Create, link, and initialise a  DLL instance from a modulename.
  noinline gen init_lib(modulename:string):flx_instance = {
    var linstance = prepare_lib(modulename);
    var init = get_init linstance;
    Fibres::run init;
    return linstance;
  }

  //$ Create, link, and initialise a  DLL instance from a modulename.
  noinline gen init_lib_with_args(modulename:string, args:list[string]):flx_instance = {
    var linstance = prepare_lib_with_args(modulename,args);
    var init = get_init linstance;
    Fibres::run init;
    return linstance;
  }


@h3 Convenience to run a program @{run_lib}
This function does the same as @{init_lib}.
@tangle dynlink.flx
  //$ Run a Felix program from a filename.
  proc run_lib(modulename:string)
  {
    var linstance = init_lib(modulename);
    C_hack::ignore(linstance);
  }

  // BUG: no return code!
  proc run_program(args:list[string])
  {
    match args with
    | Cons (h, t) =>
      var linstance = prepare_lib_with_args(h,t);
      var init = get_init linstance;
      Fibres::run init;
    | _ => ;
    endmatch;
  }


@h3 Checked version of @{dlsym}
This routine tries to find a symbol with the specified
name in an instance, if it is found, the resulting address
is cast to the specified type. It also prints a diagnostic
if the symbol cannot be found.
@tangle dynlink.flx
  //$ Find typed address of a symbol in a DLL.
  noinline fun flx_dlsym[T] (linst: flx_instance, sym:string) = {
    var library = Dynlink::get_library linst;
    var tf = Dynlink::get_thread_frame linst;
//println$ "Trying to load symbol " + sym + " from library " + linst.filename;
    var raw_sym = Dynlink::find_sym$ library, sym;
    if isNULL raw_sym do
      eprintln$ "Unable to load symbol " + sym + " from library " + linst.filename;
      raise$ flx_link_failure_t(linst.filename,"dlsym","Cannot find symbol " + sym); 
    done
//    eprintln$ "loaded symbol " + sym + " from library " + linst.filename + " address= " + str raw_sym;
    var typed_sym = C_hack::cast[T] raw_sym;
    return typed_sym, tf;
  }

@h2 Higher level wrappers for finding Felix functions.
Here make a set of higher level wrappers for finding 
standard protocol Felix function in DLLs. These wrappers
create a closure by binding the C address of the constructor
for the Felix function class in C++ to the library instance,
and return that. 

Closures returned by these function can be invoked as normal
Felix functions and procedures. Whereas a function defined
in the current files binds to  the thread frame implicitly,
with a library the instance is required to supply the
thread frame. The closures returned by these wrappers
are bound to the libraries thread frame so they can
be invoked with the ordinary syntax.

Note that these operations are not type safe. If you get
the type wrong all hell will break loose. This is because
dlsym finds functions by their C names and C++ entities
use mangled names we cannot compute in a portable way.
@tangle dynlink.flx
  //$ Return a closure representing a symbol in a DLL instance
  //$ of a function of no arguments.
  noinline fun func0[R] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address --> R] (linst, sym);
    return fun () => s tf;
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a function of one argument.
  noinline fun func1[R,A0] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 --> R] (linst, sym);
    return fun (a0:A0) => s (tf, a0);
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a function of two arguments.
  noinline fun func2[R,A0,A1] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 * A1 --> R] (linst, sym);
    return fun (var a0:A0, var a1:A1) => s (tf, a0, a1);
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a procedure of no arguments.
  noinline fun proc0 (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address --> void] (linst, sym);
    return proc () { s tf; };
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a procedure of one argument.
  noinline fun proc1[A0] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 --> void] (linst, sym);
    return proc (a0:A0) { s (tf, a0); };
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a procedure of two arguments.
  noinline fun proc2[A0,A1] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 * A1 --> void] (linst, sym);
    return proc (a0:A0,a1:A1) { s (tf, a0, a1); };
  }

@h2 Plugins.
A plugin is a special kind of DLL which supplies two
fixed entry points: a setup routine, which is called
to initialise the thread frame given a string argument,
and a single entry point which is subsequently called
and which typically returns an object type consisting
of a set of methods acting on the object state and
initialised thread frame context.

The setup routine typically take a string of configuration
parameters, extracts them with a parser, and stores them
in variables.

The current protocol is that the setup function must
be called "dllname_setup", the entry point name is passed
as a string. 

In order to accomodate static linking of plugins in the
future, the setup and entry point symbols would need to have
univerally unique names, since static linkage cannot work
with duplicate definitions, so the protocol will change
to require the library name as a prefix. Stay tuned.

@tangle dynlink.flx
  //$ Specialised routine(s) to load stylised plugin.
  //$ Two entry points:
  //$
  //$ setup: string -> int
  //$
  //$ is called to initialise the instance globals.
  //$
  //$ entry-point: arg -> iftype
  //$
  //$ is the primary entry point, typically an object factory, 
  //$ when called with an argument
  //$ of type arg_t it returns //$ an object of type iftype.
  //$
  //$ This function returns the object factory.
  //$ setup is called automatically with the supplied string.
  //$
  //$ There are 3 variants where the factory function accepts
  //$ 0, 1 and 2 arguments.
  noinline gen  load-plugin-func0[iftype] (
    dll-name: string,   // name of the DLL minus the extension
    setup-str: string="",  // string to pass to setup
    entry-point: string=""   // export name of factory function
  ) : unit -> iftype =
  {
    var entrypoint = if entry-point == "" then dll-name else entry-point;
    var linst = Dynlink::init_lib(dll-name);
    var sresult = Dynlink::func1[int,string] (linst, dll-name+"_setup") (setup-str);
    C_hack::ignore(sresult);
    if sresult != 0 call eprintln$ "[dynlink] Warning: Plugin Library " + dll-name + " set up returned " + str sresult;
    return Dynlink::func0[iftype] (linst, entrypoint);
  }

  noinline gen  load-plugin-func1[iftype, arg_t] (
    dll-name: string,   // name of the DLL minus the extension
    setup-str: string="",  // string to pass to setup
    entry-point: string=""   // export name of factory function
  ) : arg_t -> iftype =
  {
    var entrypoint = if entry-point == "" then dll-name else entry-point;
    var linst = Dynlink::init_lib(dll-name);
    var sresult = Dynlink::func1[int,string] (linst, dll-name+"_setup") (setup-str);
    C_hack::ignore(sresult);
    if sresult != 0 call eprintln$ "[dynlink] Warning: Plugin Library " + dll-name + " set up returned " + str sresult;
    return Dynlink::func1[iftype,arg_t] (linst, entrypoint);
  }

  noinline gen  load-plugin-func2[iftype, arg1_t, arg2_t] (
    dll-name: string,   // name of the DLL minus the extension
    setup-str: string="",  // string to pass to setup
    entry-point: string=""   // export name of factory function
  ) : arg1_t * arg2_t -> iftype =
  {
    var entrypoint = if entry-point == "" then dll-name else entry-point;
    var linst = Dynlink::init_lib(dll-name);
    var sresult = Dynlink::func1[int,string] (linst, dll-name+"_setup") (setup-str);
    C_hack::ignore(sresult);
    if sresult != 0 call eprintln$ "[dynlink] Warning: Plugin Library " + dll-name + " set up returned " + str sresult;
    return Dynlink::func2[iftype,arg1_t, arg2_t] (linst, entrypoint);
  }

@h2 Utilities and misc.
@tangle dynlink.flx

  //$ Execute an address representing a top
  //$ level exported felix procedure's C wrapper,
  //$ this creates a 'read to run' continuation object
  //$ by both constructing the object using the thread
  //$ frame of the instance as an argument, and calling
  //$ it to fix a null return address and an arbitrary
  //$ client data pointer as arguments to the call method.
  fun bind_proc: flx_instance * address * address -> cont =
    "$1->bind_proc($2,$3)";

  //$ Get the OS dependent handle representing a loaded DLL.
  //$ Return as an address. 
  fun dlib_of : flx_library -> address = "(void*)$1->library";

  //$ Throw an exception indicating the failure to 
  //$ find a symbol in a DLL.
  proc dlsym_err:flx_library*string="""
    throw ::flx::rtl::flx_link_failure_t($1->filename,$2,"symbol not found");
  """;

  //$ Run a procedure represented by a string name with
  //$ given thread frame.
  noinline proc run_proc (linstance:flx_instance, p: string, data: address)
  {
    var lib = get_library linstance;
    var sym = find_sym(lib, p);
    if isNULL(sym) call dlsym_err(lib,p);
    var f = bind_proc(linstance, sym, data);
    run f;
  }


}


