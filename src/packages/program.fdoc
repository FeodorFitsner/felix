@title Program
@tangler __init__.flx        = share/lib/std/program/__init__.flx
@tangler env.flx             = share/lib/std/program/env.flx
@tangler cmdopt.flx          = share/lib/std/program/cmdopt.flx
@tangler shell.flx           = share/lib/std/program/shell.flx
@tangler posix_shell.flx     = share/lib/std/posix/shell.flx
@tangler win32_shell.flx     = share/lib/std/win32/shell.flx
@tangler process.flx         = share/lib/std/program/process.flx
@tangler posix_errno.flx     = share/lib/std/posix/errno.flx
@tangler posix_process.flx   = share/lib/std/posix/process.flx
@tangler win32_process.flx   = share/lib/std/win32/process.flx
@tangler signal.flx          = share/lib/std/program/signal.flx
@tangler posix_signal.flx    = share/lib/std/posix/signal.flx
@tangler win32_signal.flx    = share/lib/std/win32/signal.flx
@tangler system.flx          = share/lib/std/program/system.flx
@tangler dynlink.flx         = share/lib/std/program/dynlink.flx

@h1 Synopsis
@tangle __init__.flx

include "std/program/cmdopt";
include "std/program/system";
include "std/program/shell";
include "std/program/dynlink";
include "std/program/env";
include "std/program/process";
include "std/program/signal";


@h1 Environment Variables
@tangle env.flx
//$ Access environment variables.
class Env_class[os]
{
  //$ Separator for filename lists
  virtual fun pathsep: 1 -> string;

  //$ Get the value of a given variable.
  //$ Returns empty string if the variable doesn't exist.
  fun getenv:string -> string =
    "::flx::rtl::strutil::atostr(std::getenv($1.c_str()))"
    requires package "flx_strutil", Cxx_headers::cstdlib;

  //$ Get the value of a given variable.
  //$ Returns specified default if the variable doesn't exist.
  fun getenv(name:string,dflt:string):string=>let result = getenv(name) in 
    if String::len result != 0uz then result else dflt endif
  ;

  fun getenvlist (name:string) : list[string] =>
     split (getenv name, #pathsep)
  ;
}

instance Env_class[Win32] { fun pathsep() => ";"; }
instance Env_class[Posix] { fun pathsep() => ":"; }

class Env
{
  if PLAT_WIN32 do
    inherit Env_class[Win32];
  else
    inherit Env_class[Posix];
  done
}


@h1 Command Line Options
@tangle cmdopt.flx

open class CmdOpt 
{
  // Convert key/value pairs represented like -I path
  // into form --include=path
  noinline fun cvt-key-arg (keys: list[string * string]) (x:list[string]) = 
  {
     var out = Empty[string];
     var inp = x.iterator;
     for word in inp do
       match keys.find word with
       | #None => out = Cons (word,out);
       | Some prefix => 
         match inp() with
         | #None => println$ "Error, expected argument to option " + word;
         | Some arg => out = Cons (prefix+"=" + arg, out);
         endmatch;
       endmatch;
     done
     return rev out;
  }

  // Parse key value pairs represented by --key=value.
  // Allows multiple values to be given.
  // Stores reversed list of values.
  // Returns ordered list of non-handled elements.
  var rekv = RE2 "(--.*)=(.*)";
  noinline gen parse-key-multi-value (keys:list[string]) (d:strdict[list[string]]) (x:list[string]) =
  {
    var out = Empty[string];
    var va = varray[StringPiece] (StringPiece "", StringPiece "", StringPiece "");
    for opt in x do
      if Match (rekv, StringPiece (opt), 0,ANCHOR_BOTH, va.stl_begin, va.len.int) do
        var key = va . 1 . string;
        if key in keys do
          val value= va . 2 . string ;
          val nuval = Cons (value, d.get_dflt (key,Empty[string]));
          d.add key nuval;
        else
          out = Cons (opt, out);
        done
      else
        out = Cons (opt, out);
      done
    done
    return rev out;
  }

  // Parse key value pairs represented by --key=value.
  // Keys must be unique.
  // Stores reversed list of values.
  // Returns ordered list of non-handled elements.
  noinline gen parse-key-single-value (keys:list[string]) (d:strdict[string]) (x:list[string]) =
  {
    var out = Empty[string];
    var va = varray[StringPiece] (StringPiece "", StringPiece "", StringPiece "");
    for opt in x do
      if Match (rekv, StringPiece (opt), 0,ANCHOR_BOTH, va.stl_begin, va.len.int) do
        var key = va . 1 . string;
        if key in keys do
          val value= va . 2 . string ;
          match d.get key with
          | #None => d.add key value;
          | _ => println$ "Duplicate option '" + opt +"'";
          endmatch;
        else
          println$ "Invalid option '" + opt+"'";
        done
      else
        out = Cons (opt, out);
      done
    done
    return rev out;
  }


  // Parse keys given by --key.
  // Allows multiple values.
  // Stores count of occurences.
  var rek = RE2 "(--.*)";
  noinline gen parse-key (keys:list[string]) (d:strdict[int]) (x:list[string]) =
  {
    var out = Empty[string];
    var va = varray[StringPiece] (StringPiece "", StringPiece "");
    for opt in x do
      if Match (rek, StringPiece (opt), 0,ANCHOR_BOTH, va.stl_begin, va.len.int) do
        var key = va . 1 . string;
        if key in keys do
          val nuval =d.get_dflt (key,0) + 1;
          d.add key nuval;
        else
          println$ "Invalid option '" + opt+"'";
        done
      else
        out = Cons (opt, out);
      done
    done
    return rev out;
  }

  // Parse keys given by -abcd
  // Allows multiple values.
  // Stores count of occurences.
  // Replaces option letter with specified long option key.
  // Returns ordered list of non-handled elements.
  var resw = RE2 "(-.*)";
  noinline gen parse-switches (switchmap: list[char * string] ) (d:strdict[int]) (x:list[string]) =
  {
    var out = Empty[string];
    var va = varray[StringPiece] (StringPiece "", StringPiece "");
    for opt in x do
      if Match (resw, StringPiece (opt), 0,ANCHOR_BOTH, va.stl_begin, va.len.int) do
        var switches = va . 1 . string . [1 to];
        for switch in switches do
          match switchmap.find switch with
          | #None =>
            println$ "Invalid option " + opt + " char '" + str switch+"'";
          | Some key=>
            val nuval = d.get_dflt (key,0) + 1;
            d.add key nuval;
          endmatch;
        done
      else
        out = Cons (opt, out);
      done
    done
    return rev out;
  }

  typedef cmdspec_t = (
    split-key-value-spec: list[string * string],
    multi-valued-keys-spec: list[string], 
    single-valued-keys-spec: list[string], 
    switches-spec: list[string], 
    short-switch-map-spec: list[char * string]
  );

  typedef cmdopt-parse-result_t = (
     multi-valued-keys : strdict[list[string]],
     single-valued-keys : strdict[string],
     switches : strdict[int],
     positional : list[string]
  );

  ctor cmdopt-parse-result_t () =>
  (
    multi-valued-keys = strdict[list[string]](), 
    single-valued-keys = strdict[string](),
    switches = strdict[int](),
    positional = Empty[string]
  );

  noinline gen parse-cmdline (spec:cmdspec_t) (x:list[string]) : cmdopt-parse-result_t = {
    var result = cmdopt-parse-result_t ();
    var nonk = cvt-key-arg spec.split-key-value-spec x;
    nonk = parse-key-multi-value spec.multi-valued-keys-spec result.multi-valued-keys nonk;
    nonk = parse-key-single-value spec.single-valued-keys-spec result.single-valued-keys nonk;
    nonk = parse-key spec.switches-spec result.switches nonk;
    result.positional = parse-switches spec.short-switch-map-spec result.switches nonk;
    return result;
  }
}

@h1 Process
@tangle process.flx

class Process_class[os, process_status_t]
{
  virtual gen popen_in : string -> Cstdio::ifile;
  virtual gen pclose: Cstdio::ifile -> process_status_t; 
}

class Process {
if PLAT_WIN32 do
  inherit Win32Process;
else
  inherit PosixProcess;
done
}

@h1 Posix Errno
@tangle posix_errno.flx

open class Errno 
{
  pod type errno_t = "int" requires C89_headers::errno_h;
  ctor int : errno_t = "$1";
  ctor errno_t : int = "$1";
  instance Eq[errno_t] {
    fun == : errno_t * errno_t -> bool= "$1==$2";
  }
  inherit Eq[errno_t];
 
  const errno : errno_t = "errno"; // SUCKS
  const ENOERROR : errno_t = "0";
  const EACCES: errno_t;
  const ENOENT: errno_t;
  const EAGAIN: errno_t;
  const ENOMEM: errno_t;
  const EEXIST: errno_t;
  const EINVAL: errno_t;
  const EINTR: errno_t; // call interrupted by a signal

  proc maybe_exit(var n:int) { if n != 0 do System::exit(errno.int); done }
  proc maybe_exit(var n:errno_t) { if n != ENOERROR  do System::exit(n.int); done }
  proc maybe_exit() { if errno != ENOERROR do System::exit(errno.int); done }

  // Unfortunately we get the crappy GNU version of strerror_r 
  // even if we don't define _GNU_SOURCE
if PLAT_WIN32 do
  proc strerror_r: errno_t *  carray[char] * size  = "(void)strerror_s($2, $3, $1);" 
    requires C89_headers::string_h /* on Linux.. on OSX it's in stdio.h */
  ;
else
  proc strerror_r: errno_t * carray[char] * size  = "(void)strerror_r($1, $2, $3);" 
    requires C89_headers::string_h 
  ;
done
  fun strerror(e:errno_t) : string = {
    if e.int == 0 do 
      return "OK"; 
    else
      var b:array[char,1000];
      var bad = "[strerror_r] Failed to find text for error number " + e.int.str;
      strncpy (carray (&b),bad._unsafe_cstr,1000.size); // safe because bad is a variable
      strerror_r(e,carray (&b), b.len.size);
      return string( carray (&b));
    done
  }
 
  gen strerror()=> strerror errno;

  instance Str[errno_t] { fun str (e:errno_t) => strerror e; }
  inherit Str[errno_t];

  // Auto error check support
  class Check[T] 
  {
    proc int_to_proc (var x:int) { if x == -1 do ehandler; done }
    fun int_to_int (var x:int) = { if x == -1 do ehandler; done return x; }
    fun pointer_to_pointer[U] (var p:&U) = { if C_hack::isNULL p do #ehandler; done return p; }
    virtual fun ehandler: unit -> any;
  }

  type check_ignore = "";
  instance Check[check_ignore] 
  {
    fun ehandler ():any = {}
  }
  type check_throw = "";
  instance Check[check_throw] 
  {
    fun ehandler ():any = { raise #strerror; }
  }
}

@h1 Posix Process
@tangle posix_process.flx

class PosixProcess {
  open PosixSignal;

  instance Process_class[Posix, process_status_t] 
  {
    gen popen_in: string -> Cstdio::ifile = 'popen($1.c_str(), "r")';
    gen pclose: Cstdio::ifile -> process_status_t = "pclose($1)";
  }
  inherit Process_class[Posix, process_status_t];

  type process_status_t = "int" requires Posix_headers::sys_wait_h;
  ctor int:process_status_t = "$1";
  ctor process_status_t : int = "$1";
  fun int_of_process_status_t: process_status_t -> int = "(int)$1";

  fun WIFCONTINUED: process_status_t -> bool = "WIFCONTINUED($1)!=0";
  fun WIFEXITED: process_status_t -> bool = "WIFEXITED($1)!=0";
  fun WIFSIGNALED: process_status_t -> bool = "WIFSIGNALED($1)!=0";
  fun WIFSTOPPED: process_status_t -> bool = "WIFSTOPPED($1)!=0";

  fun WEXITSTATUS: process_status_t -> int = "WEXITSTATUS($1)";
  fun WTERMSIG: process_status_t -> signal_t = "WTERMSIG($1)";
  fun WSTOPSIG: process_status_t -> signal_t = "WSTOPSIG($1)";

  // OSX only, not in Posix
  fun  WCOREDUMP: process_status_t -> int = "WCOREDUMP($1)";


  fun str(x:process_status_t) = {
    if WIFEXITED x do
       val e = x.WEXITSTATUS;
       return "Exit " + str e + ": " +e.errno_t.strerror;
    elif WIFSIGNALED x do
       val s = x.WTERMSIG;
       return "SIGNAL " + s.int.str + ": " + s.str;
    else
       return "Unknown temination status " + x.int.str;
    done
  }

  const environ: + (+char) = "environ" requires Posix_headers::unistd_h;

  type exec_result_t = "int";
  const bad_exec: exec_result_t = "-1";
  fun == : exec_result_t * exec_result_t -> bool= "$1==$2";

  gen execv:+char *  + (+char) -> exec_result_t = "execv($1, $2)" requires Posix_headers::unistd_h;
  gen execvp:+char *  + (+char) -> exec_result_t = "execvp($1, $2)" requires Posix_headers::unistd_h;
  gen execve:+char *  + (+char) * + (+char) -> exec_result_t = "execve($1, $2, $3)" requires Posix_headers::unistd_h;

  // do NOT try to fork Felix programs, it doesn't work
  // because of threads already running. We use fork only
  // to preceed exec() calls.
  type pid_t = "pid_t" requires Posix_headers::unistd_h;

  instance Str[pid_t] {
    fun str: pid_t -> string = "::flx::rtl::strutil::str<int>($1)" requires package "flx_strutil";
  }

  ctor int: pid_t = "((int)$1)";
  const child_process : pid_t = "0";
  const bad_process : pid_t = "-1";
  fun == : pid_t * pid_t -> bool= "$1==$2";

  gen fork: unit -> pid_t = "fork()" requires Posix_headers::unistd_h;

  union spawn_result_t = 
  // returned to parent process
  | BadFork of errno_t  
  | ProcessId of pid_t 

  // returned to child proces
  | BadExec of errno_t 
  | BadSetup of int
  ;

  gen spawnv(file: string, argv:+ (+char), setup:1->int) : spawn_result_t = {
    var x = fork();
    if x == child_process do  // CHILD
      var result = #setup;
      if result != 0 do
        return BadSetup result;
      done
      var y = execv(file.cstr, argv); 
      if y == bad_exec do 
        return BadExec errno; 
      else 
        return ProcessId x; // never taken! fool type system 
      done 
    elif x == bad_process do // PARENT 
      return BadFork errno;
    else 
      return ProcessId x;
    done
  }

  gen spawnvp(file: string, argv:+ (+char), setup:1->int) : spawn_result_t = { 
    var x = fork();
    if x == child_process do // CHILD
      var result = #setup;
      if result != 0 do
        return BadSetup result;
      done
      var y = execvp(file.cstr, argv); 
      if y == bad_exec do 
        return BadExec errno; 
      else 
        return ProcessId x; // never taken! fool type system 
      done 
    elif x == bad_process do  // PARENT
      return BadFork errno;
    else 
      return ProcessId x;
    done
  }

  gen spawnve(file: string, argv:+ (+char), env: + (+char), setup:1->int) : spawn_result_t = {
    var x = fork();
    if x == child_process do // CHILD
      var result = #setup;
      if result != 0 do
        return BadSetup result;
      done
      var y = execve(file.cstr, argv, env); 
      if y == bad_exec do 
        return BadExec errno; 
      else 
        return ProcessId x; // never taken! fool type system
      done 
    elif x == bad_process do // PARENT
      return BadFork errno;
    else 
      return ProcessId x;
    done
  }

  type process_status_options_t = "int";
  const WCONTINUED: process_status_options_t;
  const WNOHANG: process_status_options_t;
  const WUNTRACED: process_status_options_t;
  const WNONE: process_status_options_t="0";
  fun \| : process_status_options_t * process_status_options_t -> process_status_options_t = "$1|$2";

  gen waitpid: pid_t * &process_status_t * process_status_options_t -> pid_t requires Posix_headers::sys_wait_h;

  gen waitpid(pid:pid_t) = {
    var status: process_status_t;
    var pid' = waitpid(pid,&status,WNONE);
    if pid' == bad_process do 
      println$ "Waitpid failed .. fix me!";
      System::exit 1;
    else
      return status;
    done
  }

  union ProcesStatus= | Running | Stopped of process_status_t;

  gen checkpid(pid:pid_t) = {
    var status: process_status_t;
    var pid' = waitpid(pid,&status,WNOHANG);
    if pid' == bad_process do 
      println$ "Waitpid failed .. fix me!";
      System::exit 1;
    elif pid'.int == 0 do
      return Running;
    else
      return Stopped status;
    done
  }

  gen kill: pid_t * signal_t -> int;
  const OUR_PROCESS_GROUP: pid_t = "0";
 
}
@h1 Win32 Process
@tangle win32_process.flx

class Win32Process {
  open Win32Signal;

  instance Process_class[Win32, process_status_t] 
  {
    gen popen_in: string -> Cstdio::ifile = '_popen($1.c_str(), "r")' requires C89_headers::stdio_h;
    gen pclose: Cstdio::ifile -> process_status_t = "_pclose($1)" requires C89_headers::stdio_h;
  }
  inherit Process_class[Win32, process_status_t];
  type process_status_t = "intptr_t";
  ctor intptr:process_status_t = "$1";
  ctor int:process_status_t = "int($1)";
  ctor process_status_t : intptr = "$1";
  fun int_of_process_status_t: process_status_t -> int = "(int)$1";

/*

  fun WIFCONTINUED: process_status_t -> bool = "WIFCONTINUED($1)!=0";
  fun WIFEXITED: process_status_t -> bool = "WIFEXITED($1)!=0";
  fun WIFSIGNALED: process_status_t -> bool = "WIFSIGNALED($1)!=0";
  fun WIFSTOPPED: process_status_t -> bool = "WIFSTOPPED($1)!=0";

  fun WEXITSTATUS: process_status_t -> int = "WEXITSTATUS($1)";
  fun WTERMSIG: process_status_t -> signal_t = "WTERMSIG($1)";
  fun WSTOPSIG: process_status_t -> signal_t = "WSTOPSIG($1)";

  // OSX only, not in Posix
  fun  WCOREDUMP: process_status_t -> int = "WCOREDUMP($1)";


  fun str(x:process_status_t) = {
    if WIFEXITED x do
       val e = x.WEXITSTATUS;
       return "Exit " + str e + ": " +e.errno_t.strerror;
    elif WIFSIGNALED x do
       val s = x.WTERMSIG;
       return "SIGNAL " + s.int.str + ": " + s.str;
    else
       return "Unknown temination status " + x.int.str;
    done
  }
*/
  const environ: + (+char) = "environ" requires Posix_headers::unistd_h;

  type exec_result_t = "intptr_t";
  const bad_exec: exec_result_t = "intptr_t(-1)";
  fun == : exec_result_t * exec_result_t -> bool= "$1==$2";

  gen execv:+char *  + (+char) -> exec_result_t = "_execv($1, $2)" requires Win32_headers::process_h;
  gen execvp:+char *  + (+char) -> exec_result_t = "_execvp($1, $2)" requires Win32_headers::process_h;
  gen execve:+char *  + (+char) * + (+char) -> exec_result_t = "_execve($1, $2, $3)" requires Win32_headers::process_h;

  // do NOT try to fork Felix programs, it doesn't work
  // because of threads already running. We use fork only
  // to preceed exec() calls.
  type pid_t = "intptr_t" requires Posix_headers::unistd_h;
  ctor intptr: pid_t = "($1)";
  const bad_process : pid_t = "intptr_t(-1)";
  fun == : pid_t * pid_t -> bool= "$1==$2";

  instance Str[pid_t] {
    fun str: pid_t -> string = "::flx::rtl::strutil::str<intptr_t>($1)" requires package "flx_strutil";
  }

  union spawn_result_t = 
  // returned to parent process
  | BadFork of errno_t  
  | ProcessId of pid_t 

  // returned to child proces (can't happen on Windows)
  | BadExec of errno_t 
  | BadSetup of int
  ;

  gen spawnv:+char *  + (+char) -> pid_t = "_spawn(_P_NOWAIT,$1, $2)" requires Win32_headers::process_h;
  gen spawnvp:+char *  + (+char) -> pid_t = "_spawnvp(_P_NOWAIT,$1, $2)" requires Win32_headers::process_h; 
  gen spawnve:+char *  + (+char) * + (+char) -> pid_t = "_spawnve(_P_NOWAIT,$1, $2, $3)" requires Win32_headers::process_h; 

  gen spawnv(file: string, argv:+ (+char), setup:1->int) : spawn_result_t = {
    var x = spawnv(file.cstr, argv); 
    if x == bad_process do // PARENT 
      return BadFork errno;
    else 
      return ProcessId x;
    done
  }

  gen spawnvp(file: string, argv:+ (+char), setup:1->int) : spawn_result_t = { 
    var x = spawnvp(file.cstr, argv); 
    if x == bad_process do  // PARENT
      return BadFork errno;
    else 
      return ProcessId x;
    done
  }

  gen spawnve(file: string, argv:+ (+char), env: + (+char), setup:1->int) : spawn_result_t = {
    var x = spawnve(file.cstr, argv, env); 
    if x == bad_process do // PARENT
      return BadFork errno;
    else 
      return ProcessId x;
    done
  }
/*
  type process_status_options_t = "int";
  const WCONTINUED: process_status_options_t;
  const WNOHANG: process_status_options_t;
  const WUNTRACED: process_status_options_t;
  const WNONE: process_status_options_t="0";
  fun \| : process_status_options_t * process_status_options_t -> process_status_options_t = "$1|$2";

  // Use WaitForSingleObject
  gen waitpid: pid_t * &process_status_t * process_status_options_t -> pid_t requires Posix_headers::sys_wait_h;

  gen waitpid(pid:pid_t) = {
    var status: process_status_t;
    var pid' = waitpid(pid,&status,WNONE);
    if pid' == bad_process do 
      println$ "Waitpid failed .. fix me!";
      System::exit 1;
    else
      return status;
    done
  }

  union ProcesStatus= | Running | Stopped of process_status_t;

  gen checkpid(pid:pid_t) = {
    var status: process_status_t;
    var pid' = waitpid(pid,&status,WNOHANG);
    if pid' == bad_process do 
      println$ "Waitpid failed .. fix me!";
      System::exit 1;
    elif pid'.int == 0 do
      return Running;
    else
      return Stopped status;
    done
  }

  gen kill: pid_t * signal_t -> int;
  const OUR_PROCESS_GROUP: pid_t = "0";
*/ 
}

@h1 System Call
@tangle system.flx

class System
{
  const argc:int = "PTF argc" requires property "needs_ptf";
  const _argv:&&char= "PTF argv" requires property "needs_ptf";

  fun argv:int -> string = '::std::string($1<0||$1>=PTF argc??"":PTF argv[$1])' 
    requires property "needs_ptf";
  fun argv_dflt (x:int) (y:string) => match argv x with | "" => y | a => a;

  fun args () => List::map (argv) (List::range argc);

  proc setargs : + (+char) * size = "PTF argc=$2; PTF argv=$1;" requires property "needs_ptf";
  proc setargs[N] (a:string^N) 
  {
    gen myget(i:size)=>a.i.cstr;
    var x = varray[+char] (a.len,a.len,myget);
    setargs (x.stl_begin,x.len);
  }

  gen system (cmd:string) : int => Shell::system(cmd);
  gen exit: int -> any = '::std::exit($1)' requires Cxx_headers::cstdlib;
  gen abort: 1 -> any = "::std::abort($1)" requires Cxx_headers::cstdlib;
  _gc_pointer type ptf_t = "thread_frame_t*";
  const ptf:ptf_t = "ptf" requires property "needs_ptf";

  //$ pexit examines the return code from a system call.
  //$ If the code is 0 it exists with 0.
  //$ On Windows:
  //$    if the code is -1, it exits with errno.
  //$    otherwise code 3
  //$ On Unix:
  //$   if the code is non-zero then
  //$     if the callout aborted, return its abort code.
  //$     if the callout died due to a signal, exit with code 2
  //$     otherwise exit with code 3
  //$ In both these cases a non-zero return causes a message
  //$ to be printed on stderr.

  if PLAT_WIN32 do
    proc pexit(e:int)
    {
      if e != 0 do
        if e == -1 do
          err :=  errno;
          eprintln$ "Error "+err.str+" in flx: " + strerror err;
          System::exit err.int;
        else
          eprintln$ "Unknown error in shell " + str e;
          System::exit 3;
        done
      done
      System::exit e;
    }
  else
    proc pexit(e:int)
    {
      if e != 0 do
        if PosixProcess::WIFEXITED e.PosixProcess::process_status_t do
          err :=  PosixProcess::WEXITSTATUS e.PosixProcess::process_status_t;
          eprintln$ "Error "+err.str+" in flx: " + strerror err.errno_t;
          System::exit err;
        elif PosixProcess::WIFSIGNALED e.PosixProcess::process_status_t do
          sig := Process::WTERMSIG e.PosixProcess::process_status_t;
          eprintln$ "Shell terminated by signal " + str sig;
          System::exit 2;
        else
          eprintln$ "Unknown error in shell " + str e;
          System::exit 3;
        done
      done
      System::exit e;
    }
  done

  gen get_stdout(x:string) : int * string => Shell::get_stdout x;

}

@h1 Shell
@tangle shell.flx

// Note Shell_class interface doesn't use process_status_t
// but the implementation does.

class Shell_class[OS, process_status_t]
{
  // Quote a single argument.
  // Note: kills Bash wildcard replacement.
  virtual fun quote_arg:string->string;

  // Mainly for Windows we need a way to quote command line strings too.
  virtual fun quote_line_for_system: string->string;
  virtual fun quote_line_for_popen: string -> string;

  virtual fun parse: string -> list[string];

  //$ System command is ISO C and C++ standard.
  gen raw_system: string -> int = "::std::system($1.c_str())"
    requires Cxx_headers::cstdlib
  ;

  //$ get_stdout is a synchronous version of popen_in/pclose pair.
  virtual gen raw_get_stdout : string -> int * string;

  //$ create prototype command strings from arg list.
  fun create_system_command (s:list[string]) : string =>
    quote_line_for_system $ catmap[string] ' ' quote_arg s
  ;
  fun create_popen_command (s:list[string]) : string =>
    quote_line_for_popen $ catmap[string] ' ' quote_arg s
  ;

  //$ basic command with line quoting.
  gen basic_system (cmd: string) :int => 
    cmd.quote_line_for_system.raw_system
  ;
  gen basic_get_stdout (cmd: string) : int * string =>
    cmd.quote_line_for_popen.raw_get_stdout
  ;

  // string argument
  gen system (cmd:string) = {
    if Env::getenv "FLX_SHELL_ECHO" != "" do
      eprintln$ "[system] " + cmd;
    done
    return basic_system cmd;
  }

  gen get_stdout (cmd:string) : int * string = {
    if Env::getenv "FLX_SHELL_ECHO" != "" do
      eprintln$ "[get_stdout] " + cmd;
    done
    return basic_get_stdout cmd;
  }

  // list of string argument
  gen system (args:list[string]) : int =>
    args.create_system_command.system
  ;

  gen system[T with Streamable[T,string]] (args:T) : int =
  {
    var lst = Empty[string];
    for arg in args do 
      lst = lst + arg; 
    done
    return system lst;
  }  


  // arbitrary Streamable argument
  gen get_stdout (args:list[string]) : int * string =>
    args.create_popen_command.get_stdout
  ;
 
  gen get_stdout[T with Streamable[T,string]] (args:T) : int * string =
  {
    var lst = Empty[string];
    for arg in args do 
      lst = lst + arg; 
    done
    return get_stdout lst;
  }  

}

class Shell {
if PLAT_WIN32 do
  inherit CmdExe;
else
  inherit Bash;
done
}

@h1 Posix Shell (Bash)
@tangle posix_shell.flx

// Note: shell functions here only work with Bash.
// However, the system() function always calls sh,
// and sh is always an ash, which is almost always bash

/* GNU Bash 3-2 Man page
QUOTING
       Quoting  is  used  to  remove  the  special meaning of certain characters or words to the shell.
       Quoting can be used to disable special treatment for special  characters,  to  prevent  reserved
       words from being recognized as such, and to prevent parameter expansion.

       Each  of  the metacharacters listed above under DEFINITIONS has special meaning to the shell and
       must be quoted if it is to represent itself.

       When the command history expansion facilities are being used (see HISTORY EXPANSION below),  the
       history expansion character, usually !, must be quoted to prevent history expansion.

       There are three quoting mechanisms: the escape character, single quotes, and double quotes.

       A  non-quoted backslash (\) is the escape character.  It preserves the literal value of the next
       character that follows, with the exception of <newline>.  If a \<newline> pair appears, and  the
       backslash is not itself quoted, the \<newline> is treated as a line continuation (that is, it is
       removed from the input stream and effectively ignored).

       Enclosing characters in single quotes preserves the literal value of each character  within  the
       quotes.   A single quote may not occur between single quotes, even when preceded by a backslash.

       Enclosing characters in double quotes preserves the literal value of all characters  within  the
       quotes,  with  the exception of $, `, \, and, when history expansion is enabled, !.  The charac-
       ters $ and ` retain their special meaning within double quotes.  The backslash retains its  spe-
       cial meaning only when followed by one of the following characters: $, `, ", \, or <newline>.  A
       double quote may be quoted within double quotes by preceding it with a backslash.   If  enabled,
       history  expansion  will be performed unless an !  appearing in double quotes is escaped using a
       backslash.  The backslash preceding the !  is not removed.

       The special parameters * and @ have special  meaning  when  in  double  quotes  (see  PARAMETERS
       below).

       Words  of the form $'string' are treated specially.  The word expands to string, with backslash-
       escaped characters replaced as specified by the ANSI C standard.  Backslash escape sequences, if
       present, are decoded as follows:
              \a     alert (bell)
              \b     backspace
              \e     an escape character
              \f     form feed
              \n     new line
              \r     carriage return
              \t     horizontal tab
              \v     vertical tab
              \\     backslash
              \'     single quote
              \nnn   the eight-bit character whose value is the octal value nnn (one to three digits)
              \xHH   the  eight-bit  character  whose value is the hexadecimal value HH (one or two hex
                     digits)
              \cx    a control-x character

       The expanded result is single-quoted, as if the dollar sign had not been present.

       A double-quoted string preceded by a dollar sign ($) will cause  the  string  to  be  translated
       according  to  the  current  locale.   If  the  current locale is C or POSIX, the dollar sign is
       ignored.  If the string is translated and replaced, the replacement is double-quoted.

*/

class Bash {

  instance Shell_class[Posix, PosixProcess::process_status_t] {
    // we can't use single quotes becase there's no way to represent a ' 
    // in a single quoted string .. so we have to use double quotes and
    // backslash the 4 special characters: " $ \ `
    // I think this is all ..
    fun quote_arg(s:string):string= {
      var r = "";
      for ch in s do
        if ch in "\\\"" do   // leave $ and ` in there, unquoted.
          r += "\\"+ str ch;
        else
          r+= ch;
        done
      done
      return '"'+r+'"';
    }
    fun quote_line_for_system (s:string) => s;
    fun quote_line_for_popen (s:string) => s + " ";

    gen raw_get_stdout(x:string) = {
        var fout = PosixProcess::popen_in(x+" ");
        if valid fout do
          var output = load fout;

          var result = PosixProcess::pclose fout; 
          return PosixProcess::WEXITSTATUS result, output;
        else
          println$ "Unable to run command '" + x "'";
          return -1,"";
        done
    }

    //$ Parse a bash command line into words.
    fun parse (s:string) : list[string] = 
    {
      var args = Empty[string];
      var current = "";
      union mode_t = | copy | skip | quote | dquote | escape-copy | escape-dquote;
      var mode = skip;
      for ch in s do
        match mode with
        | #skip => 
          if ch == char "\\" do
            mode = escape-copy;
          elif ch == char "'" do
            mode = quote;
          elif ch == char '"' do
            mode = dquote;
          elif ord ch > ord (char ' ') do
            current += ch;
            mode = copy;
          done

        | #copy =>
          if ch == char "\\" do
            mode = escape-copy;
          elif ord ch <= ord (char ' ') do
            mode = skip;
            args += current;
            current = "";
          elif ch == char "'" do
             mode = quote;
          elif ch == char '"' do
            mode = dquote;
          else
            current += ch;
          done

        | #escape-copy =>
          current += ch;
          mode = copy;

        | #escape-dquote =>
          mode = dquote;
          if ch in '"\\$`' do
            current += ch;
          elif ch == char "'n" do ;
          else 
            current += "\\" + ch;
          done
  
        | #dquote =>
          if ch == char '"' do
            mode = copy;
          elif ch == char "\\" do
            mode = escape-dquote;
          else
            current += ch;
          done
        | #quote =>
          if ch == char "'" do
            mode = copy;
          else
            current += ch;
          done
        endmatch;
      done
      match mode with
      | #skip => ;
      | _ => args += current;
      endmatch; 
      return args;
    }
  }
  inherit Shell_class[Posix, PosixProcess::process_status_t];
}

@h1 Win32 Shell (cmd.exe)
@tangle win32_shell.flx


/* http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
Microsoft Specific

Microsoft C/C++ startup code uses the following rules when interpreting 
arguments given on the operating system command line:

    Arguments are delimited by white space, which is either a space or a tab.

    The caret character (^) is not recognized as an escape character or delimiter. 
    The character is handled completely by the command-line parser in the 
    operating system before being passed to the argv array in the program.

    A string surrounded by double quotation marks ("string") is 
    interpreted as a single argument, regardless of white space contained within. 
    A quoted string can be embedded in an argument.

    A double quotation mark preceded by a backslash (\") is 
    interpreted as a literal double quotation mark character (").

    Backslashes are interpreted literally, unless they 
    immediately precede a double quotation mark.

    If an even number of backslashes is followed by a 
    double quotation mark, one backslash is placed in the argv
    array for every pair of backslashes, and the double quotation mark 
    is interpreted as a string delimiter.

    If an odd number of backslashes is followed by a 
    double quotation mark, one backslash is placed in the argv
    array for every pair of backslashes, and the double quotation mark
    is "escaped" by the remaining backslash, causing a literal 
    double quotation mark (") to be placed in argv.
*/

class CmdExe
{
  instance Shell_class[Win32, Win32Process::process_status_t]
  {
    fun quote_arg(s:string):string => '"' + s + '"';
    fun quote_line_for_system(s:string) => '"' + s + '"';
    fun quote_line_for_popen(s:string) => '"' + s + '"';

    gen get_stdout(x:string) = {
      var fout = Win32Process::popen_in('"'+x+'"');
      if valid fout do
        var output = load fout;
        var result = Win32Process::pclose fout; 
        return Win32Process::int_of_process_status_t result, output;
      else
        println$ "Unable to run command '" + x "'";
        return -1,"";
      done
    }

    //$ Parse a CMD.EXE command line into words.
    fun parse (s:string) : list[string] = 
    {
      var args = Empty[string];
      var current = "";
      union mode_t = | copy | skip | dquote | escape-copy | escape-dquote;
      var mode = skip;
      for ch in s do
        match mode with
        | #skip => 
          if ch == char "\\" do
            mode = escape-copy;
          elif ch == char '"' do
            mode = dquote;
          elif ord ch > ord (char ' ') do
            current += ch;
            mode = copy;
          done

        | #copy =>
          if ch == char "\\" do
            mode = escape-copy;
          elif ord ch <= ord (char ' ') do
            mode = skip;
            args += current;
            current = "";
          elif ch == char '"' do
            mode = dquote;
          else
            current += ch;
          done

        | #escape-copy =>
          mode = copy;
          if ch == char '"' do
            current += ch;
          else
            current += "\\" + ch;
          done 

        | #escape-dquote =>
          mode = dquote;
          if ch == char '"' do
            current += ch;
          else 
            current += "\\" + ch;
          done
  
        | #dquote =>
          if ch == char '"' do
            mode = copy;
          elif ch == char "\\" do
            mode = escape-dquote;
          else
            current += ch;
          done
        endmatch;
      done
      match mode with
      | #skip => ;
      | _ => args += current;
      endmatch; 
      return args;
    }
  }
  inherit Shell_class[Win32, Win32Process::process_status_t];

}



@h1 Signals
@tangle signal.flx

body ctrl_c_flag = """
  static bool ctrl_c_flag = false;
  bool get_ctrl_c_flag() { return ctrl_c_flag; }
  void set_ctrl_c_flag(int) { ctrl_c_flag = true; }
""";


class Signal_class [os] {
  gen get_ctrl_c_flag: 1 -> bool requires ctrl_c_flag;
  proc set_ctrl_c_flag: int requires ctrl_c_flag;
  virtual proc trap_ctrl_c: 1;

}

class Signal {
if PLAT_WIN32 do
  inherit Win32Signal;
else
  inherit PosixSignal;
done
}

@h1 Posix Signal
@tangle posix_signal.flx

class PosixSignal {
  requires C89_headers::signal_h; 
  type signal_t = "int";
  ctor signal_t: int = "$1";
  ctor int: signal_t = "$1";

  type sig_t = "sig_t"; // what a pity posix calls the handler sig_t
  gen signal: signal_t * sig_t -> sig_t = "signal($1, $2)";
  instance Eq[signal_t] {
    fun == : signal_t * signal_t ->  bool = "$1==$2";
  }
  inherit Eq[signal_t];

  // http://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html
  const 
    SIGABRT, SIGALRM, SIGBUS, SIGCHLD, SIGCONT, SIGFPE, SIGHUP, SIGILL, SIGINT, SIGKILL,
    SIGPIPE, SIGQUIT, SIGSEGV, SIGSTOP, SIGTERM, SIGTSTP, SIGTTN, SIGTTOU, SIGUSR1, SIGUSR2,
    SIGPOLL, SIGPROF, SIGSYS, SIGTRAP, SIGURG, SIGVTALRM, SIGXCPU,SIGXSZ
  : signal_t;

  instance Str[signal_t] {
    fun str: signal_t -> string =
    | $(SIGABRT) =>  "SIGABRT" 
    | $(SIGALRM) =>  "SIGALRM" 
    | $(SIGBUS) =>  "SIGBUS" 
    | $(SIGCHLD) =>  "SIGCHLD" 
    | $(SIGCONT) =>  "SIGCONT" 
    | $(SIGFPE) =>  "SIGFPE" 
    | $(SIGHUP) =>  "SIGHUP" 
    | $(SIGILL) =>  "SIGILL" 
    | $(SIGINT) =>  "SIGINT" 
    | $(SIGKILL) =>  "SIGKILL"
    | $(SIGPIPE) =>  "SIGPIPE" 
    | $(SIGQUIT) =>  "SIGQUIT" 
    | $(SIGSEGV) =>  "SIGSEGV" 
    | $(SIGSTOP) =>  "SIGSTOP" 
    | $(SIGTERM) =>  "SIGTERM" 
    | $(SIGTSTP) =>  "SIGTSTP" 
    // | $(SIGTTN) =>  "SIGTTN"  // not in OSX
    | $(SIGTTOU) =>  "SIGTTOU" 
    | $(SIGUSR1) =>  "SIGUSR1" 
    | $(SIGUSR2) =>  "SIGUSR2"
    // | $(SIGPOLL) =>  "SIGPOLL" // not in OSX
    | $(SIGPROF) =>  "SIGPROF" 
    | $(SIGSYS) =>  "SIGSYS" 
    | $(SIGTRAP) =>  "SIGTRAP" 
    | $(SIGURG) =>  "SIGURG" 
    | $(SIGVTALRM) =>  "SIGVTALRM" 
    | $(SIGXCPU) =>  "SIGXCPU" 
    // | $(SIGXSZ) =>  "SIGXSZ" // not in OSX
    | x => "signal " + x.int.str
    ;
  }
  inherit Str[signal_t];

  body "void null_signal_handler(int){}";
  const null_signal_handler: sig_t;
  proc ignore_signal(s:signal_t) { C_hack::ignore(signal(s, null_signal_handler)); }

  // http://pubs.opengroup.org/onlinepubs/007904975/functions/sigaction.html
  body ctrl_c_handling = """
    void set_ctrl_c_flag(int);
    void trap_ctrl_c () {
      struct sigaction sa;
      sa.sa_handler = set_ctrl_c_flag;
      sigemptyset(&sa.sa_mask);
      sa.sa_flags = SA_RESTART;
      sigaction(SIGINT, &sa, NULL);
   }
  """ requires ctrl_c_flag;

  inherit Signal_class[Posix];

  instance Signal_class[Posix] {
    proc trap_ctrl_c: unit requires ctrl_c_handling;
  }
}


@h1 Win32 Signal
@tangle win32_signal.flx

class Win32Signal {
  requires C89_headers::signal_h;
  type signal_t = "int";
  ctor signal_t: int = "$1";
  ctor int: signal_t = "$1";

  header sig_t_def = "typedef void (__cdecl *sig_t)(int);";
  type sig_t = "sig_t" requires sig_t_def; 
  gen signal: signal_t * sig_t -> sig_t = "signal($1, $2)";
  instance Eq[signal_t] {
    fun == : signal_t * signal_t ->  bool = "$1==$2";
  }
  inherit Eq[signal_t];

  // http://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html
  const 
    SIGABRT,  SIGFPE, SIGILL, SIGINT, 
    SIGSEGV,  SIGTERM 
  : signal_t;

  instance Str[signal_t] {
    fun str: signal_t -> string =
    | $(SIGABRT) =>  "SIGABRT" 
    | $(SIGFPE) =>  "SIGFPE" 
    | $(SIGILL) =>  "SIGILL" 
    | $(SIGINT) =>  "SIGINT" 
    | $(SIGSEGV) =>  "SIGSEGV" 
    | $(SIGTERM) =>  "SIGTERM" 
    | x => "signal " + x.int.str
    ;
  }
  inherit Str[signal_t];

  body "void null_signal_handler(int){}";
  const null_signal_handler: sig_t;
  proc ignore_signal(s:signal_t) { C_hack::ignore(signal(s, null_signal_handler)); }

  // http://pubs.opengroup.org/onlinepubs/007904975/functions/sigaction.html
  body ctrl_c_handling = """
    void set_ctrl_c_flag(int);
    void trap_ctrl_c () {
     (void)signal(SIGINT,set_ctrl_c_flag); 
   }
  """ requires ctrl_c_flag;

  inherit Signal_class[Win32];

  instance Signal_class[Win32] {
    proc trap_ctrl_c: unit requires ctrl_c_handling;
  }
}

@h1 Dynamic Linkage
@h2 Synopsis
This subsystem provides the ability to load,link or otherwise
access program code at run time. We use the name @{DLL} to refer
to a dynamically loaded file containing executable instructions,
on Windows this is a dynamic link library which usually ends
in extension @{.dll} whilst on Linux we have shared libraries
with extension @{.so} and on OSX we use files with extension @{.dylib}.

There is a confusing array of operations provided here which will
require refactoring in the future. 

The core platform dependent operations are implemented in C++
and configuration and compile time choices determine the
platform supported.

These core operations are wrapped, in C++, to remove the
file loading dependencies, and provide resource control
integrated with the garbage collector. 

We use @{LoadLibrary} on Windows and @{dlopen} on Unix platforms
wrapped inside a C++ class @{flx_dynlink_t} that represents
a library, in Felix the type @{flx_library} is used.

Felix generated code does not permit variables to be
stored in static storage. Instead, a structure is used
to contain Felix top level variables. For historical
reasons objects are called <em>thread frames.</em>

Members of a thread frame are accessed in Felix bindings
to C++ using the macro @{PTF} which stands for <em>pointer
to thread frame.</em>

A Felix generated shared library requires an instance to be 
created which is a closure: a pair consisting of the library code
and a @{thread_frame_t} object which is allocated on the heap.
The closure object has the type @{flx_libinst_t} in C++
and @{flx_instance} in Felix.

Instances require a fixed protocol which involves
the library containing exported symbols which can
be linked using @{LoadProcAddress} on Windows
or @{dlsym} on unix, which can be used to construct
the required thread frame. High level Felix functions
require he thread frame because it contains a pointer
to the garbage collector which in turn provides the
system allocator.

Higher level abstractions require more fixed
symbols. In particular, there is a protocol
for loading a special kind of library 
called a <em>plugin</em> which make separate
compilation of and use of dynamic libraries
particularly convenient.

@h2 The dynamic link library @{Dynlink}
@tangle dynlink.flx
class Dynlink
{
@h3 C++ support package.
@tangle dynlink.flx
  requires package "flx_dynlink";

@h3 Error handling.
The current version of the library requires dynamic link attempts
to succeed. If they fail an exception is thrown which aborts
the program unless specifically caught. In future, we may
provide an interface based on option types which enforces
user level error checking as well.
@tangle dynlink.flx
  //$ Exception thrown if dynamic linkage fails.
  type flx_link_failure_t = "::flx::rtl::flx_link_failure_t";

  //$ Constructor for dynamic linkage exception.
  ctor flx_link_failure_t : string * string * string = "::flx::rtl::flx_link_failure_t($1,$2,$3)";

  //$ Extractors.
  fun filename : flx_link_failure_t -> string = "$1.filename";
  fun operation : flx_link_failure_t -> string = "$1.operation";
  fun what : flx_link_failure_t -> string = "$1.what";

  //$ Delete returned exception.
  proc delete : cptr[flx_link_failure_t] = "delete $1;";

  //$ This doesn't belong here but it will do for now
  fun get_debug_driver_flag : 1 -> bool = "PTF gcp->debug_driver" requires property "needs_gc"; 

@h2 Library handle @{flx_library}
A platform independent handle which can refer to a dynamic
link library object. Operations in this category are universal
and apply to all dynamic link libraries, whether or not they
were generated by Felix.
@tangle dynlink.flx
  //$ Type of a DLL (dynamic link library) object.
  _gc_pointer type flx_library = "::flx::rtl::flx_dynlink_t*";

@h3 Constructor for @{flx_library</code>: <code>create_library_handle}
The constructor makes an unpopulated library handle
not associated with any particular DLL.
@tangle dynlink.flx
  //$ Create a fresh DLL object.
  fun create_library_handle: bool ->flx_library=
    "new(*PTF gcp, ::flx::rtl::flx_dynlink_ptr_map, false) ::flx::rtl::flx_dynlink_t($1)";

@h3 Load a library @{dlopen}
This procedure associates a library handle with a particular
file name and also attempts to load the library.
@tangle dynlink.flx
  //$ Link a DLL using given filename.
  //$ May throw flx_link_failure_t.
  proc dlopen:flx_library * string = "$1->dynamic_link($2);";

  //$ Link a DLL using given filename and modulename.
  //$ May throw flx_link_failure_t.
  proc modopen:flx_library * string * string = 
    "$1->dynamic_link_with_modulename($2, $3);"
  ;

   //$ Link static 
  proc set_entry_points : flx_library * string * address * address =
    "$1->static_link($2,(::flx::rtl::thread_frame_creator_t)$3, (::flx::rtl::start_t)$4, NULL);"
  ;

@h3 Load a library from registry @{regopen}
Given a registry, simulate dynamic linkage.
@tangle dynlink.flx
  typedef module_dictionary_t = StrDict::strdict[address];
  typedef registry_t = StrDict::strdict[module_dictionary_t];
  fun get_module_registry_address_address: 1 -> &&registry_t = 
    "(void****)(void*)&(PTF gcp->collector->module_registry)"
    requires property "needs_gc";

  // severe hackery: if the registry isn't initialised,
  // create one, store its address in the GC object, and make
  // it a root so the GC scans it: the GC isn't owned by itself,
  // but the registry is owned by the GC.
  gen get_module_registry  () :registry_t = {
    var ppregistry : &&registry_t = #get_module_registry_address_address;
    var pregistry : &registry_t = *ppregistry;
    if C_hack::isNULL (pregistry) do
      pregistry = new (StrDict::strdict[module_dictionary_t] ());
      ppregistry <- pregistry;
      Gc::add_root (C_hack::cast[address] (pregistry));
    done
    return *pregistry;
  }

  noinline proc regopen (registry:registry_t) (lib:flx_library, modulename:string)
  {
     //println$ "regopen " + modulename;
     var mod = StrDict::get registry modulename;
     match mod with
     | #None => 
       //println$ "Not in registry, using dlopen for " + modulename;
       modopen$ lib, modulename+#Filename::dynamic_library_extension, modulename;
     | Some dict =>
       //println$ "Found module "+modulename+" in registry"; 
       var tfc = dict.get_dflt (modulename+"_create_thread_frame", NULL);
       //println$ "Thread frame creator = " + str tfc;
       if tfc == NULL do
         raise$ flx_link_failure_t(modulename,"regopen","Cannot find symbol " + modulename+"_create_thread_frame in module registry for " + modulename);
       done
       var start_sym = dict.get_dflt (modulename+"_flx_start",NULL);
       if start_sym == NULL do
         raise$ flx_link_failure_t(modulename,"regopen","Cannot find symbol " + modulename+"_flx_start in module registry for "+modulename);
       done
       //println$ "Start symbol = " + str start_sym;
       set_entry_points$ lib,modulename,tfc, start_sym;
     endmatch;
  }

@h3 Get the filename associated with a library handle: @{filename}
@tangle dynlink.flx
  //$ Get the filename of a DLL.
  fun filename : flx_library -> string = "$1->filename";

  //$ Get the modulename of a DLL.
  fun modulename : flx_library -> string = "$1->modulename";

  //$ Get the threadframe creator function
  fun get_thread_frame_creator_as_address: flx_library -> address  = "(void*)$1->thread_frame_creator";

  //$ Get start function
  fun get_start_as_address: flx_library -> address  = "(void*)$1->start_sym";

  noinline proc add_symbol  (modulename:string, symbolname:string, adr:address)
  {
     //println$ "add symbol " + symbolname + " to module " + modulename+ " value " + str adr;
     var registry = #Dynlink::get_module_registry;
     var mod = #{
       match get registry modulename with
       | #None =>
          var mod = #strdict[address];
          add registry modulename mod;
          return mod;
       | Some dict => return dict;
       endmatch;
     };
     mod.add symbolname adr;
  }


@h3 Unlink a dll : @{dlclose}.
This routine reduces the reference count of a library handle
by one, and if it drops to zero unloads the library at the
OS level.

References counts are increase by one when instances are created.
The initial @{dlopen} sets the reference count to 1.

Unlinking clears the association of the handle with the filename
and tells the platform linker to unlink the library.
However this does not necessarily unload the library because
the platform linker may also reference count the library,
and the user may link the same DLL twice using distinct
library handles.

Because of the badly designed structure of C programs,
unloading a library physically is not safe and cannot
be made safe. Even with tight control of library code
generation, it is very hard to ensure there are no references
left to a library. References include pointers to functions,
vtables, rtti objects, strings, other constants, and sometimes
even variables.
@tangle dynlink.flx
  //$ Unlink a DLL.
  //$ Unsafe! Use with extreme caution.
  //$ May cause pointers into the DLL code segment to dangle.
  proc dlclose:flx_library = "$1->unlink();";

@h3 Get the address of an exported symbol: @{dlsym}
This routine takes a library and a string argument
and tries to find the value associated with the string
in the library symbol table, using @{GetProcAddress}
on Windows or @{dlsym} on Unix. This action is independent
of whether the calling program was linked dynamically
or statically.

For functions, this operator returns a function
pointer. For variables, it returns the address of the variable.
DO not forget the extra dereference requires if the variable
is itself a pointer.
@tangle dynlink.flx
  //$ Find raw address of a symbol in a DLL.
  //$ This function now ALWAYS does a dlsym
  //$ (or Windows equivalent)
  //$ even for static linkage: after all 
  //$ statically linked executables can still
  //$ load DLLs at run time.
  fun raw_dlsym:flx_library * string->address =
      "FLX_SDLSYM($1->library,$2.c_str())";

  noinline fun find_sym(lib:flx_library, sym:string) : address =
  {
    if lib.filename == "" do
      var reg = #get_module_registry;
      match reg.get lib.modulename with
      | #None => return NULL;
      | Some dict =>
        match dict.get sym with
        | #None => return NULL;
        | Some sym => return sym;
        endmatch;
      endmatch; 
    else 
      return raw_dlsym (lib,sym);
    done
  }

@h2 Library instance type @{flx_instance}
A library instance is a closure consisting of the
library code, represent by a library handle, 
together with a pointer to an instance of the
libraries thread frame. Operations in this category
only work with Felix generated library objects.
@tangle dynlink.flx
  //$ Type of a DLL (dynamic link library) instance.
  //$ Conceptually this is a pair consisting of
  //$ a library object and a global data frame object.
  _gc_pointer type flx_instance = "::flx::rtl::flx_libinst_t*";

@h3 Library instance constructor @{create_instance_handle}
Create a new library instance handle unassociated with any
library or thread frame.
@tangle dynlink.flx
  //$ Create a fresh DLL instance object.
  fun create_instance_handle: bool->flx_instance=
    "new(*PTF gcp, ::flx::rtl::flx_libinst_ptr_map, false) ::flx::rtl::flx_libinst_t($1)";

@h3 Create a library instance from a library: @{create}
This procedure creates a thread frame from a library,
initialises it, and sets the given library instance
with the library handle and thread frame.
The instance handle should not already be associated with a library
or thread frame.
@tangle dynlink.flx 
  //$ Create a DLL instance from a DLL.
  //$ This is a procedure, so maybe the caller is too
  //$ which means the thread frame must be available.
  proc create: flx_library * flx_instance =
    "$2->create($1,PTF gcp,PTF argc,PTF argv,PTF flx_stdin, PTF flx_stdout, PTF flx_stderr, false);" 
    requires property "needs_gc"
  ;

  proc create_with_args: flx_library * flx_instance * int * + (+char) =
    "$2->create($1,PTF gcp,$3,$4,PTF flx_stdin, PTF flx_stdout, PTF flx_stderr, false);" 
    requires property "needs_gc"
  ;

  proc create_with_args (lib:flx_library, inst:flx_instance, args:list[string])
  {
    // convert list to a varray of strings
    var a = varray args; 

    // now convert to varray of char pointers
    gen myget(i:size)=>a.i.cstr; 
    var x = varray[+char] (a.len,a.len,myget); 
    create_with_args (lib,inst,x.len.int,x.stl_begin);
  }


@h3 Get the filename from an instance @{filename}.
@tangle dynlink.flx 
  //$ Get the filename of a DLL from an instance of it.
  fun filename : flx_instance -> string = "::std::string($1->lib->filename)";

@h3 Get the startup procedure from an instance @{filename}.
Felix generated libraries contain a symbol which is used
to initialise the thread frame. This initialisation is
in addition to that performed when the instance is created.
Typically the instance creation initialisation simply invokes
the C++ default constructor and sets a couple of critical
variables including a pointer to the garbage collector
and standard input/output streams.

The startup procedure we get here, on the other hand,
usually refers to the client program when using the
scripting model; the behaviour of the program is 
the observable side effects of this initialisation
procedure.

For plugin libraries, the initialisation procedure is used
to construct default values or initialise starting state.

The initialisation procedure is represent by a pointer
to a continuation object, type @{cont}, which has to be run
by a scheduler after associating it with a fibre:
the procedure is <em>not</em> a C function.
@tangle dynlink.flx 
  //$ Get the initialisation continuation of an instance.
  fun get_init: flx_instance -> cont = "$1->start_proc";

@h3 Get the library associated with an instance.
@tangle dynlink.flx
  //$ Get the DLL associated with an instance.
  fun get_library: flx_instance -> flx_library = "$1->lib";

@h3 Get the thread frame associated with an instance.
Since we don't know the type of the thread frame here,
it is returned as a pure address.
@tangle dynlink.flx
  //$ Get the thread frame (global data object) of an instance.
  fun get_thread_frame: flx_instance -> address = "(void*)$1->thread_frame";

@h3 Convenience constructor for an instance @{init_lib}
This function creates a library handle and instance handle
and loads the library given a filename, all in one operation.
Then it runs the startup initialisation procedure.
Finally the instance is returned.
@tangle dynlink.flx

  //$ Create, link, and prepare a DLL instance from a modulename.
  //$ NOTE: libraries created here do not need to be roots
  // The code is never deleted (due to design issues with C).
  // If the library isn't reachable, you can't create an instance.
  // If an instance is created, it reaches the library.
  noinline gen prepare_lib(modulename:string):flx_instance = {
    var library = create_library_handle(get_debug_driver_flag());
    //Gc::add_root (C_hack::cast[address] library);
    var linstance =  create_instance_handle(get_debug_driver_flag());
    regopen #get_module_registry (library,modulename);
    create (library,linstance);
    return linstance;
  }

  //$ Create, link, and prepare a DLL instance from a modulename.
  noinline gen prepare_lib_with_args(modulename:string, args:list[string]):flx_instance = {
    var library = create_library_handle(get_debug_driver_flag());
    //Gc::add_root (C_hack::cast[address] library);
    var linstance =  create_instance_handle(get_debug_driver_flag());
    regopen #get_module_registry (library,modulename);
    create_with_args (library,linstance,args);
    return linstance;
  }


  //$ Create, link, and initialise a  DLL instance from a modulename.
  noinline gen init_lib(modulename:string):flx_instance = {
    var linstance = prepare_lib(modulename);
    var init = get_init linstance;
    Fibres::run init;
    return linstance;
  }

  //$ Create, link, and initialise a  DLL instance from a modulename.
  noinline gen init_lib_with_args(modulename:string, args:list[string]):flx_instance = {
    var linstance = prepare_lib_with_args(modulename,args);
    var init = get_init linstance;
    Fibres::run init;
    return linstance;
  }


@h3 Convenience to run a program @{run_lib}
This function does the same as @{init_lib}.
@tangle dynlink.flx
  //$ Run a Felix program from a filename.
  proc run_lib(modulename:string)
  {
    var linstance = init_lib(modulename);
    C_hack::ignore(linstance);
  }

  // BUG: no return code!
  proc run_program(args:list[string])
  {
    match args with
    | Cons (h, t) =>
      var linstance = prepare_lib_with_args(h,t);
      var init = get_init linstance;
      Fibres::run init;
    | _ => ;
    endmatch;
  }


@h3 Checked version of @{dlsym}
This routine tries to find a symbol with the specified
name in an instance, if it is found, the resulting address
is cast to the specified type. It also prints a diagnostic
if the symbol cannot be found.
@tangle dynlink.flx
  //$ Find typed address of a symbol in a DLL.
  noinline fun flx_dlsym[T] (linst: flx_instance, sym:string) = {
    var library = Dynlink::get_library linst;
    var tf = Dynlink::get_thread_frame linst;
//println$ "Trying to load symbol " + sym + " from library " + linst.filename;
    var raw_sym = Dynlink::find_sym$ library, sym;
    if isNULL raw_sym do
      eprintln$ "Unable to load symbol " + sym + " from library " + linst.filename;
      raise$ flx_link_failure_t(linst.filename,"dlsym","Cannot find symbol " + sym); 
    done
//    eprintln$ "loaded symbol " + sym + " from library " + linst.filename + " address= " + str raw_sym;
    var typed_sym = C_hack::cast[T] raw_sym;
    return typed_sym, tf;
  }

@h2 Higher level wrappers for finding Felix functions.
Here make a set of higher level wrappers for finding 
standard protocol Felix function in DLLs. These wrappers
create a closure by binding the C address of the constructor
for the Felix function class in C++ to the library instance,
and return that. 

Closures returned by these function can be invoked as normal
Felix functions and procedures. Whereas a function defined
in the current files binds to  the thread frame implicitly,
with a library the instance is required to supply the
thread frame. The closures returned by these wrappers
are bound to the libraries thread frame so they can
be invoked with the ordinary syntax.

Note that these operations are not type safe. If you get
the type wrong all hell will break loose. This is because
dlsym finds functions by their C names and C++ entities
use mangled names we cannot compute in a portable way.
@tangle dynlink.flx
  //$ Return a closure representing a symbol in a DLL instance
  //$ of a function of no arguments.
  noinline fun func0[R] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address --> R] (linst, sym);
    return fun () => s tf;
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a function of one argument.
  noinline fun func1[R,A0] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 --> R] (linst, sym);
    return fun (a0:A0) => s (tf, a0);
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a function of two arguments.
  noinline fun func2[R,A0,A1] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 * A1 --> R] (linst, sym);
    return fun (var a0:A0, var a1:A1) => s (tf, a0, a1);
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a procedure of no arguments.
  noinline fun proc0 (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address --> void] (linst, sym);
    return proc () { s tf; };
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a procedure of one argument.
  noinline fun proc1[A0] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 --> void] (linst, sym);
    return proc (a0:A0) { s (tf, a0); };
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a procedure of two arguments.
  noinline fun proc2[A0,A1] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 * A1 --> void] (linst, sym);
    return proc (a0:A0,a1:A1) { s (tf, a0, a1); };
  }

@h2 Plugins.
A plugin is a special kind of DLL which supplies two
fixed entry points: a setup routine, which is called
to initialise the thread frame given a string argument,
and a single entry point which is subsequently called
and which typically returns an object type consisting
of a set of methods acting on the object state and
initialised thread frame context.

The setup routine typically take a string of configuration
parameters, extracts them with a parser, and stores them
in variables.

The current protocol is that the setup function must
be called "dllname_setup", the entry point name is passed
as a string. 

In order to accomodate static linking of plugins in the
future, the setup and entry point symbols would need to have
univerally unique names, since static linkage cannot work
with duplicate definitions, so the protocol will change
to require the library name as a prefix. Stay tuned.

@tangle dynlink.flx
  //$ Specialised routine(s) to load stylised plugin.
  //$ Two entry points:
  //$
  //$ setup: string -> int
  //$
  //$ is called to initialise the instance globals.
  //$
  //$ entry-point: arg -> iftype
  //$
  //$ is the primary entry point, typically an object factory, 
  //$ when called with an argument
  //$ of type arg_t it returns //$ an object of type iftype.
  //$
  //$ This function returns the object factory.
  //$ setup is called automatically with the supplied string.
  //$
  //$ There are 3 variants where the factory function accepts
  //$ 0, 1 and 2 arguments.
  noinline gen  load-plugin-func0[iftype] (
    dll-name: string,   // name of the DLL minus the extension
    setup-str: string="",  // string to pass to setup
    entry-point: string=""   // export name of factory function
  ) : unit -> iftype =
  {
    var entrypoint = if entry-point == "" then dll-name else entry-point;
    var linst = Dynlink::init_lib(dll-name);
    var sresult = Dynlink::func1[int,string] (linst, dll-name+"_setup") (setup-str);
    C_hack::ignore(sresult);
    if sresult != 0 call eprintln$ "[dynlink] Warning: Plugin Library " + dll-name + " set up returned " + str sresult;
    return Dynlink::func0[iftype] (linst, entrypoint);
  }

  noinline gen  load-plugin-func1[iftype, arg_t] (
    dll-name: string,   // name of the DLL minus the extension
    setup-str: string="",  // string to pass to setup
    entry-point: string=""   // export name of factory function
  ) : arg_t -> iftype =
  {
    var entrypoint = if entry-point == "" then dll-name else entry-point;
    var linst = Dynlink::init_lib(dll-name);
    var sresult = Dynlink::func1[int,string] (linst, dll-name+"_setup") (setup-str);
    C_hack::ignore(sresult);
    if sresult != 0 call eprintln$ "[dynlink] Warning: Plugin Library " + dll-name + " set up returned " + str sresult;
    return Dynlink::func1[iftype,arg_t] (linst, entrypoint);
  }

  noinline gen  load-plugin-func2[iftype, arg1_t, arg2_t] (
    dll-name: string,   // name of the DLL minus the extension
    setup-str: string="",  // string to pass to setup
    entry-point: string=""   // export name of factory function
  ) : arg1_t * arg2_t -> iftype =
  {
    var entrypoint = if entry-point == "" then dll-name else entry-point;
    var linst = Dynlink::init_lib(dll-name);
    var sresult = Dynlink::func1[int,string] (linst, dll-name+"_setup") (setup-str);
    C_hack::ignore(sresult);
    if sresult != 0 call eprintln$ "[dynlink] Warning: Plugin Library " + dll-name + " set up returned " + str sresult;
    return Dynlink::func2[iftype,arg1_t, arg2_t] (linst, entrypoint);
  }

@h2 Utilities and misc.
@tangle dynlink.flx

  //$ Execute an address representing a top
  //$ level exported felix procedure's C wrapper,
  //$ this creates a 'read to run' continuation object
  //$ by both constructing the object using the thread
  //$ frame of the instance as an argument, and calling
  //$ it to fix a null return address and an arbitrary
  //$ client data pointer as arguments to the call method.
  fun bind_proc: flx_instance * address * address -> cont =
    "$1->bind_proc($2,$3)";

  //$ Get the OS dependent handle representing a loaded DLL.
  //$ Return as an address. 
  fun dlib_of : flx_library -> address = "(void*)$1->library";

  //$ Throw an exception indicating the failure to 
  //$ find a symbol in a DLL.
  proc dlsym_err:flx_library*string="""
    throw ::flx::rtl::flx_link_failure_t($1->filename,$2,"symbol not found");
  """;

  //$ Run a procedure represented by a string name with
  //$ given thread frame.
  noinline proc run_proc (linstance:flx_instance, p: string, data: address)
  {
    var lib = get_library linstance;
    var sym = find_sym(lib, p);
    if isNULL(sym) call dlsym_err(lib,p);
    var f = bind_proc(linstance, sym, data);
    run f;
  }


}


