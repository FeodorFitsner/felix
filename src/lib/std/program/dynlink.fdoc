@title Dynamic Loading
@h1 Synopsis
This subsystem provides the ability to load,link or otherwise
access program code at run time. We use the name @{DLL} to refer
to a dynamically loaded file containing executable instructions,
on Windows this is a dynamic link library which usually ends
in extension @{.dll} whilst on Linux we have shared libraries
with extension @{.so} and on OSX we use files with extension @{.dylib}.

There is a confusing array of operations provided here which will
require refactoring in the future. 

The core platform dependent operations are implemented in C++
and configuration and compile time choices determine the
platform supported.

These core operations are wrapped, in C++, to remove the
file loading dependencies, and provide resource control
integrated with the garbage collector. 

We use @{LoadLibrary} on Windows and @{dlopen} on Unix platforms
wrapped inside a C++ class @{flx_dynlink_t} that represents
a library, in Felix the type @{flx_library} is used.

Felix generated code does not permit variables to be
stored in static storage. Instead, a structure is used
to contain Felix top level variables. For historical
reasons objects are called <em>thread frames.</em>

Members of a thread frame are accessed in Felix bindings
to C++ using the macro @{PTF} which stands for <em>pointer
to thread frame.</em>

A Felix generated shared library requires an instance to be 
created which is a closure: a pair consisting of the library code
and a @{thread_frame_t} object which is allocated on the heap.
The closure object has the type @{flx_libinst_t} in C++
and @{flx_instance} in Felix.

Instances require a fixed protocol which involves
the library containing exported symbols which can
be linked using @{LoadProcAddress} on Windows
or @{dlsym} on unix, which can be used to construct
the required thread frame. High level Felix functions
require he thread frame because it contains a pointer
to the garbage collector which in turn provides the
system allocator.

Higher level abstractions require more fixed
symbols. In particular, there is a protocol
for loading a special kind of library 
called a <em>plugin</em> which make separate
compilation of and use of dynamic libraries
particularly convenient.

@h1 The dynamic link library @{Dynlink}
@felix
class Dynlink
{
@h2 C++ support package.
@felix
  requires package "flx_dynlink";

@h2 Error handling.
The current version of the library requires dynamic link attempts
to succeed. If they fail an exception is thrown which aborts
the program unless specifically caught. In future, we may
provide an interface based on option types which enforces
user level error checking as well.
@felix
  //$ Exception thrown if dynamic linkage fails.
  type flx_link_failure_t = "::flx::rtl::flx_link_failure_t";

  //$ Constructor for dynamic linkage exception.
  ctor flx_link_failure_t : string * string * string = "::flx::rtl::flx_link_failure_t($1,$2,$3)";

  //$ Extractors.
  fun filename : flx_link_failure_t -> string = "$1.filename";
  fun operation : flx_link_failure_t -> string = "$1.operation";
  fun what : flx_link_failure_t -> string = "$1.what";

  //$ Delete returned exception.
  proc delete : cptr[flx_link_failure_t] = "delete $1;";

  //$ This doesn't belong here but it will do for now
  fun get_debug_driver_flag : 1 -> bool = "PTF gcp->debug_driver" requires property "needs_gc"; 

@h1 Library handle @{flx_library}
A platform independent handle which can refer to a dynamic
link library object. Operations in this category are universal
and apply to all dynamic link libraries, whether or not they
were generated by Felix.
@felix
  //$ Type of a DLL (dynamic link library) object.
  _gc_pointer type flx_library = "::flx::rtl::flx_dynlink_t*";

@h2 Constructor for @{flx_library</code>: <code>create_library_handle}
The constructor makes an unpopulated library handle
not associated with any particular DLL.
@felix
  //$ Create a fresh DLL object.
  fun create_library_handle: bool ->flx_library=
    "new(*PTF gcp, ::flx::rtl::flx_dynlink_ptr_map, false) ::flx::rtl::flx_dynlink_t($1)";

@h2 Load a library @{dlopen}
This procedure associates a library handle with a particular
file name and also attempts to load the library.
@felix
  //$ Link a DLL using given filename.
  //$ May throw flx_link_failure_t.
  proc dlopen:flx_library * string = "$1->dynamic_link($2);";

  //$ Link a DLL using given filename and modulename.
  //$ May throw flx_link_failure_t.
  proc modopen:flx_library * string * string = 
    "$1->dynamic_link_with_modulename($2, $3);"
  ;

   //$ Link static 
  proc set_entry_points : flx_library * string * address * address =
    "$1->static_link($2,(::flx::rtl::thread_frame_creator_t)$3, (::flx::rtl::start_t)$4, NULL);"
  ;

@h2 Load a library from registry @{regopen}
Given a registry, simulate dynamic linkage.
@felix
  typedef module_dictionary_t = StrDict::strdict[address];
  typedef registry_t = StrDict::strdict[module_dictionary_t];
  fun get_module_registry_address_address: 1 -> &&registry_t = 
    "(void****)(void*)&(PTF gcp->collector->module_registry)"
    requires property "needs_gc";

  // severe hackery: if the registry isn't initialised,
  // create one, store its address in the GC object, and make
  // it a root so the GC scans it: the GC isn't owned by itself,
  // but the registry is owned by the GC.
  gen get_module_registry  () :registry_t = {
    var ppregistry : &&registry_t = #get_module_registry_address_address;
    var pregistry : &registry_t = *ppregistry;
    if C_hack::isNULL (pregistry) do
      pregistry = new (StrDict::strdict[module_dictionary_t] ());
      ppregistry <- pregistry;
      Gc::add_root (C_hack::cast[address] (pregistry));
    done
    return *pregistry;
  }

  noinline proc regopen (registry:registry_t) (lib:flx_library, modulename:string)
  {
     //println$ "regopen " + modulename;
     var mod = StrDict::get registry modulename;
     match mod with
     | #None => 
       //println$ "Not in registry, using dlopen for " + modulename;
       modopen$ lib, modulename+#Filename::dynamic_library_extension, modulename;
     | Some dict =>
       //println$ "Found module "+modulename+" in registry"; 
       var tfc = dict.get_dflt (modulename+"_create_thread_frame", NULL);
       //println$ "Thread frame creator = " + str tfc;
       if tfc == NULL do
         raise$ flx_link_failure_t(modulename,"regopen","Cannot find symbol " + modulename+"_create_thread_frame in module registry for " + modulename);
       done
       var start_sym = dict.get_dflt (modulename+"_flx_start",NULL);
       if start_sym == NULL do
         raise$ flx_link_failure_t(modulename,"regopen","Cannot find symbol " + modulename+"_flx_start in module registry for "+modulename);
       done
       //println$ "Start symbol = " + str start_sym;
       set_entry_points$ lib,modulename,tfc, start_sym;
     endmatch;
  }

@h2 Get the filename associated with a library handle: @{filename}
@felix
  //$ Get the filename of a DLL.
  fun filename : flx_library -> string = "$1->filename";

  //$ Get the modulename of a DLL.
  fun modulename : flx_library -> string = "$1->modulename";

  //$ Get the threadframe creator function
  fun get_thread_frame_creator_as_address: flx_library -> address  = "(void*)$1->thread_frame_creator";

  //$ Get start function
  fun get_start_as_address: flx_library -> address  = "(void*)$1->start_sym";

  noinline proc add_symbol  (modulename:string, symbolname:string, adr:address)
  {
     //println$ "add symbol " + symbolname + " to module " + modulename+ " value " + str adr;
     var registry = #Dynlink::get_module_registry;
     var mod = #{
       match get registry modulename with
       | #None =>
          var mod = #strdict[address];
          add registry modulename mod;
          return mod;
       | Some dict => return dict;
       endmatch;
     };
     mod.add symbolname adr;
  }


@h2 Unlink a dll : @{dlclose}.
This routine reduces the reference count of a library handle
by one, and if it drops to zero unloads the library at the
OS level.

References counts are increase by one when instances are created.
The initial @{dlopen} sets the reference count to 1.

Unlinking clears the association of the handle with the filename
and tells the platform linker to unlink the library.
However this does not necessarily unload the library because
the platform linker may also reference count the library,
and the user may link the same DLL twice using distinct
library handles.

Because of the badly designed structure of C programs,
unloading a library physically is not safe and cannot
be made safe. Even with tight control of library code
generation, it is very hard to ensure there are no references
left to a library. References include pointers to functions,
vtables, rtti objects, strings, other constants, and sometimes
even variables.
@felix
  //$ Unlink a DLL.
  //$ Unsafe! Use with extreme caution.
  //$ May cause pointers into the DLL code segment to dangle.
  proc dlclose:flx_library = "$1->unlink();";

@h2 Get the address of an exported symbol: @{dlsym}
This routine takes a library and a string argument
and tries to find the value associated with the string
in the library symbol table, using @{GetProcAddress}
on Windows or @{dlsym} on Unix. This action is independent
of whether the calling program was linked dynamically
or statically.

For functions, this operator returns a function
pointer. For variables, it returns the address of the variable.
DO not forget the extra dereference requires if the variable
is itself a pointer.
@felix
  //$ Find raw address of a symbol in a DLL.
  //$ This function now ALWAYS does a dlsym
  //$ (or Windows equivalent)
  //$ even for static linkage: after all 
  //$ statically linked executables can still
  //$ load DLLs at run time.
  fun raw_dlsym:flx_library * string->address =
      "FLX_SDLSYM($1->library,$2.c_str())";

  noinline fun find_sym(lib:flx_library, sym:string) : address =
  {
    if lib.filename == "" do
      var reg = #get_module_registry;
      match reg.get lib.modulename with
      | #None => return NULL;
      | Some dict =>
        match dict.get sym with
        | #None => return NULL;
        | Some sym => return sym;
        endmatch;
      endmatch; 
    else 
      return raw_dlsym (lib,sym);
    done
  }

@h1 Library instance type @{flx_instance}
A library instance is a closure consisting of the
library code, represent by a library handle, 
together with a pointer to an instance of the
libraries thread frame. Operations in this category
only work with Felix generated library objects.
@felix
  //$ Type of a DLL (dynamic link library) instance.
  //$ Conceptually this is a pair consisting of
  //$ a library object and a global data frame object.
  _gc_pointer type flx_instance = "::flx::rtl::flx_libinst_t*";

@h2 Library instance constructor @{create_instance_handle}
Create a new library instance handle unassociated with any
library or thread frame.
@felix
  //$ Create a fresh DLL instance object.
  fun create_instance_handle: bool->flx_instance=
    "new(*PTF gcp, ::flx::rtl::flx_libinst_ptr_map, false) ::flx::rtl::flx_libinst_t($1)";

@h2 Create a library instance from a library: @{create}
This procedure creates a thread frame from a library,
initialises it, and sets the given library instance
with the library handle and thread frame.
The instance handle should not already be associated with a library
or thread frame.
@felix 
  //$ Create a DLL instance from a DLL.
  //$ This is a procedure, so maybe the caller is too
  //$ which means the thread frame must be available.
  proc create: flx_library * flx_instance =
    "$2->create($1,PTF gcp,PTF argc,PTF argv,PTF flx_stdin, PTF flx_stdout, PTF flx_stderr, false);" 
    requires property "needs_gc"
  ;

  proc create_with_args: flx_library * flx_instance * int * + (+char) =
    "$2->create($1,PTF gcp,$3,$4,PTF flx_stdin, PTF flx_stdout, PTF flx_stderr, false);" 
    requires property "needs_gc"
  ;

  proc create_with_args (lib:flx_library, inst:flx_instance, args:list[string])
  {
    // convert list to a varray of strings
    var a = varray args; 

    // now convert to varray of char pointers
    gen myget(i:size)=>a.i.cstr; 
    var x = varray[+char] (a.len,a.len,myget); 
    create_with_args (lib,inst,x.len.int,x.stl_begin);
  }


@h2 Get the filename from an instance @{filename}.
@felix 
  //$ Get the filename of a DLL from an instance of it.
  fun filename : flx_instance -> string = "::std::string($1->lib->filename)";

@h2 Get the startup procedure from an instance @{filename}.
Felix generated libraries contain a symbol which is used
to initialise the thread frame. This initialisation is
in addition to that performed when the instance is created.
Typically the instance creation initialisation simply invokes
the C++ default constructor and sets a couple of critical
variables including a pointer to the garbage collector
and standard input/output streams.

The startup procedure we get here, on the other hand,
usually refers to the client program when using the
scripting model; the behaviour of the program is 
the observable side effects of this initialisation
procedure.

For plugin libraries, the initialisation procedure is used
to construct default values or initialise starting state.

The initialisation procedure is represent by a pointer
to a continuation object, type @{cont}, which has to be run
by a scheduler after associating it with a fibre:
the procedure is <em>not</em> a C function.
@felix 
  //$ Get the initialisation continuation of an instance.
  fun get_init: flx_instance -> cont = "$1->start_proc";

@h2 Get the library associated with an instance.
@felix
  //$ Get the DLL associated with an instance.
  fun get_library: flx_instance -> flx_library = "$1->lib";

@h2 Get the thread frame associated with an instance.
Since we don't know the type of the thread frame here,
it is returned as a pure address.
@felix
  //$ Get the thread frame (global data object) of an instance.
  fun get_thread_frame: flx_instance -> address = "(void*)$1->thread_frame";

@h2 Convenience constructor for an instance @{init_lib}
This function creates a library handle and instance handle
and loads the library given a filename, all in one operation.
Then it runs the startup initialisation procedure.
Finally the instance is returned.
@felix

  //$ Create, link, and prepare a DLL instance from a modulename.
  //$ NOTE: libraries created here do not need to be roots
  // The code is never deleted (due to design issues with C).
  // If the library isn't reachable, you can't create an instance.
  // If an instance is created, it reaches the library.
  noinline gen prepare_lib(modulename:string):flx_instance = {
    var library = create_library_handle(get_debug_driver_flag());
    //Gc::add_root (C_hack::cast[address] library);
    var linstance =  create_instance_handle(get_debug_driver_flag());
    regopen #get_module_registry (library,modulename);
    create (library,linstance);
    return linstance;
  }

  //$ Create, link, and prepare a DLL instance from a modulename.
  noinline gen prepare_lib_with_args(modulename:string, args:list[string]):flx_instance = {
    var library = create_library_handle(get_debug_driver_flag());
    //Gc::add_root (C_hack::cast[address] library);
    var linstance =  create_instance_handle(get_debug_driver_flag());
    regopen #get_module_registry (library,modulename);
    create_with_args (library,linstance,args);
    return linstance;
  }


  //$ Create, link, and initialise a  DLL instance from a modulename.
  noinline gen init_lib(modulename:string):flx_instance = {
    var linstance = prepare_lib(modulename);
    var init = get_init linstance;
    Fibres::run init;
    return linstance;
  }

  //$ Create, link, and initialise a  DLL instance from a modulename.
  noinline gen init_lib_with_args(modulename:string, args:list[string]):flx_instance = {
    var linstance = prepare_lib_with_args(modulename,args);
    var init = get_init linstance;
    Fibres::run init;
    return linstance;
  }


@h2 Convenience to run a program @{run_lib}
This function does the same as @{init_lib}.
@felix
  //$ Run a Felix program from a filename.
  proc run_lib(modulename:string)
  {
    var linstance = init_lib(modulename);
    C_hack::ignore(linstance);
  }

  // BUG: no return code!
  proc run_program(args:list[string])
  {
    match args with
    | Cons (h, t) =>
      var linstance = prepare_lib_with_args(h,t);
      var init = get_init linstance;
      Fibres::run init;
    | _ => ;
    endmatch;
  }


@h2 Checked version of @{dlsym}
This routine tries to find a symbol with the specified
name in an instance, if it is found, the resulting address
is cast to the specified type. It also prints a diagnostic
if the symbol cannot be found.
@felix
  //$ Find typed address of a symbol in a DLL.
  noinline fun flx_dlsym[T] (linst: flx_instance, sym:string) = {
    var library = Dynlink::get_library linst;
    var tf = Dynlink::get_thread_frame linst;
//println$ "Trying to load symbol " + sym + " from library " + linst.filename;
    var raw_sym = Dynlink::find_sym$ library, sym;
    if isNULL raw_sym do
      eprintln$ "Unable to load symbol " + sym + " from library " + linst.filename;
      raise$ flx_link_failure_t(linst.filename,"dlsym","Cannot find symbol " + sym); 
    done
//    eprintln$ "loaded symbol " + sym + " from library " + linst.filename + " address= " + str raw_sym;
    var typed_sym = C_hack::cast[T] raw_sym;
    return typed_sym, tf;
  }

@h1 Higher level wrappers for finding Felix functions.
Here make a set of higher level wrappers for finding 
standard protocol Felix function in DLLs. These wrappers
create a closure by binding the C address of the constructor
for the Felix function class in C++ to the library instance,
and return that. 

Closures returned by these function can be invoked as normal
Felix functions and procedures. Whereas a function defined
in the current files binds to  the thread frame implicitly,
with a library the instance is required to supply the
thread frame. The closures returned by these wrappers
are bound to the libraries thread frame so they can
be invoked with the ordinary syntax.

Note that these operations are not type safe. If you get
the type wrong all hell will break loose. This is because
dlsym finds functions by their C names and C++ entities
use mangled names we cannot compute in a portable way.
@felix
  //$ Return a closure representing a symbol in a DLL instance
  //$ of a function of no arguments.
  noinline fun func0[R] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address --> R] (linst, sym);
    return fun () => s tf;
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a function of one argument.
  noinline fun func1[R,A0] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 --> R] (linst, sym);
    return fun (a0:A0) => s (tf, a0);
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a function of two arguments.
  noinline fun func2[R,A0,A1] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 * A1 --> R] (linst, sym);
    return fun (var a0:A0, var a1:A1) => s (tf, a0, a1);
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a procedure of no arguments.
  noinline fun proc0 (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address --> void] (linst, sym);
    return proc () { s tf; };
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a procedure of one argument.
  noinline fun proc1[A0] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 --> void] (linst, sym);
    return proc (a0:A0) { s (tf, a0); };
  }

  //$ Return a closure representing a symbol in a DLL instance
  //$ of a procedure of two arguments.
  noinline fun proc2[A0,A1] (linst: flx_instance, sym:string) = {
    var s,tf= flx_dlsym[address * A0 * A1 --> void] (linst, sym);
    return proc (a0:A0,a1:A1) { s (tf, a0, a1); };
  }

@h1 Plugins.
A plugin is a special kind of DLL which supplies two
fixed entry points: a setup routine, which is called
to initialise the thread frame given a string argument,
and a single entry point which is subsequently called
and which typically returns an object type consisting
of a set of methods acting on the object state and
initialised thread frame context.

The setup routine typically take a string of configuration
parameters, extracts them with a parser, and stores them
in variables.

The current protocol is that the setup function must
be called "dllname_setup", the entry point name is passed
as a string. 

In order to accomodate static linking of plugins in the
future, the setup and entry point symbols would need to have
univerally unique names, since static linkage cannot work
with duplicate definitions, so the protocol will change
to require the library name as a prefix. Stay tuned.

@felix
  //$ Specialised routine(s) to load stylised plugin.
  //$ Two entry points:
  //$
  //$ setup: string -> int
  //$
  //$ is called to initialise the instance globals.
  //$
  //$ entry-point: arg -> iftype
  //$
  //$ is the primary entry point, typically an object factory, 
  //$ when called with an argument
  //$ of type arg_t it returns //$ an object of type iftype.
  //$
  //$ This function returns the object factory.
  //$ setup is called automatically with the supplied string.
  //$
  //$ There are 3 variants where the factory function accepts
  //$ 0, 1 and 2 arguments.
  noinline gen  load-plugin-func0[iftype] (
    dll-name: string,   // name of the DLL minus the extension
    setup-str: string="",  // string to pass to setup
    entry-point: string=""   // export name of factory function
  ) : unit -> iftype =
  {
    var entrypoint = if entry-point == "" then dll-name else entry-point;
    var linst = Dynlink::init_lib(dll-name);
    var sresult = Dynlink::func1[int,string] (linst, dll-name+"_setup") (setup-str);
    C_hack::ignore(sresult);
    if sresult != 0 call eprintln$ "[dynlink] Warning: Plugin Library " + dll-name + " set up returned " + str sresult;
    return Dynlink::func0[iftype] (linst, entrypoint);
  }

  noinline gen  load-plugin-func1[iftype, arg_t] (
    dll-name: string,   // name of the DLL minus the extension
    setup-str: string="",  // string to pass to setup
    entry-point: string=""   // export name of factory function
  ) : arg_t -> iftype =
  {
    var entrypoint = if entry-point == "" then dll-name else entry-point;
    var linst = Dynlink::init_lib(dll-name);
    var sresult = Dynlink::func1[int,string] (linst, dll-name+"_setup") (setup-str);
    C_hack::ignore(sresult);
    if sresult != 0 call eprintln$ "[dynlink] Warning: Plugin Library " + dll-name + " set up returned " + str sresult;
    return Dynlink::func1[iftype,arg_t] (linst, entrypoint);
  }

  noinline gen  load-plugin-func2[iftype, arg1_t, arg2_t] (
    dll-name: string,   // name of the DLL minus the extension
    setup-str: string="",  // string to pass to setup
    entry-point: string=""   // export name of factory function
  ) : arg1_t * arg2_t -> iftype =
  {
    var entrypoint = if entry-point == "" then dll-name else entry-point;
    var linst = Dynlink::init_lib(dll-name);
    var sresult = Dynlink::func1[int,string] (linst, dll-name+"_setup") (setup-str);
    C_hack::ignore(sresult);
    if sresult != 0 call eprintln$ "[dynlink] Warning: Plugin Library " + dll-name + " set up returned " + str sresult;
    return Dynlink::func2[iftype,arg1_t, arg2_t] (linst, entrypoint);
  }

@h1 Utilities and misc.
@felix

  //$ Execute an address representing a top
  //$ level exported felix procedure's C wrapper,
  //$ this creates a 'read to run' continuation object
  //$ by both constructing the object using the thread
  //$ frame of the instance as an argument, and calling
  //$ it to fix a null return address and an arbitrary
  //$ client data pointer as arguments to the call method.
  fun bind_proc: flx_instance * address * address -> cont =
    "$1->bind_proc($2,$3)";

  //$ Get the OS dependent handle representing a loaded DLL.
  //$ Return as an address. 
  fun dlib_of : flx_library -> address = "(void*)$1->library";

  //$ Throw an exception indicating the failure to 
  //$ find a symbol in a DLL.
  proc dlsym_err:flx_library*string="""
    throw ::flx::rtl::flx_link_failure_t($1->filename,$2,"symbol not found");
  """;

  //$ Run a procedure represented by a string name with
  //$ given thread frame.
  noinline proc run_proc (linstance:flx_instance, p: string, data: address)
  {
    var lib = get_library linstance;
    var sym = find_sym(lib, p);
    if isNULL(sym) call dlsym_err(lib,p);
    var f = bind_proc(linstance, sym, data);
    run f;
  }


}


