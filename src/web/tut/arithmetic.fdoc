@title Parser Combinators
@h1 Stuff
@pre
// /home/fletch/project/felix.git/build/release/host/bin/flx --force --echo --test=build/release src/web/tut/arithmetic.fdoc
//
//To understand segfaults you do this:
//  (a) Run flx with --force and --echo
//        This tells you the name of the C++ file in the cache
//        Now edit the C++ file with your text editor to put printf()
//        statements in various places.
//
//  (b) Run flx again with --nofelix option
//        That stops the flxg compiler running so it doesn't clobber
//        your edits to the C++ file.
//
//You can then put Felix prints between the steps, this prints debug
//stuff to show progress AND it put the prints in the C++ so you can
//more easily find where you're up to.

//Some more notes:

//Compare this code against the 'E_let' case in 'eval' which uses a
//"short form syntax"
//
// let v = eval env e in #{ env <- (tag, v) ! (deref env); return v; } 
//

//Notice also 'deref' is used here since '*' is hidden by the syntax
//definition in effect for 'zero_or_more'.
//
//
//This can be addressed in the future using the approach taken
//by regdefs (see
//http://felix-lang.org/$/usr/local/lib/felix/felix-latest/share/lib/grammar/regexps.fsyn
//which uses a postfix '*'.
//
//"If you use a DSSL you can do like regdefs but then you have to
//"unquote" to get back to standard notation i.e. you introduce by pcomb
//(expr) pcomb switches syntax then you need in that syntax felix (expr)
//to switch back eg you can do pcomb ( a b c \ d* ) if you get my drift:
//you have a parser combinator language, there's no interaction with any
//Felix operators at all."

//On 05/06/2015, at 8:07 AM, Shayne Fletcher wrote:
//
//>       fun str (tok : token_t) : string => ... ;
//>       fun str (ast : ast_t) : string => ... ;
//
//You should override the virtual:
//
//instance Str[token_t] {
//        fun str (tok : token_t) : string => ... ;
//}
//open Str[token_t];
//
//This allows you to, for example print a token.
//
//>
//>        match parse "..." with
//>          | Some l => println$ str (map str l); //here
//>          | #None => println$ "Oh dear";
//>        endmatch;
//>
//>     it seems the compiler can't work out which overload to choose
//
//Of course not. How can it? Here str is being passed as an argument
//to map, so map can't overload without knowing the type of the function
//you're passing. Use
//
//        map str of (token_t) l
//
//The syntax
//
//        str of type
//
//is how you provide a function set an argument type when you're not
//providing an argument\value.
//
//>
//> (2) I have a type like this:
//>
//>       union result[A, B] =  Ok of A | Error of B ;
//>
//>       union error_t =
//>         | Syntax_error
//>         | Unbound_variable of string
//>         | Division_by_zero
//>         ;
//>
//>      Assume a 'str' overload like so:
//>
//>       fun str (err : error_t) : string =>
//>         match err with
//>           | Unbound_variable s => "Unbound variable '" + s + "'"
//>           | #Syntax_error => "Syntax error"
//>           | #Division_by_zero => "Attempted division by zero"
//>         endmatch
//>       ;
//>
//>      What I want to do is write a general 'str' for 'result' e.g.
//>
//>       fun str[A, B with Str[A], Str[B]] (res:result[A, B]) : string =>
//>         match res with
//>           | Ok a => str a
//>           | Error b => "Error : " + str b
//>        endmatch;
//>
//>      2.1 Is the syntax correct (for the multiple type constraints)?
//
//Yes.
//
//>      2.2 Any attempt to use the definition above fails - the compiler does not want to accept that there is an overload 'fun str (err : error_t) : string' it can use in the second case of the 'match'. What am I missing?
//
//Your str is not an instance of the typeclass Str.
//
//--
//john skaller
//skaller@users.sourceforge.net
//http://felix-lang.org
//

// --
@
@felix
//Result of a parse
union parsed[A, B] = 
  | Returns of B * list[A] 
  | Parse_failed
  ;

//struct singular_value_t {};
//var singular_value = singular_value_t ();

typedef singular_value_t = unit;
var singular_value = ();

//Type of a parser
typedef parser[A, B] = list[A] -> parsed[A, B];

//Emtpy string parser
fun empty[A, B] (v:B)(toks:list[A]):parsed[A, B] => 
  Returns (v, toks)
  ;

//Given a predicate, produce a parser
fun token[A, B](test:A->opt[B]):parser[A,B] =>
  fun (l:list[A]):parsed[A, B] => 
    match l with
    | Cons (t, ts) =>
        match test t with
        | Some r => Returns[A, B] (r, ts)
        | #None => Parse_failed[A, B]
        endmatch
    | #Empty => Parse_failed[A, B]
    endmatch
  ;

//Parser of a specific token
fun char_[A with Eq[A]] (ch:A):parser[A, A] =>
  token (
  fun (tok:A):opt[A] =>
    match tok with
       | $(ch) => Some ch
      | _ => None[A]
    endmatch
  )
  ;

//Parser disjunction
fun orelse[A, B] (p1:parser[A, B], p2:parser[A, B]):parser[A, B] =>
   fun (toks:list[A]):parsed[A, B] =>
      match p1 toks with
        | #Parse_failed => p2 toks
        | res => res
      endmatch
  ;

//Parser conjunction
fun andalso[A, B, C] (p1:parser[A, B],p2:parser[A, C]):parser[A, (B * C)] =>
  fun (toks:list[A]) : parsed[A, (B * C)]=>
    match p1 toks with
      | Returns (r1, toks1) =>
          match p2 toks1 with
            | Returns (r2, toks2) => Returns ((r1, r2), toks2)
            | _ => Parse_failed[A, (B * C)]
          endmatch
      | _ => Parse_failed[A, (B * C)]
    endmatch
  ;

//Transform the result of a parse
fun gives[A, B, C] (p:parser[A, B], f:B ->C):parser[A, C] =>
  fun (toks:list[A]):parsed[A, C] =>
    match p toks with
      | Returns (v, toks1) => Returns (f v, toks1)
      | _ => Parse_failed[A, C]
   endmatch
  ;

//Infix operators
syntax infix_c
{
  //orelse
  x[ssetunion_pri] := 
   x[ssetunion_pri] "|~" x[>ssetunion_pri] =># 
    '''`(ast_apply ,_sr (,(nos "orelse") (,_1 ,_3)))'''
  ;

  //andalso
  x[ssetintersection_pri] := 
   x[ssetintersection_pri] "&~" x[>ssetintersection_pri] =># 
    '''`(ast_apply ,_sr (,(nos "andalso") (,_1 ,_3)))'''
  ;

  //gives
  x[scomparison_pri]:= 
   x[scomparison_pri] ">=~" x[>scomparison_pri] =># 
    '''`(ast_apply ,_sr (,(nos "gives") (,_1 ,_3)))'''
  ;

  //givento
  x[scomparison_pri]:= 
   x[scomparison_pri] ">>=~" x[>scomparison_pri] =># 
    '''`(ast_apply ,_sr (,(nos "givento") (,_1 ,_3)))'''
  ;

}

open syntax infix_c;

//These idioms comes up enough to be worth factoring them out
fun fst[A, B] (p : A * B) : A => p.0 ;
fun snd[A, B] (p : A * B) : B => p.1 ;
fun prepend[T] (p : T * list[T]) : list[T] => Cons (p.0, p.1) ;

//Kleene '*'
fun zero_or_more[A, B] (p:parser[A, B]): parser[A, list[B]] =>
  fun (toks:list[A]) : parsed[A, list[B]] =>
   ( (p &~ zero_or_more p >=~ prepend[B])
   |~ (empty[A, list[B]] (list[B]())) ) toks
;

syntax prefix_c 
{
  //zero_or_more
  x[srefr_pri] := "*" x[srefr_pri] =># "(prefix 'zero_or_more)";
}

open syntax prefix_c;

//Check if a character is a member of one of the provided ranges
fun char_range (c:char)(l:list[char * char]):bool =>
  match l with
    | #Empty => false
    | Cons ((c1, c2), tl) =>    
       (ord c1 <= ord c and ord c <= ord c2) or char_range c tl
  endmatch
  ;

//An element of the alphabet
var letter : parser[char, char] =
  token (fun (c:char) => 
           if char_range c 
            (list[char*char](
             (char 'a', char 'z'), 
            (char 'A', char 'Z'))) 
           then Some c else None[char])
  ;

//Digit parser
var digit : parser[char, char] = 
  token (fun (c:char) : opt[char] => if isdigit c then Some c else None[char])
  ;

//Parser of a sequence of digit
var digits : parser[char, list[char]] = 
  (digit &~ *digit) >=~ prepend[char]
  ;

// '-' | '+' | eps
var optsign : parser[char, list[char]] =
  token (fun (c:char):opt[list[char]] =>
    match c with
    | c when c == char '-' => Some (list[char] (c))
    | c when c == char '+'=> Some (list[char] (c))
    | _ => None[list[char]]
   endmatch) |~ empty[char, list[char]] (list[char] ())
  ;

// '.' digit* | eps
var optfrac : parser[char, list[char]] =
  ( char_ (char '.') &~ *digit >=~ prepend[char])
  |~ empty[char, list[char]] (list[char] ())
  ;

//(('e'|'E') optsign digits)|eps
var optexp : parser[char, list[char]] =
  (((((char_ (char 'e') |~ char_ (char 'E')) &~ optsign) 
    >=~ prepend[char]) &~ digits) 
    >=~ (fun (x:list[char], y:list[char]) : list[char] => x + y)) 
  |~ empty[char, list[char]] (list[char] ())
;

//Tokens
union token_t  =
  | T_num of double
  | T_ident of string
  | T_lparen | T_rparen
  | T_plus | T_minus | T_star | T_slash | T_semicolon | T_equal
  ;

instance Str[token_t] {
  fun str (tok : token_t) : string =>
    match tok with
      | T_num f => "T_num " + (str f)
      | T_ident s => "T_ident " + s
      | #T_lparen => "T_lparen"
      | #T_rparen => "T_rparen"
      | #T_plus => "T_plus"
      | #T_minus => "T_minus"
      | #T_star => "T_star"
      | #T_slash => "T_slash"
      | #T_semicolon => "T_semicolon"
      | #T_equal => "T_equal"
    endmatch
    ;
}

//Explode a string into a list of char
fun explode (s:string):list[char] =
{
  val n:size = len s;
  fun loop (acc:list[char]) (i:size) : list[char] =>
    if (i == n) then rev acc
    else loop (Cons (s.[i], acc)) (i + 1)
  ;
  return loop (list[char]()) 0uz;
};

//Implode a list of char to a string
fun implode (xs:list[char]) =>
  fold_left (fun (a:string) (b:char):string => a + b) "" xs
  ;

//Number token
var number:parser[char, token_t] =
  (digits &~ optfrac &~ optexp) >=~
    (fun (p:list[char] * list[char], cse:list[char]):token_t =>
      T_num (atof (implode (p.0 + p.1 + cse))))
  ;

//Identifier token
var identifier : parser[char, token_t] =
  (letter &~ (zero_or_more letter)) >=~ 
    (fun (c:char, cs:list[char]):token_t => 
       T_ident (implode (Cons (c, cs))))
  ;

//Operator token
var operator : parser[char, token_t] =
  token (
    fun (ch:char) : opt[token_t] =>
      match ch with
      | c when c == char '-' => Some T_minus
      | c when c == char '+' => Some T_plus
      | c when c == char '*' => Some T_star
      | c when c == char '/' => Some T_slash
      | _ => None[token_t]
    endmatch
  );

//Parenthesis token
var paren : parser[char, token_t] =
  token (
    fun (ch:char) : opt[token_t] =>
      match ch with
      | c when c == char '(' => Some T_lparen
      | c when c == char ')' => Some T_rparen
      | _ => None[token_t]
      endmatch
  );

//Equal token
var equal : parser[char, token_t] =
  token (
   fun (ch:char) : opt[token_t] =>
      match ch with
      | c when c == '=' => Some T_equal
      | _ => None[token_t]
    endmatch
  );

//Semicolon token
var semicolon : parser[char, token_t] =
  token (
    fun (ch:char) : opt[token_t] =>
      match ch with
      | c when c == ';' => Some T_semicolon
      | _ => None[token_t]
     endmatch
  );

//Parse a whitespace character
var space_ : parser[char, singular_value_t] =
 token (fun (ch:char) : opt[singular_value_t] =>
   match ch with
     | c when c == char ' ' => Some singular_value
     | c when c == char '\t' => Some singular_value
     | c when c == char '\n' => Some singular_value
     | c when c == char '\r' => Some singular_value
     | _ => None[singular_value_t]
   endmatch
  );


//Parser of whitespace
fun spaces (toks:list[char]) : parsed[char, singular_value_t] =>
  (((space_ &~ spaces) >=~ 
       fst[singular_value_t, singular_value_t])
    |~ empty[char, singular_value_t](singular_value))
  toks
  ;

//Lexer for the language of arithmetic expressions
fun lex (toks : list[char]) : parsed [char, list[token_t]] =>
    (spaces &~ 
    *((( identifier 
        |~ number 
        |~ operator 
        |~ paren 
        |~ semicolon 
        |~ equal) &~ spaces) >=~ 
    (fst[token_t, singular_value_t])) 
       >=~ snd[singular_value_t, list[token_t]]) toks
  ;

//Arithmetic expressions
union ast_t =
  | E_const of double
  | E_var of string
  | E_add of ast_t * ast_t
  | E_sub of ast_t * ast_t
  | E_mul of ast_t * ast_t
  | E_div of ast_t * ast_t
  | E_let of (string * ast_t)
  ;

fun str (ast : ast_t) : string =>
  match ast with
    | E_const f => "E_const (" + str f + ")"
    | E_var s => "E_var (" + s + ")"
    | E_add (x, y) => "E_add (" + str x + ", " + str y + ")"
    | E_sub (x, y) => "E_sub (" + str x + ", " + str y + ")"
    | E_mul (x, y) => "E_mul (" + str x + ", " + str y + ")"
    | E_div (x, y) => "E_div (" + str x + ", " + str y + ")"
    | E_let (s, e) => "E_let (" + s + ", " + str e + ")"
  endmatch
  ;

//Constants
val num:parser[token_t, ast_t] =
  token (
    fun (t:token_t):opt[ast_t] =>
      match t with
        | T_num n => Some (E_const n)
        | _ => None[ast_t]
      endmatch
  );

//Identifiers
val ident:parser[token_t, ast_t] =
  token (
    fun (t:token_t):opt[ast_t] =>
      match t with
        | T_ident s => Some (E_var s)
        | _ => None[ast_t]
  );

//Addition, subtraction operators
val addop:parser[token_t, ast_t -> ast_t -> ast_t] =
  token (
    fun (t:token_t):opt[ast_t -> ast_t -> ast_t] =>
      match t with
        | #T_plus => Some (fun (e1:ast_t)(e2:ast_t):ast_t => E_add (e1, e2))
        | #T_minus => Some (fun (e1:ast_t)(e2:ast_t):ast_t => E_sub (e1, e2))
        | _ => None[ast_t -> ast_t -> ast_t]
        endmatch
  );

//Multiplication, division operators
val mulop:parser[token_t, ast_t -> ast_t -> ast_t] =
  token (
    fun (t:token_t):opt[ast_t -> ast_t -> ast_t] =>
      match t with
        | #T_star => Some (fun (e1:ast_t)(e2:ast_t):ast_t => E_mul (e1, e2))
        | #T_slash => Some (fun (e1:ast_t)(e2:ast_t):ast_t => E_div (e1, e2))
        | _ => None[ast_t -> ast_t -> ast_t]
        endmatch
  );

//A parser that feeds its result into another
fun givento[A, B, C] (p1:parser[A, B], p2:B -> parser[A, C]) : parser[A, C] =>
  fun (toks : list[A]) : parsed[A, C] =>
     match p1 toks with
      | Returns (r1, toks1) => p2 r1 toks1
      | #Parse_failed => Parse_failed[A, C]
     endmatch
    ;

//Build left-associative trees e.g. expr := term (op term)*
fun left_assoc[A, B] 
  (term : parser[A, B]) 
  (op : parser[A, B -> B-> B]) : parser[A, B] =>
  let 
    fun sequence (t1:B) : parser [A, B] =>
      let fn = fun (f:B -> B -> B, t2:B) => f t1 t2 in
      (op &~ term >=~ fn >>=~ sequence of (B)) |~ (empty[A, B] t1)
  in
    (term >>=~ sequence)
;

//Opening paren
var open_paren : parser[token_t, singular_value_t] =
  let fun t (tok : token_t) : opt[singular_value_t] =>
    match tok with
    | #T_lparen => Some singular_value
    | _ => None[singular_value_t]
  in token t
;

//Closing paren
var close_paren : parser[token_t, singular_value_t] =
  let fun t (tok : token_t) : opt[singular_value_t] =>
    match tok with
    | #T_rparen => Some singular_value
    | _ => None[singular_value_t]
  in token t
;

//Semi-colon
var semi : parser[token_t, singular_value_t] =
  let fun t (tok : token_t) : opt[singular_value_t] =>
    match tok with
    | #T_semicolon => Some singular_value
    | _ => None[singular_value_t]
  in token t
;

//Equals sign
var equals : parser[token_t, singular_value_t] =
  let fun t (tok : token_t) : opt[singular_value_t] =>
    match tok with
    | #T_equal => Some singular_value
    | _ => None[singular_value_t]
  in token t
;

//A language of arithmetic expressions
/*
expr_list :=
  | expr (';' expr)*
  ;
expr :=
  | identifier '=' expr
  | term (['+'|'-'] term)*
  ;
term :=
  | fact (['*'|'/'] fact)*
  ;
fact :=
  | num
  | identifier
  | '( expr ')
 */

//expr_list := expr (';' expr)*
var expr_list : parser[token_t, list[ast_t]] = 
  ((expr &~ *((semi &~ expr) >=~ snd[singular_value_t, ast_t])
     >=~ prepend[ast_t]))
   |~empty[token_t, list[ast_t]] (list[ast_t]())
  ;

//expr :=
//| bind
//| term (['+'|'-'] term)*
//;
fun expr (toks : list[token_t]) : parsed[token_t, ast_t] =>
  (bind |~ left_assoc[token_t, ast_t] term addop) toks
  ;

//bind := identifier '=' expr
var bind : parser[token_t, ast_t] =
   (((ident &~ equals) >=~ fst[ast_t, singular_value_t]) &~ expr) >=~ 
   (fun (p : ast_t * ast_t) : ast_t => 
      match p.0 with
      | E_var e => E_let (e, p.1)
      endmatch)
  ;

//term := fact (['*'|'/'] fact)*
var term : parser[token_t, ast_t] = left_assoc[token_t, ast_t] fact mulop ;

//fact :=
// | num
// | identifier
// | '( expr ')
// ;
fun fact (toks : list[token_t]) : parsed[token_t, ast_t] =>
  (num |~ ident |~ 
    ((open_paren &~ expr &~ close_paren) >=~ 
        (fun (p:(singular_value_t * ast_t), u:singular_value_t) : ast_t => p.1))
   ) toks
  ;

//A function to extract the result of a parse
fun accept[A, B] (result : parsed[A, B]) : opt[B] =>
  match result with
  | Returns (b, #Empty) => Some[B] (b)
  | #Parse_failed => None[B]
  | _ => None[B] //meaning, not all chars consumed
  endmatch
  ;

//A function to produce a list of tokens from a string
fun tokenize (s : string) : opt[list[token_t]] => 
  accept (lex (explode (s))) 
  ;

//A function to produce an AST from a list of tokens
fun parse_expr (s : string) : opt[ast_t] =>
  match tokenize s with
    | Some toks => accept (expr toks)
    | #None => None[ast_t]
  endmatch
  ;

//A function to produce a list of ASTs from a list of tokens
fun parse_expr_list (s : string) : opt[list[ast_t]] =>
  match tokenize s with
  | Some toks => accept (expr_list toks)
  | #None => None[list[ast_t]]
  endmatch
  ;

//'assoc a l' returns the value associated with key 'a in the list of
//pairs 'l'.  That is, 'assoc a [ ...; (a,b); ...] = b' if '(a,b)' is
//the leftmost binding of 'a' in list 'l'
fun assoc[A, B with Eq[A]] (x : A) (l : list[(A * B)]) : opt[B] =>
  match l with
    | #Empty => None[B]
    | Cons ((a, b), t) => if a == x then Some b else assoc x t
  endmatch
    ;

union result[A, B] =  Ok of A | Error of B ;

union error_t =
  | Syntax_error
  | Unbound_variable of string
  | Division_by_zero
  ;

fun str (err : error_t) : string =>
  match err with
    | Unbound_variable s => "Unbound variable '" + s + "'"
    | #Syntax_error => "Syntax error"
    | #Division_by_zero => "Attempted division by zero"
  endmatch
  ;

//Evaluate an expression in an environment
fun eval 
   (env:&list[(string * double)]) 
   (ast:ast_t) 
   : result[double, error_t] =>
  (
  match ast with 
    | E_const f => Ok[double, error_t] f
    | E_let (tag, e) => 
       let v = eval env e in
       match v with
         | Ok f => ( env <- (tag, f) ! (deref env);  v)
         | _ => v
       endmatch
   | E_var s => 
      let v  = assoc s (deref env) in
      match v with
        | Some f => Ok[double, error_t] f
        | #None => Error[double, error_t] (Unbound_variable s)
      endmatch
   | E_add (l, r) => 
     let lhs = eval env l in
     match lhs with
        | Ok x =>
          let rhs = eval env r in
          match rhs with
            | Ok y => Ok[double, error_t] (x + y)
            | _ as error => error
          endmatch
        | _ as error => error
      endmatch          
   | E_sub (l, r) => 
     let lhs = eval env l in
     match lhs with
        | Ok x =>
          let rhs = eval env r in
          match rhs with
            | Ok y => Ok[double, error_t] (x - y)
            | _ as error => error
          endmatch
        | _ as error => error
      endmatch          
   | E_mul (l, r) => 
     let lhs = eval env l in
     match lhs with
        | Ok x =>
          let rhs = eval env r in
          match rhs with
            | Ok y => Ok[double, error_t] (x * y)
            | _ as error => error
          endmatch
        | _ as error => error
      endmatch          
   | E_div (l, r) => 
     let lhs = eval env l in
     match lhs with
        | Ok x =>
          let rhs = eval env r in
          match rhs with
            | Ok y => 
                 if y != 0.0 then 
                   Ok[double, error_t] (x / y)
                 else
                   Error[double, error_t] (Division_by_zero)
            | _ as error => error
          endmatch
        | _ as error => error
      endmatch          
   endmatch)
  ;

gen parse_eval_expr
  (env:&list[(string*double)]) (s:string) : result[double, error_t] =
{
  val expr : opt[ast_t] = parse_expr s;

  if (is_defined expr) do
    return eval env (get expr);
  done

  return Error[double, error_t](Syntax_error);
}

gen parse_eval_exprs 
  (env:&list[(string*double)]) (s:string) : result[list[double], error_t] =
{
  fun f 
      (acc : result[list[double], error_t]) 
              (e : result[double, error_t]) : 
              result[list[double], error_t] =>
    match acc with
      | Ok l =>
          match e with
            | Ok v => Ok[list[double], error_t] (l + v)//slow
            | Error error => Error[list[double], error_t](error)
          endmatch
      | Error error => Error[list[double], error_t] (error)
    endmatch
  ;

  val exprs : opt[list[ast_t]] = parse_expr_list s;

  if (is_defined exprs) do
    return fold_left 
             f (Ok[list[double], error_t](list[double]())) 
             (map (eval env) (get exprs));
  done

  return Error[list[double], error_t](Syntax_error);
}  

proc prompt (continuing:bool) {
  if (not continuing) do
    write$ stdout, "? ";
  else
    write$ stdout, "... ";
  done;
  fflush stdout;
}

gen read (continuing:bool) : string = {
  prompt (continuing);
  val l = readln$ stdin;

  return l;
}

//Read-eval-print-loop
proc repl () {

  //oh hai!
  println$ "";
  println$ "Interpreter of arithmetic expressions (with variables)";
  println$ "Type ^D to quit.";

  var env = list [(string * double)]();

  //A buffer
  var buf:string ="";
  reserve (&buf, 1048); //initial capacity
  
repl_loop : //iz in ur loop!
  while true do

    var l:string = read (len buf != 0uz);
    var n:size = len l;

    if n == 0uz 
      break repl_loop; //kthxbai!

    l = substring (l, 0, n - 1) ; // Strip newline
    n = n - 1; //update char count

    if n > 0uz do
      if (l.[0] == char '%') //Comment line. Discard
        continue repl_loop;

      if l.[n - 1] == char '\\' do //Line continuation; append and keep reading
        buf += substring (l, 0, n - 1);
        continue repl_loop;
      done

      if l.[n - 1] == char 7 do //Discard partial statements with ^G
        buf = "";
        continue repl_loop;
      done

      //We think we got a phrase. Evaluate
      buf += l;
      var res : result[list[double], error_t] = parse_eval_exprs (&env) buf;
      buf = ""; //reset buf
      var response : string =
        match res with 
         | Ok a => str (head (drop (int (len a) - 1) a))
         | Error err => str err
       endmatch;
       println$ response;

    done
  done //repl_loop
  println$ "";
}

repl () ;
@
@input
x=1
y=2
x+y
x+(x*y)+43-y/1
@
@expect

Interpreter of arithmetic expressions (with variables)
Type ^D to quit.
? x=1
1
? y=2
2
? x+y
3
? x+(x*y)+43-y/1
44
? 
@
