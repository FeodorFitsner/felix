@title GSL binding
@tangler gsl.flx = share/lib/gnu/gsl.flx
@tangler cblas.flx = share/lib/blas.flx
@tangler gslffi.flx = $PWD/gslffi.flx

@h1 A binding for GNU GSL
Licence for this file: GNU documentation licence NOT LGPL.

As at 4 Aug 2015 most of the functions are in here.
But no types, constants, or macros.
No links to docs. No docs. No test cases.
No classes and no requirements clauses.
Work in progress.

DO NOT EDIT YET. Most of this file is mechanically
generated from over 400 pages which were painfully
copied from my web browser by hand.

@h1 Binding generator
Run with
@pre
flx gslffi ~/gslspec >binding.flx
@
to create the binding. The directory @{gslspec}
contains hand copied text versions of the official GSL
library documentation.

@tangle gslffi.flx

// extract gsl functions from docs
var lre = RE2 "([0-9]+)(\\.([0-9]+)(\\.([0-9]+))?)? +(.*)";
if not lre.ok do
  println "BAD RE";
  assert false;
done

var dirname = System::argv 1;
var files = FileSystem::regfilesin (dirname,".*\\.txt");
match files do 
| #Empty=> println$ "// NO FILES FOUND in " + dirname;
| files => 
    println$ "// Dirname " + dirname;
    //println$ "// Files: " + files.str;
    var sfiles = map (fun (file:string)=> find_index$ Filename::join(dirname, file))  files;
    sfiles = sort sfiles;
    iter (proc (file:string){ process_file$ (file.[to 8],file.[9 to]);}) sfiles;
done

fun find_index (filename:string) : string =
{
  var text = load filename;
  var lines = split(text,char "\n");
  var ready = false;
  for line in lines do
    if ready == true do
//println$ "Index line " + line;
      var result = Match (lre, line);
      match result do  
      | #None => 
        if prefix(line, "Appendix D") do
          return ("D .00.00 "+filename);
        elif prefix(line,"D.") do
          return "D .0"+line.[2 to 3]+".00 "+filename;
        else
          println$ "BUG unexpected index format in " + line;
          assert false;
        done
      | Some v =>
//println$ "Got match "+ v.str;
//        println$ "Index=" + v.1 + "." + v.3 + "." + v.5 + " title=" + v.6;
        var s = f"%02d.%02d.%02d %S" (v.1.int,v.3.int,v.5.int,filename);
//println$ "CODE=" + s;
        return s;
      done
    done
    if prefix(line,"Next:") or prefix(line,"Previous") do ready = true; done;
  done
  println$ "BUG no index number";
  assert false;
  return ""; // hack
}

proc process_file (section:string, filename:string)
{
  println$ "// "+section+ " " + filename.[23 to -3];
  var text = load filename;
  var lines = split(text,char "\n");
  for line in lines do
    //println$ "// " + line;
    if prefix(line,"Function: ") do
      println$ "// " + line;
      var munged = line.[10 to];
      munged = search_and_replace (munged, "("," ( ");
      munged = search_and_replace (munged, ")"," ) ");
      munged = search_and_replace (munged, ","," , ");
      var words = filter (fun (s:string) => s != "" and s != "const") (munged,char " ").split;
      var parsed = parse_cfun words;
      var felix = format_fun parsed;
      println$ "  " + felix;
    done
  done
  println "//*****";
}

typedef type_t = list[string];
typedef arg_t = (aname:string, atype: type_t);
typedef fun_t = (fname:string, args:list[arg_t], ret:type_t); 

fun parse_cfun (var w:list[string]) =
{
  var ret = list[string] ();
  var fname = "";
  var args = list[arg_t] ();
  var argt = list[string] ();

  grab_ret:>
    match w do
    | ty ! nm ! "(" ! tl => 
      ret = ret + ty; 
      fname = nm; 
      w = tl; 
      goto grab_args;
    | nm ! "(" ! tl => 
      fname = nm; 
      w = tl; 
      goto grab_args;
    | x ! tl =>  
      ret = ret + x; 
      w = tl; 
      goto grab_ret;
    | _ => 
println$ "BUG parsing return type: w="+w.str;
      assert false;
    done

  grab_args:>
    argt = list[string]();
    match w do
    | ")" ! tl => goto fin;
    | "void" ! ")" ! tl => goto fin;
    | _ => ;
    done
  grab_arg:> 
    match w do
    | "..." ! ")" ! tl =>
      args = args + (aname="", atype=list[string] "...");
      goto fin;

    | ty ! nm ! "," ! tl => 
      if nm.[-2 to] == "[]" do
        argt = argt + ty + "[]"; 
        args = args + (aname = nm.[to -2],  atype = argt);
      else
        argt = argt + ty; 
        args = args + (aname = nm,  atype = argt);
      done
      w = tl; 
      goto grab_args;


    | ty ! nm ! ")" ! tl => 
      if nm.[-2 to] == "[]" do
        argt = argt + ty + "[]"; 
        args = args + (aname = nm.[to -2],  atype = argt);
      else
        argt = argt + ty; 
        args = args + (aname = nm,  atype = argt);
      done
      w = tl; 
      goto fin;

    | x ! tl =>  
      argt = argt + x; 
      w = tl;
      goto grab_arg;
    | _ =>
println$ "BUG parsing arguments w="+w.str;
     assert false;
    done
  fin:>
   return (fname=fname, args=args, ret=ret); 
}

fun get_base_type (t:type_t) : string * type_t =>
  match t with
  | "unsigned" ! "long" ! "int" ! tl => "ulong", tl
  | "unsigned" ! "int" ! tl => "uint", tl
  | "enum" ! nm ! tl => nm,tl
  | "struct" ! nm ! tl => nm,tl
  | "size_t" ! tl => "size",tl
  | x ! tl => x, tl
;

fun format_type (t:type_t) : string = 
{
  var base, rest = get_base_type t; 
  match rest do
  | #Empty => return base;
  | "[]" ! #Empty => return "+" + base;
  | "*" ! #Empty => return "&" + base;
  | "**" ! #Empty => return "&&" + base;
  | _ => 
    println$ "BUG parsing type t="+t;
    assert false;
  done
  return ""; //Ugg!
}
 

fun format_args (args:list[arg_t]) =>
  match args with
  | #Empty => "unit"
  | _ => catmap " * " (fun (p:arg_t) => format_type p.atype) args
  endmatch
;

// fix for procs ..
fun format_fun (f: fun_t) =>
  if format_type f.ret == "void" then
  "proc " + f.fname + ": " + format_args f.args +
  " = '" + f.fname + "($a);';"
  else
  "fun " + f.fname + ": " + 
  format_args f.args +
  " -> " + format_type f.ret +
  " = '" + f.fname + "($a)';"
  endif
;





@h1 Generated binding
For GSL. 
@tangle gsl.flx

// TEMPORARY HACKS: type names
ctypes 
  gsl_error_handler_t,
  gsl_complex,
  gsl_poly_complex_workspace,
  gsl_complex_packed_ptr,
  gsl_mode_t,
  gsl_sf_result,
  gsl_sf_result_e10,
  gsl_sf_mathieu_workspace,
  gsl_block,
  gsl_vector,
  gsl_vector_view,
  gsl_vector_const_view,
  gsl_vector_complex,
  gsl_matrix,
  gsl_matrix_view,
  gsl_matrix_const_view,
  gsl_permutation,
  gsl_combination,
  gsl_multiset,
  gsl_comparison_fn_t,
  gsl_vector_float,
  gsl_vector_complex_float,
  gsl_complex_float,
  CBLAS_INDEX_t,
  CBLAS_TRANSPOSE_t,
  gsl_matrix_float,
  gsl_matrix_complex_float,
  gsl_matrix_complex,
  CBLAS_UPLO_t,
  CBLAS_DIAG_t,
  CBLAS_SIDE_t,
  gsl_eigen_symm_workspace,
  gsl_eigen_symmv_workspace,
  gsl_eigen_herm_workspace,
  gsl_eigen_hermv_workspace,
  gsl_eigen_nonsymm_workspace,
  gsl_eigen_nonsymmv_workspace,
  gsl_eigen_gensymm_workspace,
  gsl_eigen_gensymmv_workspace,
  gsl_eigen_genherm_workspace,
  gsl_eigen_genhermv_workspace,
  gsl_eigen_gen_workspace,
  gsl_eigen_genv_workspace,
  gsl_eigen_sort_t,
  gsl_complex_packed_array,
  gsl_fft_direction,
  gsl_fft_complex_wavetable,
  gsl_fft_complex_workspace,
  gsl_fft_real_wavetable,
  gsl_fft_halfcomplex_wavetable,
  gsl_fft_real_workspace,
  gsl_function,
  gsl_integration_workspace,
  gsl_integration_qaws_table,
  gsl_integration_qawo_enum,
  gsl_integration_qawo_table,
  gsl_integration_cquad_workspace,
  gsl_integration_glfixed_table,
  gsl_rng_type,
  gsl_rng,
  gsl_qrng_type,
  gsl_qrng,
  gsl_histogram,
  gsl_histogram_pdf,
  gsl_histogram2d,
  gsl_histogram2d_pdf,
  gsl_ntuple,
  gsl_ntuple_value_fn,
  gsl_ntuple_select_fn,
  gsl_monte_plain_state,
  gsl_monte_function,
  gsl_monte_miser_state,
  gsl_monte_miser_params,
  gsl_monte_vegas_state,
  gsl_monte_vegas_params,
  gsl_siman_Efunc_t,
  gsl_siman_step_t,
  gsl_siman_copy_construct_t,
  gsl_siman_destroy_t,
  gsl_siman_metric_t,
  gsl_siman_print_t,
  gsl_siman_copy_t,
  gsl_siman_params_t,
  gsl_odeiv2_step_type,
  gsl_odeiv2_step,
  gsl_odeiv2_driver,
  gsl_odeiv2_system,
  gsl_odeiv2_control,
  gsl_odeiv2_control_type,
  gsl_odeiv2_evolve,
  gsl_interp_type,
  gsl_interp,
  gsl_interp_accel,
  gsl_spline,
  gsl_cheb_series,
  gsl_sum_levin_u_workspace,
  gsl_sum_levin_utrunc_workspace,
  gsl_wavelet_type,
  gsl_wavelet,
  gsl_wavelet_workspace,
  gsl_wavelet_direction,
  gsl_dht,
  gsl_root_fsolver_type,
  gsl_root_fsolver,
  gsl_root_fdfsolver_type,
  gsl_root_fdfsolver,
  gsl_function_fdf,
  gsl_min_fminimizer_type,
  gsl_min_fminimizer,
  gsl_multiroot_fsolver_type,
  gsl_multiroot_fsolver,
  gsl_multiroot_fdfsolver_type,
  gsl_multiroot_fdfsolver,
  gsl_multiroot_function,
  gsl_multiroot_function_fdf,
  gsl_multimin_fdfminimizer_type,
  gsl_multimin_fdfminimizer,
  gsl_multimin_fminimizer_type,
  gsl_multimin_fminimizer,
  gsl_multimin_function_fdf,
  gsl_multimin_function,
  gsl_multifit_linear_workspace,
  gsl_multifit_robust_type,
  gsl_multifit_robust_workspace,
  gsl_multifit_robust_stats,
  gsl_multifit_fsolver_type,
  gsl_multifit_fsolver,
  gsl_multifit_fdfsolver_type,
  gsl_multifit_fdfsolver,
  gsl_multifit_function,
  gsl_multifit_function_fdf,
  gsl_bspline_workspace,
  gsl_bspline_deriv_workspace
;

// Dirname /Users/skaller/gslspec
// 03.02.00 GSL-Error-Codes.
// Function: const char * gsl_strerror (const int gsl_errno)
  fun gsl_strerror: int -> &char = 'gsl_strerror($a)';
//*****
// 03.03.00 GSL-Error-Handlers.
// Function: gsl_error_handler_t * gsl_set_error_handler (gsl_error_handler_t * new_handler)
  fun gsl_set_error_handler: &gsl_error_handler_t -> &gsl_error_handler_t = 'gsl_set_error_handler($a)';
// Function: gsl_error_handler_t * gsl_set_error_handler_off ()
  fun gsl_set_error_handler_off: unit -> &gsl_error_handler_t = 'gsl_set_error_handler_off($a)';
//*****
// 03.04.00 GSL-Error-Reporting.
//*****
// 04.01.00 Mathematical-Constants.
//*****
// 04.02.00 Infinities-and-Not-a-number.
// Function: int gsl_isnan (const double x)
  fun gsl_isnan: double -> int = 'gsl_isnan($a)';
// Function: int gsl_isinf (const double x)
  fun gsl_isinf: double -> int = 'gsl_isinf($a)';
// Function: int gsl_finite (const double x)
  fun gsl_finite: double -> int = 'gsl_finite($a)';
//*****
// 04.03.00 Elementary-Functions.
// Function: double gsl_log1p (const double x)
  fun gsl_log1p: double -> double = 'gsl_log1p($a)';
// Function: double gsl_expm1 (const double x)
  fun gsl_expm1: double -> double = 'gsl_expm1($a)';
// Function: double gsl_hypot (const double x, const double y)
  fun gsl_hypot: double * double -> double = 'gsl_hypot($a)';
// Function: double gsl_hypot3 (const double x, const double y, const double z)
  fun gsl_hypot3: double * double * double -> double = 'gsl_hypot3($a)';
// Function: double gsl_acosh (const double x)
  fun gsl_acosh: double -> double = 'gsl_acosh($a)';
// Function: double gsl_asinh (const double x)
  fun gsl_asinh: double -> double = 'gsl_asinh($a)';
// Function: double gsl_atanh (const double x)
  fun gsl_atanh: double -> double = 'gsl_atanh($a)';
// Function: double gsl_ldexp (double x, int e)
  fun gsl_ldexp: double * int -> double = 'gsl_ldexp($a)';
// Function: double gsl_frexp (double x, int * e)
  fun gsl_frexp: double * &int -> double = 'gsl_frexp($a)';
//*****
// 04.04.00 Small-integer-powers.
// Function: double gsl_pow_int (double x, int n)
  fun gsl_pow_int: double * int -> double = 'gsl_pow_int($a)';
// Function: double gsl_pow_uint (double x, unsigned int n)
  fun gsl_pow_uint: double * uint -> double = 'gsl_pow_uint($a)';
// Function: double gsl_pow_2 (const double x)
  fun gsl_pow_2: double -> double = 'gsl_pow_2($a)';
// Function: double gsl_pow_3 (const double x)
  fun gsl_pow_3: double -> double = 'gsl_pow_3($a)';
// Function: double gsl_pow_4 (const double x)
  fun gsl_pow_4: double -> double = 'gsl_pow_4($a)';
// Function: double gsl_pow_5 (const double x)
  fun gsl_pow_5: double -> double = 'gsl_pow_5($a)';
// Function: double gsl_pow_6 (const double x)
  fun gsl_pow_6: double -> double = 'gsl_pow_6($a)';
// Function: double gsl_pow_7 (const double x)
  fun gsl_pow_7: double -> double = 'gsl_pow_7($a)';
// Function: double gsl_pow_8 (const double x)
  fun gsl_pow_8: double -> double = 'gsl_pow_8($a)';
// Function: double gsl_pow_9 (const double x)
  fun gsl_pow_9: double -> double = 'gsl_pow_9($a)';
//*****
// 04.05.00 Testing-the-Sign-of-Numbers.
//*****
// 04.06.00 Maximum-and-Minimum-functions.
//*****
// 04.06.00 Testing-for-Odd-and-Even-Numbers.
//*****
// 04.08.00 Approximate-Comparison-of_Floating-Point-Numbers.
// Function: int gsl_fcmp (double x, double y, double epsilon)
  fun gsl_fcmp: double * double * double -> int = 'gsl_fcmp($a)';
//*****
// 05.01.00 Representation-of-complex-numbers.
// Function: gsl_complex gsl_complex_rect (double x, double y)
  fun gsl_complex_rect: double * double -> gsl_complex = 'gsl_complex_rect($a)';
// Function: gsl_complex gsl_complex_polar (double r, double theta)
  fun gsl_complex_polar: double * double -> gsl_complex = 'gsl_complex_polar($a)';
//*****
// 05.02.00 Properties-of-complex-numbers.
// Function: double gsl_complex_arg (gsl_complex z)
  fun gsl_complex_arg: gsl_complex -> double = 'gsl_complex_arg($a)';
// Function: double gsl_complex_abs (gsl_complex z)
  fun gsl_complex_abs: gsl_complex -> double = 'gsl_complex_abs($a)';
// Function: double gsl_complex_abs2 (gsl_complex z)
  fun gsl_complex_abs2: gsl_complex -> double = 'gsl_complex_abs2($a)';
// Function: double gsl_complex_logabs (gsl_complex z)
  fun gsl_complex_logabs: gsl_complex -> double = 'gsl_complex_logabs($a)';
//*****
// 05.03.00 Complex-arithmetic-operators.
// Function: gsl_complex gsl_complex_add (gsl_complex a, gsl_complex b)
  fun gsl_complex_add: gsl_complex * gsl_complex -> gsl_complex = 'gsl_complex_add($a)';
// Function: gsl_complex gsl_complex_sub (gsl_complex a, gsl_complex b)
  fun gsl_complex_sub: gsl_complex * gsl_complex -> gsl_complex = 'gsl_complex_sub($a)';
// Function: gsl_complex gsl_complex_mul (gsl_complex a, gsl_complex b)
  fun gsl_complex_mul: gsl_complex * gsl_complex -> gsl_complex = 'gsl_complex_mul($a)';
// Function: gsl_complex gsl_complex_div (gsl_complex a, gsl_complex b)
  fun gsl_complex_div: gsl_complex * gsl_complex -> gsl_complex = 'gsl_complex_div($a)';
// Function: gsl_complex gsl_complex_add_real (gsl_complex a, double x)
  fun gsl_complex_add_real: gsl_complex * double -> gsl_complex = 'gsl_complex_add_real($a)';
// Function: gsl_complex gsl_complex_sub_real (gsl_complex a, double x)
  fun gsl_complex_sub_real: gsl_complex * double -> gsl_complex = 'gsl_complex_sub_real($a)';
// Function: gsl_complex gsl_complex_mul_real (gsl_complex a, double x)
  fun gsl_complex_mul_real: gsl_complex * double -> gsl_complex = 'gsl_complex_mul_real($a)';
// Function: gsl_complex gsl_complex_div_real (gsl_complex a, double x)
  fun gsl_complex_div_real: gsl_complex * double -> gsl_complex = 'gsl_complex_div_real($a)';
// Function: gsl_complex gsl_complex_add_imag (gsl_complex a, double y)
  fun gsl_complex_add_imag: gsl_complex * double -> gsl_complex = 'gsl_complex_add_imag($a)';
// Function: gsl_complex gsl_complex_sub_imag (gsl_complex a, double y)
  fun gsl_complex_sub_imag: gsl_complex * double -> gsl_complex = 'gsl_complex_sub_imag($a)';
// Function: gsl_complex gsl_complex_mul_imag (gsl_complex a, double y)
  fun gsl_complex_mul_imag: gsl_complex * double -> gsl_complex = 'gsl_complex_mul_imag($a)';
// Function: gsl_complex gsl_complex_div_imag (gsl_complex a, double y)
  fun gsl_complex_div_imag: gsl_complex * double -> gsl_complex = 'gsl_complex_div_imag($a)';
// Function: gsl_complex gsl_complex_conjugate (gsl_complex z)
  fun gsl_complex_conjugate: gsl_complex -> gsl_complex = 'gsl_complex_conjugate($a)';
// Function: gsl_complex gsl_complex_inverse (gsl_complex z)
  fun gsl_complex_inverse: gsl_complex -> gsl_complex = 'gsl_complex_inverse($a)';
// Function: gsl_complex gsl_complex_negative (gsl_complex z)
  fun gsl_complex_negative: gsl_complex -> gsl_complex = 'gsl_complex_negative($a)';
//*****
// 05.04.00 Elementary-Complex-Function.
// Function: gsl_complex gsl_complex_sqrt (gsl_complex z)
  fun gsl_complex_sqrt: gsl_complex -> gsl_complex = 'gsl_complex_sqrt($a)';
// Function: gsl_complex gsl_complex_sqrt_real (double x)
  fun gsl_complex_sqrt_real: double -> gsl_complex = 'gsl_complex_sqrt_real($a)';
// Function: gsl_complex gsl_complex_pow (gsl_complex z, gsl_complex a)
  fun gsl_complex_pow: gsl_complex * gsl_complex -> gsl_complex = 'gsl_complex_pow($a)';
// Function: gsl_complex gsl_complex_pow_real (gsl_complex z, double x)
  fun gsl_complex_pow_real: gsl_complex * double -> gsl_complex = 'gsl_complex_pow_real($a)';
// Function: gsl_complex gsl_complex_exp (gsl_complex z)
  fun gsl_complex_exp: gsl_complex -> gsl_complex = 'gsl_complex_exp($a)';
// Function: gsl_complex gsl_complex_log (gsl_complex z)
  fun gsl_complex_log: gsl_complex -> gsl_complex = 'gsl_complex_log($a)';
// Function: gsl_complex gsl_complex_log10 (gsl_complex z)
  fun gsl_complex_log10: gsl_complex -> gsl_complex = 'gsl_complex_log10($a)';
// Function: gsl_complex gsl_complex_log_b (gsl_complex z, gsl_complex b)
  fun gsl_complex_log_b: gsl_complex * gsl_complex -> gsl_complex = 'gsl_complex_log_b($a)';
//*****
// 05.05.00 Complex-Trigonometric-Functions.
// Function: gsl_complex gsl_complex_sin (gsl_complex z)
  fun gsl_complex_sin: gsl_complex -> gsl_complex = 'gsl_complex_sin($a)';
// Function: gsl_complex gsl_complex_cos (gsl_complex z)
  fun gsl_complex_cos: gsl_complex -> gsl_complex = 'gsl_complex_cos($a)';
// Function: gsl_complex gsl_complex_tan (gsl_complex z)
  fun gsl_complex_tan: gsl_complex -> gsl_complex = 'gsl_complex_tan($a)';
// Function: gsl_complex gsl_complex_sec (gsl_complex z)
  fun gsl_complex_sec: gsl_complex -> gsl_complex = 'gsl_complex_sec($a)';
// Function: gsl_complex gsl_complex_csc (gsl_complex z)
  fun gsl_complex_csc: gsl_complex -> gsl_complex = 'gsl_complex_csc($a)';
// Function: gsl_complex gsl_complex_cot (gsl_complex z)
  fun gsl_complex_cot: gsl_complex -> gsl_complex = 'gsl_complex_cot($a)';
//*****
// 05.06.00 Inverse-Complex-Trigonometric-Functions.
// Function: gsl_complex gsl_complex_arcsin (gsl_complex z)
  fun gsl_complex_arcsin: gsl_complex -> gsl_complex = 'gsl_complex_arcsin($a)';
// Function: gsl_complex gsl_complex_arcsin_real (double z)
  fun gsl_complex_arcsin_real: double -> gsl_complex = 'gsl_complex_arcsin_real($a)';
// Function: gsl_complex gsl_complex_arccos (gsl_complex z)
  fun gsl_complex_arccos: gsl_complex -> gsl_complex = 'gsl_complex_arccos($a)';
// Function: gsl_complex gsl_complex_arccos_real (double z)
  fun gsl_complex_arccos_real: double -> gsl_complex = 'gsl_complex_arccos_real($a)';
// Function: gsl_complex gsl_complex_arctan (gsl_complex z)
  fun gsl_complex_arctan: gsl_complex -> gsl_complex = 'gsl_complex_arctan($a)';
// Function: gsl_complex gsl_complex_arcsec (gsl_complex z)
  fun gsl_complex_arcsec: gsl_complex -> gsl_complex = 'gsl_complex_arcsec($a)';
// Function: gsl_complex gsl_complex_arcsec_real (double z)
  fun gsl_complex_arcsec_real: double -> gsl_complex = 'gsl_complex_arcsec_real($a)';
// Function: gsl_complex gsl_complex_arccsc (gsl_complex z)
  fun gsl_complex_arccsc: gsl_complex -> gsl_complex = 'gsl_complex_arccsc($a)';
// Function: gsl_complex gsl_complex_arccsc_real (double z)
  fun gsl_complex_arccsc_real: double -> gsl_complex = 'gsl_complex_arccsc_real($a)';
// Function: gsl_complex gsl_complex_arccot (gsl_complex z)
  fun gsl_complex_arccot: gsl_complex -> gsl_complex = 'gsl_complex_arccot($a)';
//*****
// 05.07.00 Complex-Hyperbolic-Functions.
// Function: gsl_complex gsl_complex_sinh (gsl_complex z)
  fun gsl_complex_sinh: gsl_complex -> gsl_complex = 'gsl_complex_sinh($a)';
// Function: gsl_complex gsl_complex_cosh (gsl_complex z)
  fun gsl_complex_cosh: gsl_complex -> gsl_complex = 'gsl_complex_cosh($a)';
// Function: gsl_complex gsl_complex_tanh (gsl_complex z)
  fun gsl_complex_tanh: gsl_complex -> gsl_complex = 'gsl_complex_tanh($a)';
// Function: gsl_complex gsl_complex_sech (gsl_complex z)
  fun gsl_complex_sech: gsl_complex -> gsl_complex = 'gsl_complex_sech($a)';
// Function: gsl_complex gsl_complex_csch (gsl_complex z)
  fun gsl_complex_csch: gsl_complex -> gsl_complex = 'gsl_complex_csch($a)';
// Function: gsl_complex gsl_complex_coth (gsl_complex z)
  fun gsl_complex_coth: gsl_complex -> gsl_complex = 'gsl_complex_coth($a)';
//*****
// 05.08.00 Inverse-Complex-Hyperbolic-Functions.
// Function: gsl_complex gsl_complex_arcsinh (gsl_complex z)
  fun gsl_complex_arcsinh: gsl_complex -> gsl_complex = 'gsl_complex_arcsinh($a)';
// Function: gsl_complex gsl_complex_arccosh (gsl_complex z)
  fun gsl_complex_arccosh: gsl_complex -> gsl_complex = 'gsl_complex_arccosh($a)';
// Function: gsl_complex gsl_complex_arccosh_real (double z)
  fun gsl_complex_arccosh_real: double -> gsl_complex = 'gsl_complex_arccosh_real($a)';
// Function: gsl_complex gsl_complex_arctanh (gsl_complex z)
  fun gsl_complex_arctanh: gsl_complex -> gsl_complex = 'gsl_complex_arctanh($a)';
// Function: gsl_complex gsl_complex_arctanh_real (double z)
  fun gsl_complex_arctanh_real: double -> gsl_complex = 'gsl_complex_arctanh_real($a)';
// Function: gsl_complex gsl_complex_arcsech (gsl_complex z)
  fun gsl_complex_arcsech: gsl_complex -> gsl_complex = 'gsl_complex_arcsech($a)';
// Function: gsl_complex gsl_complex_arccsch (gsl_complex z)
  fun gsl_complex_arccsch: gsl_complex -> gsl_complex = 'gsl_complex_arccsch($a)';
// Function: gsl_complex gsl_complex_arccoth (gsl_complex z)
  fun gsl_complex_arccoth: gsl_complex -> gsl_complex = 'gsl_complex_arccoth($a)';
//*****
// 06.01.00 Polynomial-Evaluation.
// Function: double gsl_poly_eval (const double c[], const int len, const double x)
  fun gsl_poly_eval: +double * int * double -> double = 'gsl_poly_eval($a)';
// Function: gsl_complex gsl_poly_complex_eval (const double c[], const int len, const gsl_complex z)
  fun gsl_poly_complex_eval: +double * int * gsl_complex -> gsl_complex = 'gsl_poly_complex_eval($a)';
// Function: gsl_complex gsl_complex_poly_complex_eval (const gsl_complex c[], const int len, const gsl_complex z)
  fun gsl_complex_poly_complex_eval: +gsl_complex * int * gsl_complex -> gsl_complex = 'gsl_complex_poly_complex_eval($a)';
// Function: int gsl_poly_eval_derivs (const double c[], const size_t lenc, const double x, double res[], const size_t lenres)
  fun gsl_poly_eval_derivs: +double * size * double * +double * size -> int = 'gsl_poly_eval_derivs($a)';
//*****
// 06.02.00 Divided-Difference-Representation-of-Polynomials.
// Function: int gsl_poly_dd_init (double dd[], const double xa[], const double ya[], size_t size)
  fun gsl_poly_dd_init: +double * +double * +double * size -> int = 'gsl_poly_dd_init($a)';
// Function: double gsl_poly_dd_eval (const double dd[], const double xa[], const size_t size, const double x)
  fun gsl_poly_dd_eval: +double * +double * size * double -> double = 'gsl_poly_dd_eval($a)';
// Function: int gsl_poly_dd_taylor (double c[], double xp, const double dd[], const double xa[], size_t size, double w[])
  fun gsl_poly_dd_taylor: +double * double * +double * +double * size * +double -> int = 'gsl_poly_dd_taylor($a)';
// Function: int gsl_poly_dd_hermite_init (double dd[], double za[], const double xa[], const double ya[], const double dya[], const size_t size)
  fun gsl_poly_dd_hermite_init: +double * +double * +double * +double * +double * size -> int = 'gsl_poly_dd_hermite_init($a)';
//*****
// 06.03.00 Quadratic-Equations.
// Function: int gsl_poly_solve_quadratic (double a, double b, double c, double * x0, double * x1)
  fun gsl_poly_solve_quadratic: double * double * double * &double * &double -> int = 'gsl_poly_solve_quadratic($a)';
// Function: int gsl_poly_complex_solve_quadratic (double a, double b, double c, gsl_complex * z0, gsl_complex * z1)
  fun gsl_poly_complex_solve_quadratic: double * double * double * &gsl_complex * &gsl_complex -> int = 'gsl_poly_complex_solve_quadratic($a)';
//*****
// 06.04.00 Cubic-Equations.
// Function: int gsl_poly_solve_cubic (double a, double b, double c, double * x0, double * x1, double * x2)
  fun gsl_poly_solve_cubic: double * double * double * &double * &double * &double -> int = 'gsl_poly_solve_cubic($a)';
// Function: int gsl_poly_complex_solve_cubic (double a, double b, double c, gsl_complex * z0, gsl_complex * z1, gsl_complex * z2)
  fun gsl_poly_complex_solve_cubic: double * double * double * &gsl_complex * &gsl_complex * &gsl_complex -> int = 'gsl_poly_complex_solve_cubic($a)';
//*****
// 06.05.00 General-Polynomial-Equations.
// Function: gsl_poly_complex_workspace * gsl_poly_complex_workspace_alloc (size_t n)
  fun gsl_poly_complex_workspace_alloc: size -> &gsl_poly_complex_workspace = 'gsl_poly_complex_workspace_alloc($a)';
// Function: void gsl_poly_complex_workspace_free (gsl_poly_complex_workspace * w)
  proc gsl_poly_complex_workspace_free: &gsl_poly_complex_workspace = 'gsl_poly_complex_workspace_free($a);';
// Function: int gsl_poly_complex_solve (const double * a, size_t n, gsl_poly_complex_workspace * w, gsl_complex_packed_ptr z)
  fun gsl_poly_complex_solve: &double * size * &gsl_poly_complex_workspace * gsl_complex_packed_ptr -> int = 'gsl_poly_complex_solve($a)';
//*****
// 07.02.00 The-gsl_sf_result-struct.
//*****
// 07.03.00 Special-Function-Modes.
//*****
// 07.04.00 Airy-Functions-and-Derivatives.
//*****
// 07.04.02 Derivatives-of-Airy-Functions.
// Function: double gsl_sf_airy_Ai_deriv (double x, gsl_mode_t mode)
  fun gsl_sf_airy_Ai_deriv: double * gsl_mode_t -> double = 'gsl_sf_airy_Ai_deriv($a)';
// Function: int gsl_sf_airy_Ai_deriv_e (double x, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_airy_Ai_deriv_e: double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_airy_Ai_deriv_e($a)';
// Function: double gsl_sf_airy_Bi_deriv (double x, gsl_mode_t mode)
  fun gsl_sf_airy_Bi_deriv: double * gsl_mode_t -> double = 'gsl_sf_airy_Bi_deriv($a)';
// Function: int gsl_sf_airy_Bi_deriv_e (double x, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_airy_Bi_deriv_e: double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_airy_Bi_deriv_e($a)';
// Function: double gsl_sf_airy_Ai_deriv_scaled (double x, gsl_mode_t mode)
  fun gsl_sf_airy_Ai_deriv_scaled: double * gsl_mode_t -> double = 'gsl_sf_airy_Ai_deriv_scaled($a)';
// Function: int gsl_sf_airy_Ai_deriv_scaled_e (double x, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_airy_Ai_deriv_scaled_e: double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_airy_Ai_deriv_scaled_e($a)';
// Function: double gsl_sf_airy_Bi_deriv_scaled (double x, gsl_mode_t mode)
  fun gsl_sf_airy_Bi_deriv_scaled: double * gsl_mode_t -> double = 'gsl_sf_airy_Bi_deriv_scaled($a)';
// Function: int gsl_sf_airy_Bi_deriv_scaled_e (double x, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_airy_Bi_deriv_scaled_e: double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_airy_Bi_deriv_scaled_e($a)';
//*****
// 07.04.03 Zeros-of-Airy-Functions.
// Function: double gsl_sf_airy_zero_Ai (unsigned int s)
  fun gsl_sf_airy_zero_Ai: uint -> double = 'gsl_sf_airy_zero_Ai($a)';
// Function: int gsl_sf_airy_zero_Ai_e (unsigned int s, gsl_sf_result * result)
  fun gsl_sf_airy_zero_Ai_e: uint * &gsl_sf_result -> int = 'gsl_sf_airy_zero_Ai_e($a)';
// Function: double gsl_sf_airy_zero_Bi (unsigned int s)
  fun gsl_sf_airy_zero_Bi: uint -> double = 'gsl_sf_airy_zero_Bi($a)';
// Function: int gsl_sf_airy_zero_Bi_e (unsigned int s, gsl_sf_result * result)
  fun gsl_sf_airy_zero_Bi_e: uint * &gsl_sf_result -> int = 'gsl_sf_airy_zero_Bi_e($a)';
//*****
// 07.04.03 Zeros-of-Derivatives-of-Airy-Functions.
// Function: double gsl_sf_airy_zero_Ai (unsigned int s)
  fun gsl_sf_airy_zero_Ai: uint -> double = 'gsl_sf_airy_zero_Ai($a)';
// Function: int gsl_sf_airy_zero_Ai_e (unsigned int s, gsl_sf_result * result)
  fun gsl_sf_airy_zero_Ai_e: uint * &gsl_sf_result -> int = 'gsl_sf_airy_zero_Ai_e($a)';
// Function: double gsl_sf_airy_zero_Bi (unsigned int s)
  fun gsl_sf_airy_zero_Bi: uint -> double = 'gsl_sf_airy_zero_Bi($a)';
// Function: int gsl_sf_airy_zero_Bi_e (unsigned int s, gsl_sf_result * result)
  fun gsl_sf_airy_zero_Bi_e: uint * &gsl_sf_result -> int = 'gsl_sf_airy_zero_Bi_e($a)';
//*****
// 07.05.00 Bessel-Functions.
//*****
// 07.05.01 Regular-Cylindrical-Bessel-Functions.
// Function: double gsl_sf_bessel_J0 (double x)
  fun gsl_sf_bessel_J0: double -> double = 'gsl_sf_bessel_J0($a)';
// Function: int gsl_sf_bessel_J0_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_J0_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_J0_e($a)';
// Function: double gsl_sf_bessel_J1 (double x)
  fun gsl_sf_bessel_J1: double -> double = 'gsl_sf_bessel_J1($a)';
// Function: int gsl_sf_bessel_J1_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_J1_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_J1_e($a)';
// Function: double gsl_sf_bessel_Jn (int n, double x)
  fun gsl_sf_bessel_Jn: int * double -> double = 'gsl_sf_bessel_Jn($a)';
// Function: int gsl_sf_bessel_Jn_e (int n, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Jn_e: int * double * &gsl_sf_result -> int = 'gsl_sf_bessel_Jn_e($a)';
// Function: int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x, double result_array[])
  fun gsl_sf_bessel_Jn_array: int * int * double * +double -> int = 'gsl_sf_bessel_Jn_array($a)';
//*****
// 07.05.02 Irregular-Cylindrical-Bessel-Functions.
// Function: double gsl_sf_bessel_Y0 (double x)
  fun gsl_sf_bessel_Y0: double -> double = 'gsl_sf_bessel_Y0($a)';
// Function: int gsl_sf_bessel_Y0_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Y0_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_Y0_e($a)';
// Function: double gsl_sf_bessel_Y1 (double x)
  fun gsl_sf_bessel_Y1: double -> double = 'gsl_sf_bessel_Y1($a)';
// Function: int gsl_sf_bessel_Y1_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Y1_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_Y1_e($a)';
// Function: double gsl_sf_bessel_Yn (int n, double x)
  fun gsl_sf_bessel_Yn: int * double -> double = 'gsl_sf_bessel_Yn($a)';
// Function: int gsl_sf_bessel_Yn_e (int n, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Yn_e: int * double * &gsl_sf_result -> int = 'gsl_sf_bessel_Yn_e($a)';
// Function: int gsl_sf_bessel_Yn_array (int nmin, int nmax, double x, double result_array[])
  fun gsl_sf_bessel_Yn_array: int * int * double * +double -> int = 'gsl_sf_bessel_Yn_array($a)';
//*****
// 07.05.03 Regular-Modified-Cylindrical-Bessel-Functions.
// Function: double gsl_sf_bessel_I0 (double x)
  fun gsl_sf_bessel_I0: double -> double = 'gsl_sf_bessel_I0($a)';
// Function: int gsl_sf_bessel_I0_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_I0_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_I0_e($a)';
// Function: double gsl_sf_bessel_I1 (double x)
  fun gsl_sf_bessel_I1: double -> double = 'gsl_sf_bessel_I1($a)';
// Function: int gsl_sf_bessel_I1_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_I1_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_I1_e($a)';
// Function: double gsl_sf_bessel_In (int n, double x)
  fun gsl_sf_bessel_In: int * double -> double = 'gsl_sf_bessel_In($a)';
// Function: int gsl_sf_bessel_In_e (int n, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_In_e: int * double * &gsl_sf_result -> int = 'gsl_sf_bessel_In_e($a)';
// Function: int gsl_sf_bessel_In_array (int nmin, int nmax, double x, double result_array[])
  fun gsl_sf_bessel_In_array: int * int * double * +double -> int = 'gsl_sf_bessel_In_array($a)';
// Function: double gsl_sf_bessel_I0_scaled (double x)
  fun gsl_sf_bessel_I0_scaled: double -> double = 'gsl_sf_bessel_I0_scaled($a)';
// Function: int gsl_sf_bessel_I0_scaled_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_I0_scaled_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_I0_scaled_e($a)';
// Function: double gsl_sf_bessel_I1_scaled (double x)
  fun gsl_sf_bessel_I1_scaled: double -> double = 'gsl_sf_bessel_I1_scaled($a)';
// Function: int gsl_sf_bessel_I1_scaled_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_I1_scaled_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_I1_scaled_e($a)';
// Function: double gsl_sf_bessel_In_scaled (int n, double x)
  fun gsl_sf_bessel_In_scaled: int * double -> double = 'gsl_sf_bessel_In_scaled($a)';
// Function: int gsl_sf_bessel_In_scaled_e (int n, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_In_scaled_e: int * double * &gsl_sf_result -> int = 'gsl_sf_bessel_In_scaled_e($a)';
// Function: int gsl_sf_bessel_In_scaled_array (int nmin, int nmax, double x, double result_array[])
  fun gsl_sf_bessel_In_scaled_array: int * int * double * +double -> int = 'gsl_sf_bessel_In_scaled_array($a)';
//*****
// 07.05.04 Irregular-Modified-Cylindrical-Bessel-Functions.
// Function: double gsl_sf_bessel_K0 (double x)
  fun gsl_sf_bessel_K0: double -> double = 'gsl_sf_bessel_K0($a)';
// Function: int gsl_sf_bessel_K0_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_K0_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_K0_e($a)';
// Function: double gsl_sf_bessel_K1 (double x)
  fun gsl_sf_bessel_K1: double -> double = 'gsl_sf_bessel_K1($a)';
// Function: int gsl_sf_bessel_K1_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_K1_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_K1_e($a)';
// Function: double gsl_sf_bessel_Kn (int n, double x)
  fun gsl_sf_bessel_Kn: int * double -> double = 'gsl_sf_bessel_Kn($a)';
// Function: int gsl_sf_bessel_Kn_e (int n, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Kn_e: int * double * &gsl_sf_result -> int = 'gsl_sf_bessel_Kn_e($a)';
// Function: int gsl_sf_bessel_Kn_array (int nmin, int nmax, double x, double result_array[])
  fun gsl_sf_bessel_Kn_array: int * int * double * +double -> int = 'gsl_sf_bessel_Kn_array($a)';
// Function: double gsl_sf_bessel_K0_scaled (double x)
  fun gsl_sf_bessel_K0_scaled: double -> double = 'gsl_sf_bessel_K0_scaled($a)';
// Function: int gsl_sf_bessel_K0_scaled_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_K0_scaled_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_K0_scaled_e($a)';
// Function: double gsl_sf_bessel_K1_scaled (double x)
  fun gsl_sf_bessel_K1_scaled: double -> double = 'gsl_sf_bessel_K1_scaled($a)';
// Function: int gsl_sf_bessel_K1_scaled_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_K1_scaled_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_K1_scaled_e($a)';
// Function: double gsl_sf_bessel_Kn_scaled (int n, double x)
  fun gsl_sf_bessel_Kn_scaled: int * double -> double = 'gsl_sf_bessel_Kn_scaled($a)';
// Function: int gsl_sf_bessel_Kn_scaled_e (int n, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Kn_scaled_e: int * double * &gsl_sf_result -> int = 'gsl_sf_bessel_Kn_scaled_e($a)';
// Function: int gsl_sf_bessel_Kn_scaled_array (int nmin, int nmax, double x, double result_array[])
  fun gsl_sf_bessel_Kn_scaled_array: int * int * double * +double -> int = 'gsl_sf_bessel_Kn_scaled_array($a)';
//*****
// 07.05.05 Regular-Spherical-Bessel-Functions.
// Function: double gsl_sf_bessel_j0 (double x)
  fun gsl_sf_bessel_j0: double -> double = 'gsl_sf_bessel_j0($a)';
// Function: int gsl_sf_bessel_j0_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_j0_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_j0_e($a)';
// Function: double gsl_sf_bessel_j1 (double x)
  fun gsl_sf_bessel_j1: double -> double = 'gsl_sf_bessel_j1($a)';
// Function: int gsl_sf_bessel_j1_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_j1_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_j1_e($a)';
// Function: double gsl_sf_bessel_j2 (double x)
  fun gsl_sf_bessel_j2: double -> double = 'gsl_sf_bessel_j2($a)';
// Function: int gsl_sf_bessel_j2_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_j2_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_j2_e($a)';
// Function: double gsl_sf_bessel_jl (int l, double x)
  fun gsl_sf_bessel_jl: int * double -> double = 'gsl_sf_bessel_jl($a)';
// Function: int gsl_sf_bessel_jl_e (int l, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_jl_e: int * double * &gsl_sf_result -> int = 'gsl_sf_bessel_jl_e($a)';
// Function: int gsl_sf_bessel_jl_array (int lmax, double x, double result_array[])
  fun gsl_sf_bessel_jl_array: int * double * +double -> int = 'gsl_sf_bessel_jl_array($a)';
// Function: int gsl_sf_bessel_jl_steed_array (int lmax, double x, double * result_array)
  fun gsl_sf_bessel_jl_steed_array: int * double * &double -> int = 'gsl_sf_bessel_jl_steed_array($a)';
//*****
// 07.05.06 Irregular-Spherical-Bessel-Functions.
// Function: double gsl_sf_bessel_y0 (double x)
  fun gsl_sf_bessel_y0: double -> double = 'gsl_sf_bessel_y0($a)';
// Function: int gsl_sf_bessel_y0_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_y0_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_y0_e($a)';
// Function: double gsl_sf_bessel_y1 (double x)
  fun gsl_sf_bessel_y1: double -> double = 'gsl_sf_bessel_y1($a)';
// Function: int gsl_sf_bessel_y1_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_y1_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_y1_e($a)';
// Function: double gsl_sf_bessel_y2 (double x)
  fun gsl_sf_bessel_y2: double -> double = 'gsl_sf_bessel_y2($a)';
// Function: int gsl_sf_bessel_y2_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_y2_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_y2_e($a)';
// Function: double gsl_sf_bessel_yl (int l, double x)
  fun gsl_sf_bessel_yl: int * double -> double = 'gsl_sf_bessel_yl($a)';
// Function: int gsl_sf_bessel_yl_e (int l, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_yl_e: int * double * &gsl_sf_result -> int = 'gsl_sf_bessel_yl_e($a)';
// Function: int gsl_sf_bessel_yl_array (int lmax, double x, double result_array[])
  fun gsl_sf_bessel_yl_array: int * double * +double -> int = 'gsl_sf_bessel_yl_array($a)';
//*****
// 07.05.07 Regular-Modified-Spherical-Bessel-Functions.
// Function: double gsl_sf_bessel_i0_scaled (double x)
  fun gsl_sf_bessel_i0_scaled: double -> double = 'gsl_sf_bessel_i0_scaled($a)';
// Function: int gsl_sf_bessel_i0_scaled_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_i0_scaled_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_i0_scaled_e($a)';
// Function: double gsl_sf_bessel_i1_scaled (double x)
  fun gsl_sf_bessel_i1_scaled: double -> double = 'gsl_sf_bessel_i1_scaled($a)';
// Function: int gsl_sf_bessel_i1_scaled_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_i1_scaled_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_i1_scaled_e($a)';
// Function: double gsl_sf_bessel_i2_scaled (double x)
  fun gsl_sf_bessel_i2_scaled: double -> double = 'gsl_sf_bessel_i2_scaled($a)';
// Function: int gsl_sf_bessel_i2_scaled_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_i2_scaled_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_i2_scaled_e($a)';
// Function: double gsl_sf_bessel_il_scaled (int l, double x)
  fun gsl_sf_bessel_il_scaled: int * double -> double = 'gsl_sf_bessel_il_scaled($a)';
// Function: int gsl_sf_bessel_il_scaled_e (int l, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_il_scaled_e: int * double * &gsl_sf_result -> int = 'gsl_sf_bessel_il_scaled_e($a)';
// Function: int gsl_sf_bessel_il_scaled_array (int lmax, double x, double result_array[])
  fun gsl_sf_bessel_il_scaled_array: int * double * +double -> int = 'gsl_sf_bessel_il_scaled_array($a)';
//*****
// 07.05.08 Irregular-Modified-Spherical-Bessel-Functions.
// Function: double gsl_sf_bessel_k0_scaled (double x)
  fun gsl_sf_bessel_k0_scaled: double -> double = 'gsl_sf_bessel_k0_scaled($a)';
// Function: int gsl_sf_bessel_k0_scaled_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_k0_scaled_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_k0_scaled_e($a)';
// Function: double gsl_sf_bessel_k1_scaled (double x)
  fun gsl_sf_bessel_k1_scaled: double -> double = 'gsl_sf_bessel_k1_scaled($a)';
// Function: int gsl_sf_bessel_k1_scaled_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_k1_scaled_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_k1_scaled_e($a)';
// Function: double gsl_sf_bessel_k2_scaled (double x)
  fun gsl_sf_bessel_k2_scaled: double -> double = 'gsl_sf_bessel_k2_scaled($a)';
// Function: int gsl_sf_bessel_k2_scaled_e (double x, gsl_sf_result * result)
  fun gsl_sf_bessel_k2_scaled_e: double * &gsl_sf_result -> int = 'gsl_sf_bessel_k2_scaled_e($a)';
// Function: double gsl_sf_bessel_kl_scaled (int l, double x)
  fun gsl_sf_bessel_kl_scaled: int * double -> double = 'gsl_sf_bessel_kl_scaled($a)';
// Function: int gsl_sf_bessel_kl_scaled_e (int l, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_kl_scaled_e: int * double * &gsl_sf_result -> int = 'gsl_sf_bessel_kl_scaled_e($a)';
// Function: int gsl_sf_bessel_kl_scaled_array (int lmax, double x, double result_array[])
  fun gsl_sf_bessel_kl_scaled_array: int * double * +double -> int = 'gsl_sf_bessel_kl_scaled_array($a)';
//*****
// 07.05.09 Regular-Bessel-Function-Fractional-Order.
// Function: double gsl_sf_bessel_Jnu (double nu, double x)
  fun gsl_sf_bessel_Jnu: double * double -> double = 'gsl_sf_bessel_Jnu($a)';
// Function: int gsl_sf_bessel_Jnu_e (double nu, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Jnu_e: double * double * &gsl_sf_result -> int = 'gsl_sf_bessel_Jnu_e($a)';
// Function: int gsl_sf_bessel_sequence_Jnu_e (double nu, gsl_mode_t mode, size_t size, double v[])
  fun gsl_sf_bessel_sequence_Jnu_e: double * gsl_mode_t * size * +double -> int = 'gsl_sf_bessel_sequence_Jnu_e($a)';
//*****
// 07.05.10 Irregular-Bessel-Functions-Fractional-Order.
// Function: double gsl_sf_bessel_Ynu (double nu, double x)
  fun gsl_sf_bessel_Ynu: double * double -> double = 'gsl_sf_bessel_Ynu($a)';
// Function: int gsl_sf_bessel_Ynu_e (double nu, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Ynu_e: double * double * &gsl_sf_result -> int = 'gsl_sf_bessel_Ynu_e($a)';
//*****
// 07.05.11 Regular-Modified-Bessel-Functions-Fractional-Order.
// Function: double gsl_sf_bessel_Inu (double nu, double x)
  fun gsl_sf_bessel_Inu: double * double -> double = 'gsl_sf_bessel_Inu($a)';
// Function: int gsl_sf_bessel_Inu_e (double nu, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Inu_e: double * double * &gsl_sf_result -> int = 'gsl_sf_bessel_Inu_e($a)';
// Function: double gsl_sf_bessel_Inu_scaled (double nu, double x)
  fun gsl_sf_bessel_Inu_scaled: double * double -> double = 'gsl_sf_bessel_Inu_scaled($a)';
// Function: int gsl_sf_bessel_Inu_scaled_e (double nu, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Inu_scaled_e: double * double * &gsl_sf_result -> int = 'gsl_sf_bessel_Inu_scaled_e($a)';
//*****
// 07.05.12 Irregular-Modified-Bessel-Functions-Fractional-Order.
// Function: double gsl_sf_bessel_Knu (double nu, double x)
  fun gsl_sf_bessel_Knu: double * double -> double = 'gsl_sf_bessel_Knu($a)';
// Function: int gsl_sf_bessel_Knu_e (double nu, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Knu_e: double * double * &gsl_sf_result -> int = 'gsl_sf_bessel_Knu_e($a)';
// Function: double gsl_sf_bessel_lnKnu (double nu, double x)
  fun gsl_sf_bessel_lnKnu: double * double -> double = 'gsl_sf_bessel_lnKnu($a)';
// Function: int gsl_sf_bessel_lnKnu_e (double nu, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_lnKnu_e: double * double * &gsl_sf_result -> int = 'gsl_sf_bessel_lnKnu_e($a)';
// Function: double gsl_sf_bessel_Knu_scaled (double nu, double x)
  fun gsl_sf_bessel_Knu_scaled: double * double -> double = 'gsl_sf_bessel_Knu_scaled($a)';
// Function: int gsl_sf_bessel_Knu_scaled_e (double nu, double x, gsl_sf_result * result)
  fun gsl_sf_bessel_Knu_scaled_e: double * double * &gsl_sf_result -> int = 'gsl_sf_bessel_Knu_scaled_e($a)';
//*****
// 07.05.13 Zeros-of-Resular-Bessel-Functions.
// Function: double gsl_sf_bessel_zero_J0 (unsigned int s)
  fun gsl_sf_bessel_zero_J0: uint -> double = 'gsl_sf_bessel_zero_J0($a)';
// Function: int gsl_sf_bessel_zero_J0_e (unsigned int s, gsl_sf_result * result)
  fun gsl_sf_bessel_zero_J0_e: uint * &gsl_sf_result -> int = 'gsl_sf_bessel_zero_J0_e($a)';
// Function: double gsl_sf_bessel_zero_J1 (unsigned int s)
  fun gsl_sf_bessel_zero_J1: uint -> double = 'gsl_sf_bessel_zero_J1($a)';
// Function: int gsl_sf_bessel_zero_J1_e (unsigned int s, gsl_sf_result * result)
  fun gsl_sf_bessel_zero_J1_e: uint * &gsl_sf_result -> int = 'gsl_sf_bessel_zero_J1_e($a)';
// Function: double gsl_sf_bessel_zero_Jnu (double nu, unsigned int s)
  fun gsl_sf_bessel_zero_Jnu: double * uint -> double = 'gsl_sf_bessel_zero_Jnu($a)';
// Function: int gsl_sf_bessel_zero_Jnu_e (double nu, unsigned int s, gsl_sf_result * result)
  fun gsl_sf_bessel_zero_Jnu_e: double * uint * &gsl_sf_result -> int = 'gsl_sf_bessel_zero_Jnu_e($a)';
//*****
// 07.06.00 Clausen-Functions.
// Function: double gsl_sf_clausen (double x)
  fun gsl_sf_clausen: double -> double = 'gsl_sf_clausen($a)';
// Function: int gsl_sf_clausen_e (double x, gsl_sf_result * result)
  fun gsl_sf_clausen_e: double * &gsl_sf_result -> int = 'gsl_sf_clausen_e($a)';
//*****
// 07.06.00 Coulomb-Functions.
// Function: double gsl_sf_clausen (double x)
  fun gsl_sf_clausen: double -> double = 'gsl_sf_clausen($a)';
// Function: int gsl_sf_clausen_e (double x, gsl_sf_result * result)
  fun gsl_sf_clausen_e: double * &gsl_sf_result -> int = 'gsl_sf_clausen_e($a)';
//*****
// 07.07.01 Normalized-Hydrogenic-Bond-States.
// Function: double gsl_sf_hydrogenicR_1 (double Z, double r)
  fun gsl_sf_hydrogenicR_1: double * double -> double = 'gsl_sf_hydrogenicR_1($a)';
// Function: int gsl_sf_hydrogenicR_1_e (double Z, double r, gsl_sf_result * result)
  fun gsl_sf_hydrogenicR_1_e: double * double * &gsl_sf_result -> int = 'gsl_sf_hydrogenicR_1_e($a)';
// Function: double gsl_sf_hydrogenicR (int n, int l, double Z, double r)
  fun gsl_sf_hydrogenicR: int * int * double * double -> double = 'gsl_sf_hydrogenicR($a)';
// Function: int gsl_sf_hydrogenicR_e (int n, int l, double Z, double r, gsl_sf_result * result)
  fun gsl_sf_hydrogenicR_e: int * int * double * double * &gsl_sf_result -> int = 'gsl_sf_hydrogenicR_e($a)';
//*****
// 07.07.02 Coulomb-Wave-Functions.
// Function: int gsl_sf_coulomb_wave_FG_e (double eta, double x, double L_F, int k, gsl_sf_result * F, gsl_sf_result * Fp, gsl_sf_result * G, gsl_sf_result * Gp, double * exp_F, double * exp_G)
  fun gsl_sf_coulomb_wave_FG_e: double * double * double * int * &gsl_sf_result * &gsl_sf_result * &gsl_sf_result * &gsl_sf_result * &double * &double -> int = 'gsl_sf_coulomb_wave_FG_e($a)';
// Function: int gsl_sf_coulomb_wave_F_array (double L_min, int kmax, double eta, double x, double fc_array[], double * F_exponent)
  fun gsl_sf_coulomb_wave_F_array: double * int * double * double * +double * &double -> int = 'gsl_sf_coulomb_wave_F_array($a)';
// Function: int gsl_sf_coulomb_wave_FG_array (double L_min, int kmax, double eta, double x, double fc_array[], double gc_array[], double * F_exponent, double * G_exponent)
  fun gsl_sf_coulomb_wave_FG_array: double * int * double * double * +double * +double * &double * &double -> int = 'gsl_sf_coulomb_wave_FG_array($a)';
// Function: int gsl_sf_coulomb_wave_FGp_array (double L_min, int kmax, double eta, double x, double fc_array[], double fcp_array[], double gc_array[], double gcp_array[], double * F_exponent, double * G_exponent)
  fun gsl_sf_coulomb_wave_FGp_array: double * int * double * double * +double * +double * +double * +double * &double * &double -> int = 'gsl_sf_coulomb_wave_FGp_array($a)';
// Function: int gsl_sf_coulomb_wave_sphF_array (double L_min, int kmax, double eta, double x, double fc_array[], double F_exponent[])
  fun gsl_sf_coulomb_wave_sphF_array: double * int * double * double * +double * +double -> int = 'gsl_sf_coulomb_wave_sphF_array($a)';
//*****
// 07.07.03 Coulomb-Wave-Function-Normalization-Constant.
// Function: int gsl_sf_coulomb_CL_e (double L, double eta, gsl_sf_result * result)
  fun gsl_sf_coulomb_CL_e: double * double * &gsl_sf_result -> int = 'gsl_sf_coulomb_CL_e($a)';
// Function: int gsl_sf_coulomb_CL_array (double Lmin, int kmax, double eta, double cl[])
  fun gsl_sf_coulomb_CL_array: double * int * double * +double -> int = 'gsl_sf_coulomb_CL_array($a)';
//*****
// 07.08.00 Coupling-Coefficients.
//*****
// 07.08.01 3-j-Symbols.
// Function: double gsl_sf_coupling_3j (int two_ja, int two_jb, int two_jc, int two_ma, int two_mb, int two_mc)
  fun gsl_sf_coupling_3j: int * int * int * int * int * int -> double = 'gsl_sf_coupling_3j($a)';
// Function: int gsl_sf_coupling_3j_e (int two_ja, int two_jb, int two_jc, int two_ma, int two_mb, int two_mc, gsl_sf_result * result)
  fun gsl_sf_coupling_3j_e: int * int * int * int * int * int * &gsl_sf_result -> int = 'gsl_sf_coupling_3j_e($a)';
//*****
// 07.08.02 6-j-Symbols.
// Function: double gsl_sf_coupling_6j (int two_ja, int two_jb, int two_jc, int two_jd, int two_je, int two_jf)
  fun gsl_sf_coupling_6j: int * int * int * int * int * int -> double = 'gsl_sf_coupling_6j($a)';
// Function: int gsl_sf_coupling_6j_e (int two_ja, int two_jb, int two_jc, int two_jd, int two_je, int two_jf, gsl_sf_result * result)
  fun gsl_sf_coupling_6j_e: int * int * int * int * int * int * &gsl_sf_result -> int = 'gsl_sf_coupling_6j_e($a)';
//*****
// 07.08.03 9-j-Symbols.
// Function: double gsl_sf_coupling_9j (int two_ja, int two_jb, int two_jc, int two_jd, int two_je, int two_jf, int two_jg, int two_jh, int two_ji)
  fun gsl_sf_coupling_9j: int * int * int * int * int * int * int * int * int -> double = 'gsl_sf_coupling_9j($a)';
// Function: int gsl_sf_coupling_9j_e (int two_ja, int two_jb, int two_jc, int two_jd, int two_je, int two_jf, int two_jg, int two_jh, int two_ji, gsl_sf_result * result)
  fun gsl_sf_coupling_9j_e: int * int * int * int * int * int * int * int * int * &gsl_sf_result -> int = 'gsl_sf_coupling_9j_e($a)';
//*****
// 07.09.00 Dawson-Function.
// Function: double gsl_sf_dawson (double x)
  fun gsl_sf_dawson: double -> double = 'gsl_sf_dawson($a)';
// Function: int gsl_sf_dawson_e (double x, gsl_sf_result * result)
  fun gsl_sf_dawson_e: double * &gsl_sf_result -> int = 'gsl_sf_dawson_e($a)';
//*****
// 07.10.00 Debye-Functions.
// Function: double gsl_sf_debye_1 (double x)
  fun gsl_sf_debye_1: double -> double = 'gsl_sf_debye_1($a)';
// Function: int gsl_sf_debye_1_e (double x, gsl_sf_result * result)
  fun gsl_sf_debye_1_e: double * &gsl_sf_result -> int = 'gsl_sf_debye_1_e($a)';
// Function: double gsl_sf_debye_2 (double x)
  fun gsl_sf_debye_2: double -> double = 'gsl_sf_debye_2($a)';
// Function: int gsl_sf_debye_2_e (double x, gsl_sf_result * result)
  fun gsl_sf_debye_2_e: double * &gsl_sf_result -> int = 'gsl_sf_debye_2_e($a)';
// Function: double gsl_sf_debye_3 (double x)
  fun gsl_sf_debye_3: double -> double = 'gsl_sf_debye_3($a)';
// Function: int gsl_sf_debye_3_e (double x, gsl_sf_result * result)
  fun gsl_sf_debye_3_e: double * &gsl_sf_result -> int = 'gsl_sf_debye_3_e($a)';
// Function: double gsl_sf_debye_4 (double x)
  fun gsl_sf_debye_4: double -> double = 'gsl_sf_debye_4($a)';
// Function: int gsl_sf_debye_4_e (double x, gsl_sf_result * result)
  fun gsl_sf_debye_4_e: double * &gsl_sf_result -> int = 'gsl_sf_debye_4_e($a)';
// Function: double gsl_sf_debye_5 (double x)
  fun gsl_sf_debye_5: double -> double = 'gsl_sf_debye_5($a)';
// Function: int gsl_sf_debye_5_e (double x, gsl_sf_result * result)
  fun gsl_sf_debye_5_e: double * &gsl_sf_result -> int = 'gsl_sf_debye_5_e($a)';
// Function: double gsl_sf_debye_6 (double x)
  fun gsl_sf_debye_6: double -> double = 'gsl_sf_debye_6($a)';
// Function: int gsl_sf_debye_6_e (double x, gsl_sf_result * result)
  fun gsl_sf_debye_6_e: double * &gsl_sf_result -> int = 'gsl_sf_debye_6_e($a)';
//*****
// 07.11.00 Dilogarithm.
//*****
// 07.11.01 Real-Argument.
// Function: double gsl_sf_dilog (double x)
  fun gsl_sf_dilog: double -> double = 'gsl_sf_dilog($a)';
// Function: int gsl_sf_dilog_e (double x, gsl_sf_result * result)
  fun gsl_sf_dilog_e: double * &gsl_sf_result -> int = 'gsl_sf_dilog_e($a)';
//*****
// 07.11.02 Complex-Argument.
// Function: int gsl_sf_complex_dilog_e (double r, double theta, gsl_sf_result * result_re, gsl_sf_result * result_im)
  fun gsl_sf_complex_dilog_e: double * double * &gsl_sf_result * &gsl_sf_result -> int = 'gsl_sf_complex_dilog_e($a)';
//*****
// 07.12.00 Elementary-Operations.
// Function: int gsl_sf_multiply_e (double x, double y, gsl_sf_result * result)
  fun gsl_sf_multiply_e: double * double * &gsl_sf_result -> int = 'gsl_sf_multiply_e($a)';
// Function: int gsl_sf_multiply_err_e (double x, double dx, double y, double dy, gsl_sf_result * result)
  fun gsl_sf_multiply_err_e: double * double * double * double * &gsl_sf_result -> int = 'gsl_sf_multiply_err_e($a)';
//*****
// 07.13.00 Elliptic-Integrals.
//*****
// 07.13.01 Definition-of-Legedre-Forms.
//*****
// 07.13.02 Definition-of-Carlson-Forms.
//*****
// 07.13.03 Legendre-Form-of-Complete-Elliptic-Integrals.
// Function: double gsl_sf_ellint_Kcomp (double k, gsl_mode_t mode)
  fun gsl_sf_ellint_Kcomp: double * gsl_mode_t -> double = 'gsl_sf_ellint_Kcomp($a)';
// Function: int gsl_sf_ellint_Kcomp_e (double k, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_Kcomp_e: double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_Kcomp_e($a)';
// Function: double gsl_sf_ellint_Ecomp (double k, gsl_mode_t mode)
  fun gsl_sf_ellint_Ecomp: double * gsl_mode_t -> double = 'gsl_sf_ellint_Ecomp($a)';
// Function: int gsl_sf_ellint_Ecomp_e (double k, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_Ecomp_e: double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_Ecomp_e($a)';
// Function: double gsl_sf_ellint_Pcomp (double k, double n, gsl_mode_t mode)
  fun gsl_sf_ellint_Pcomp: double * double * gsl_mode_t -> double = 'gsl_sf_ellint_Pcomp($a)';
// Function: int gsl_sf_ellint_Pcomp_e (double k, double n, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_Pcomp_e: double * double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_Pcomp_e($a)';
//*****
// 07.13.04 Legendre-Form-of-Incomplete-Elliptic-Integrals.
// Function: double gsl_sf_ellint_F (double phi, double k, gsl_mode_t mode)
  fun gsl_sf_ellint_F: double * double * gsl_mode_t -> double = 'gsl_sf_ellint_F($a)';
// Function: int gsl_sf_ellint_F_e (double phi, double k, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_F_e: double * double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_F_e($a)';
// Function: double gsl_sf_ellint_E (double phi, double k, gsl_mode_t mode)
  fun gsl_sf_ellint_E: double * double * gsl_mode_t -> double = 'gsl_sf_ellint_E($a)';
// Function: int gsl_sf_ellint_E_e (double phi, double k, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_E_e: double * double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_E_e($a)';
// Function: double gsl_sf_ellint_P (double phi, double k, double n, gsl_mode_t mode)
  fun gsl_sf_ellint_P: double * double * double * gsl_mode_t -> double = 'gsl_sf_ellint_P($a)';
// Function: int gsl_sf_ellint_P_e (double phi, double k, double n, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_P_e: double * double * double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_P_e($a)';
// Function: double gsl_sf_ellint_D (double phi, double k, double n, gsl_mode_t mode)
  fun gsl_sf_ellint_D: double * double * double * gsl_mode_t -> double = 'gsl_sf_ellint_D($a)';
// Function: int gsl_sf_ellint_D_e (double phi, double k, double n, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_D_e: double * double * double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_D_e($a)';
//*****
// 07.13.05 Carlson-Forms.
// Function: double gsl_sf_ellint_RC (double x, double y, gsl_mode_t mode)
  fun gsl_sf_ellint_RC: double * double * gsl_mode_t -> double = 'gsl_sf_ellint_RC($a)';
// Function: int gsl_sf_ellint_RC_e (double x, double y, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_RC_e: double * double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_RC_e($a)';
// Function: double gsl_sf_ellint_RD (double x, double y, double z, gsl_mode_t mode)
  fun gsl_sf_ellint_RD: double * double * double * gsl_mode_t -> double = 'gsl_sf_ellint_RD($a)';
// Function: int gsl_sf_ellint_RD_e (double x, double y, double z, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_RD_e: double * double * double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_RD_e($a)';
// Function: double gsl_sf_ellint_RF (double x, double y, double z, gsl_mode_t mode)
  fun gsl_sf_ellint_RF: double * double * double * gsl_mode_t -> double = 'gsl_sf_ellint_RF($a)';
// Function: int gsl_sf_ellint_RF_e (double x, double y, double z, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_RF_e: double * double * double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_RF_e($a)';
// Function: double gsl_sf_ellint_RJ (double x, double y, double z, double p, gsl_mode_t mode)
  fun gsl_sf_ellint_RJ: double * double * double * double * gsl_mode_t -> double = 'gsl_sf_ellint_RJ($a)';
// Function: int gsl_sf_ellint_RJ_e (double x, double y, double z, double p, gsl_mode_t mode, gsl_sf_result * result)
  fun gsl_sf_ellint_RJ_e: double * double * double * double * gsl_mode_t * &gsl_sf_result -> int = 'gsl_sf_ellint_RJ_e($a)';
//*****
// 07.15.00 Error-Functions.
//*****
// 07.15.01 Error-Function.
// Function: double gsl_sf_erf (double x)
  fun gsl_sf_erf: double -> double = 'gsl_sf_erf($a)';
// Function: int gsl_sf_erf_e (double x, gsl_sf_result * result)
  fun gsl_sf_erf_e: double * &gsl_sf_result -> int = 'gsl_sf_erf_e($a)';
//*****
// 07.15.02 Complementary-Error-Function.
// Function: double gsl_sf_erfc (double x)
  fun gsl_sf_erfc: double -> double = 'gsl_sf_erfc($a)';
// Function: int gsl_sf_erfc_e (double x, gsl_sf_result * result)
  fun gsl_sf_erfc_e: double * &gsl_sf_result -> int = 'gsl_sf_erfc_e($a)';
//*****
// 07.15.03 Log-Complementary-Error-Function.
// Function: double gsl_sf_log_erfc (double x)
  fun gsl_sf_log_erfc: double -> double = 'gsl_sf_log_erfc($a)';
// Function: int gsl_sf_log_erfc_e (double x, gsl_sf_result * result)
  fun gsl_sf_log_erfc_e: double * &gsl_sf_result -> int = 'gsl_sf_log_erfc_e($a)';
//*****
// 07.15.04 Probability-Functions.
// Function: double gsl_sf_erf_Z (double x)
  fun gsl_sf_erf_Z: double -> double = 'gsl_sf_erf_Z($a)';
// Function: int gsl_sf_erf_Z_e (double x, gsl_sf_result * result)
  fun gsl_sf_erf_Z_e: double * &gsl_sf_result -> int = 'gsl_sf_erf_Z_e($a)';
// Function: double gsl_sf_erf_Q (double x)
  fun gsl_sf_erf_Q: double -> double = 'gsl_sf_erf_Q($a)';
// Function: int gsl_sf_erf_Q_e (double x, gsl_sf_result * result)
  fun gsl_sf_erf_Q_e: double * &gsl_sf_result -> int = 'gsl_sf_erf_Q_e($a)';
// Function: double gsl_sf_hazard (double x)
  fun gsl_sf_hazard: double -> double = 'gsl_sf_hazard($a)';
// Function: int gsl_sf_hazard_e (double x, gsl_sf_result * result)
  fun gsl_sf_hazard_e: double * &gsl_sf_result -> int = 'gsl_sf_hazard_e($a)';
//*****
// 07.16.00 Exponential-Functions.
//*****
// 07.16.01 Exponential-Function.
// Function: double gsl_sf_exp (double x)
  fun gsl_sf_exp: double -> double = 'gsl_sf_exp($a)';
// Function: int gsl_sf_exp_e (double x, gsl_sf_result * result)
  fun gsl_sf_exp_e: double * &gsl_sf_result -> int = 'gsl_sf_exp_e($a)';
// Function: int gsl_sf_exp_e10_e (double x, gsl_sf_result_e10 * result)
  fun gsl_sf_exp_e10_e: double * &gsl_sf_result_e10 -> int = 'gsl_sf_exp_e10_e($a)';
// Function: double gsl_sf_exp_mult (double x, double y)
  fun gsl_sf_exp_mult: double * double -> double = 'gsl_sf_exp_mult($a)';
// Function: int gsl_sf_exp_mult_e (double x, double y, gsl_sf_result * result)
  fun gsl_sf_exp_mult_e: double * double * &gsl_sf_result -> int = 'gsl_sf_exp_mult_e($a)';
// Function: int gsl_sf_exp_mult_e10_e (const double x, const double y, gsl_sf_result_e10 * result)
  fun gsl_sf_exp_mult_e10_e: double * double * &gsl_sf_result_e10 -> int = 'gsl_sf_exp_mult_e10_e($a)';
//*****
// 07.16.02 Relative-Exponential-Functions.
// Function: double gsl_sf_expm1 (double x)
  fun gsl_sf_expm1: double -> double = 'gsl_sf_expm1($a)';
// Function: int gsl_sf_expm1_e (double x, gsl_sf_result * result)
  fun gsl_sf_expm1_e: double * &gsl_sf_result -> int = 'gsl_sf_expm1_e($a)';
// Function: double gsl_sf_exprel (double x)
  fun gsl_sf_exprel: double -> double = 'gsl_sf_exprel($a)';
// Function: int gsl_sf_exprel_e (double x, gsl_sf_result * result)
  fun gsl_sf_exprel_e: double * &gsl_sf_result -> int = 'gsl_sf_exprel_e($a)';
// Function: double gsl_sf_exprel_2 (double x)
  fun gsl_sf_exprel_2: double -> double = 'gsl_sf_exprel_2($a)';
// Function: int gsl_sf_exprel_2_e (double x, gsl_sf_result * result)
  fun gsl_sf_exprel_2_e: double * &gsl_sf_result -> int = 'gsl_sf_exprel_2_e($a)';
// Function: double gsl_sf_exprel_n (int n, double x)
  fun gsl_sf_exprel_n: int * double -> double = 'gsl_sf_exprel_n($a)';
// Function: int gsl_sf_exprel_n_e (int n, double x, gsl_sf_result * result)
  fun gsl_sf_exprel_n_e: int * double * &gsl_sf_result -> int = 'gsl_sf_exprel_n_e($a)';
//*****
// 07.16.03 Exponentiation-With-Error-Estimate.
// Function: int gsl_sf_exp_err_e (double x, double dx, gsl_sf_result * result)
  fun gsl_sf_exp_err_e: double * double * &gsl_sf_result -> int = 'gsl_sf_exp_err_e($a)';
// Function: int gsl_sf_exp_err_e10_e (double x, double dx, gsl_sf_result_e10 * result)
  fun gsl_sf_exp_err_e10_e: double * double * &gsl_sf_result_e10 -> int = 'gsl_sf_exp_err_e10_e($a)';
// Function: int gsl_sf_exp_mult_err_e (double x, double dx, double y, double dy, gsl_sf_result * result)
  fun gsl_sf_exp_mult_err_e: double * double * double * double * &gsl_sf_result -> int = 'gsl_sf_exp_mult_err_e($a)';
// Function: int gsl_sf_exp_mult_err_e10_e (double x, double dx, double y, double dy, gsl_sf_result_e10 * result)
  fun gsl_sf_exp_mult_err_e10_e: double * double * double * double * &gsl_sf_result_e10 -> int = 'gsl_sf_exp_mult_err_e10_e($a)';
//*****
// 07.17.00 Exponential-Integrals.
//*****
// 07.17.01 Exponential-Integral.
// Function: double gsl_sf_expint_E1 (double x)
  fun gsl_sf_expint_E1: double -> double = 'gsl_sf_expint_E1($a)';
// Function: int gsl_sf_expint_E1_e (double x, gsl_sf_result * result)
  fun gsl_sf_expint_E1_e: double * &gsl_sf_result -> int = 'gsl_sf_expint_E1_e($a)';
// Function: double gsl_sf_expint_E2 (double x)
  fun gsl_sf_expint_E2: double -> double = 'gsl_sf_expint_E2($a)';
// Function: int gsl_sf_expint_E2_e (double x, gsl_sf_result * result)
  fun gsl_sf_expint_E2_e: double * &gsl_sf_result -> int = 'gsl_sf_expint_E2_e($a)';
// Function: double gsl_sf_expint_En (int n, double x)
  fun gsl_sf_expint_En: int * double -> double = 'gsl_sf_expint_En($a)';
// Function: int gsl_sf_expint_En_e (int n, double x, gsl_sf_result * result)
  fun gsl_sf_expint_En_e: int * double * &gsl_sf_result -> int = 'gsl_sf_expint_En_e($a)';
//*****
// 07.17.02 Ei(x).
// Function: double gsl_sf_expint_Ei (double x)
  fun gsl_sf_expint_Ei: double -> double = 'gsl_sf_expint_Ei($a)';
// Function: int gsl_sf_expint_Ei_e (double x, gsl_sf_result * result)
  fun gsl_sf_expint_Ei_e: double * &gsl_sf_result -> int = 'gsl_sf_expint_Ei_e($a)';
//*****
// 07.17.03 Hyperbolic-Integrals.
// Function: double gsl_sf_Shi (double x)
  fun gsl_sf_Shi: double -> double = 'gsl_sf_Shi($a)';
// Function: int gsl_sf_Shi_e (double x, gsl_sf_result * result)
  fun gsl_sf_Shi_e: double * &gsl_sf_result -> int = 'gsl_sf_Shi_e($a)';
// Function: double gsl_sf_Chi (double x)
  fun gsl_sf_Chi: double -> double = 'gsl_sf_Chi($a)';
// Function: int gsl_sf_Chi_e (double x, gsl_sf_result * result)
  fun gsl_sf_Chi_e: double * &gsl_sf_result -> int = 'gsl_sf_Chi_e($a)';
//*****
// 07.17.04 Ei_3(x).
// Function: double gsl_sf_expint_3 (double x)
  fun gsl_sf_expint_3: double -> double = 'gsl_sf_expint_3($a)';
// Function: int gsl_sf_expint_3_e (double x, gsl_sf_result * result)
  fun gsl_sf_expint_3_e: double * &gsl_sf_result -> int = 'gsl_sf_expint_3_e($a)';
//*****
// 07.17.05 Trigonometric-Integrals.
// Function: double gsl_sf_Si (const double x)
  fun gsl_sf_Si: double -> double = 'gsl_sf_Si($a)';
// Function: int gsl_sf_Si_e (double x, gsl_sf_result * result)
  fun gsl_sf_Si_e: double * &gsl_sf_result -> int = 'gsl_sf_Si_e($a)';
// Function: double gsl_sf_Ci (const double x)
  fun gsl_sf_Ci: double -> double = 'gsl_sf_Ci($a)';
// Function: int gsl_sf_Ci_e (double x, gsl_sf_result * result)
  fun gsl_sf_Ci_e: double * &gsl_sf_result -> int = 'gsl_sf_Ci_e($a)';
//*****
// 07.17.06 Arctangent-Integral.
// Function: double gsl_sf_atanint (double x)
  fun gsl_sf_atanint: double -> double = 'gsl_sf_atanint($a)';
// Function: int gsl_sf_atanint_e (double x, gsl_sf_result * result)
  fun gsl_sf_atanint_e: double * &gsl_sf_result -> int = 'gsl_sf_atanint_e($a)';
//*****
// 07.18.00 Fermi-Dirac-Function.
//*****
// 07.18.01 Complete-Fermi-Dirac-Integrals.
// Function: double gsl_sf_fermi_dirac_m1 (double x)
  fun gsl_sf_fermi_dirac_m1: double -> double = 'gsl_sf_fermi_dirac_m1($a)';
// Function: int gsl_sf_fermi_dirac_m1_e (double x, gsl_sf_result * result)
  fun gsl_sf_fermi_dirac_m1_e: double * &gsl_sf_result -> int = 'gsl_sf_fermi_dirac_m1_e($a)';
// Function: double gsl_sf_fermi_dirac_0 (double x)
  fun gsl_sf_fermi_dirac_0: double -> double = 'gsl_sf_fermi_dirac_0($a)';
// Function: int gsl_sf_fermi_dirac_0_e (double x, gsl_sf_result * result)
  fun gsl_sf_fermi_dirac_0_e: double * &gsl_sf_result -> int = 'gsl_sf_fermi_dirac_0_e($a)';
// Function: double gsl_sf_fermi_dirac_1 (double x)
  fun gsl_sf_fermi_dirac_1: double -> double = 'gsl_sf_fermi_dirac_1($a)';
// Function: int gsl_sf_fermi_dirac_1_e (double x, gsl_sf_result * result)
  fun gsl_sf_fermi_dirac_1_e: double * &gsl_sf_result -> int = 'gsl_sf_fermi_dirac_1_e($a)';
// Function: double gsl_sf_fermi_dirac_2 (double x)
  fun gsl_sf_fermi_dirac_2: double -> double = 'gsl_sf_fermi_dirac_2($a)';
// Function: int gsl_sf_fermi_dirac_2_e (double x, gsl_sf_result * result)
  fun gsl_sf_fermi_dirac_2_e: double * &gsl_sf_result -> int = 'gsl_sf_fermi_dirac_2_e($a)';
// Function: double gsl_sf_fermi_dirac_int (int j, double x)
  fun gsl_sf_fermi_dirac_int: int * double -> double = 'gsl_sf_fermi_dirac_int($a)';
// Function: int gsl_sf_fermi_dirac_int_e (int j, double x, gsl_sf_result * result)
  fun gsl_sf_fermi_dirac_int_e: int * double * &gsl_sf_result -> int = 'gsl_sf_fermi_dirac_int_e($a)';
// Function: double gsl_sf_fermi_dirac_mhalf (double x)
  fun gsl_sf_fermi_dirac_mhalf: double -> double = 'gsl_sf_fermi_dirac_mhalf($a)';
// Function: int gsl_sf_fermi_dirac_mhalf_e (double x, gsl_sf_result * result)
  fun gsl_sf_fermi_dirac_mhalf_e: double * &gsl_sf_result -> int = 'gsl_sf_fermi_dirac_mhalf_e($a)';
// Function: double gsl_sf_fermi_dirac_half (double x)
  fun gsl_sf_fermi_dirac_half: double -> double = 'gsl_sf_fermi_dirac_half($a)';
// Function: int gsl_sf_fermi_dirac_half_e (double x, gsl_sf_result * result)
  fun gsl_sf_fermi_dirac_half_e: double * &gsl_sf_result -> int = 'gsl_sf_fermi_dirac_half_e($a)';
// Function: double gsl_sf_fermi_dirac_3half (double x)
  fun gsl_sf_fermi_dirac_3half: double -> double = 'gsl_sf_fermi_dirac_3half($a)';
// Function: int gsl_sf_fermi_dirac_3half_e (double x, gsl_sf_result * result)
  fun gsl_sf_fermi_dirac_3half_e: double * &gsl_sf_result -> int = 'gsl_sf_fermi_dirac_3half_e($a)';
//*****
// 07.18.02 Incomplete-Fermi-Dirac-Integrals.
// Function: double gsl_sf_fermi_dirac_inc_0 (double x, double b)
  fun gsl_sf_fermi_dirac_inc_0: double * double -> double = 'gsl_sf_fermi_dirac_inc_0($a)';
// Function: int gsl_sf_fermi_dirac_inc_0_e (double x, double b, gsl_sf_result * result)
  fun gsl_sf_fermi_dirac_inc_0_e: double * double * &gsl_sf_result -> int = 'gsl_sf_fermi_dirac_inc_0_e($a)';
//*****
// 07.19.00 Gamma-and-Beta-Functions.
//*****
// 07.19.01 Gamma-Functions.
// Function: double gsl_sf_gamma (double x)
  fun gsl_sf_gamma: double -> double = 'gsl_sf_gamma($a)';
// Function: int gsl_sf_gamma_e (double x, gsl_sf_result * result)
  fun gsl_sf_gamma_e: double * &gsl_sf_result -> int = 'gsl_sf_gamma_e($a)';
// Function: double gsl_sf_lngamma (double x)
  fun gsl_sf_lngamma: double -> double = 'gsl_sf_lngamma($a)';
// Function: int gsl_sf_lngamma_e (double x, gsl_sf_result * result)
  fun gsl_sf_lngamma_e: double * &gsl_sf_result -> int = 'gsl_sf_lngamma_e($a)';
// Function: int gsl_sf_lngamma_sgn_e (double x, gsl_sf_result * result_lg, double * sgn)
  fun gsl_sf_lngamma_sgn_e: double * &gsl_sf_result * &double -> int = 'gsl_sf_lngamma_sgn_e($a)';
// Function: double gsl_sf_gammastar (double x)
  fun gsl_sf_gammastar: double -> double = 'gsl_sf_gammastar($a)';
// Function: int gsl_sf_gammastar_e (double x, gsl_sf_result * result)
  fun gsl_sf_gammastar_e: double * &gsl_sf_result -> int = 'gsl_sf_gammastar_e($a)';
// Function: double gsl_sf_gammainv (double x)
  fun gsl_sf_gammainv: double -> double = 'gsl_sf_gammainv($a)';
// Function: int gsl_sf_gammainv_e (double x, gsl_sf_result * result)
  fun gsl_sf_gammainv_e: double * &gsl_sf_result -> int = 'gsl_sf_gammainv_e($a)';
// Function: int gsl_sf_lngamma_complex_e (double zr, double zi, gsl_sf_result * lnr, gsl_sf_result * arg)
  fun gsl_sf_lngamma_complex_e: double * double * &gsl_sf_result * &gsl_sf_result -> int = 'gsl_sf_lngamma_complex_e($a)';
//*****
// 07.19.02 Factorials.
// Function: double gsl_sf_fact (unsigned int n)
  fun gsl_sf_fact: uint -> double = 'gsl_sf_fact($a)';
// Function: int gsl_sf_fact_e (unsigned int n, gsl_sf_result * result)
  fun gsl_sf_fact_e: uint * &gsl_sf_result -> int = 'gsl_sf_fact_e($a)';
// Function: double gsl_sf_doublefact (unsigned int n)
  fun gsl_sf_doublefact: uint -> double = 'gsl_sf_doublefact($a)';
// Function: int gsl_sf_doublefact_e (unsigned int n, gsl_sf_result * result)
  fun gsl_sf_doublefact_e: uint * &gsl_sf_result -> int = 'gsl_sf_doublefact_e($a)';
// Function: double gsl_sf_lnfact (unsigned int n)
  fun gsl_sf_lnfact: uint -> double = 'gsl_sf_lnfact($a)';
// Function: int gsl_sf_lnfact_e (unsigned int n, gsl_sf_result * result)
  fun gsl_sf_lnfact_e: uint * &gsl_sf_result -> int = 'gsl_sf_lnfact_e($a)';
// Function: double gsl_sf_lndoublefact (unsigned int n)
  fun gsl_sf_lndoublefact: uint -> double = 'gsl_sf_lndoublefact($a)';
// Function: int gsl_sf_lndoublefact_e (unsigned int n, gsl_sf_result * result)
  fun gsl_sf_lndoublefact_e: uint * &gsl_sf_result -> int = 'gsl_sf_lndoublefact_e($a)';
// Function: double gsl_sf_choose (unsigned int n, unsigned int m)
  fun gsl_sf_choose: uint * uint -> double = 'gsl_sf_choose($a)';
// Function: int gsl_sf_choose_e (unsigned int n, unsigned int m, gsl_sf_result * result)
  fun gsl_sf_choose_e: uint * uint * &gsl_sf_result -> int = 'gsl_sf_choose_e($a)';
// Function: double gsl_sf_lnchoose (unsigned int n, unsigned int m)
  fun gsl_sf_lnchoose: uint * uint -> double = 'gsl_sf_lnchoose($a)';
// Function: int gsl_sf_lnchoose_e (unsigned int n, unsigned int m, gsl_sf_result * result)
  fun gsl_sf_lnchoose_e: uint * uint * &gsl_sf_result -> int = 'gsl_sf_lnchoose_e($a)';
// Function: double gsl_sf_taylorcoeff (int n, double x)
  fun gsl_sf_taylorcoeff: int * double -> double = 'gsl_sf_taylorcoeff($a)';
// Function: int gsl_sf_taylorcoeff_e (int n, double x, gsl_sf_result * result)
  fun gsl_sf_taylorcoeff_e: int * double * &gsl_sf_result -> int = 'gsl_sf_taylorcoeff_e($a)';
//*****
// 07.19.03 Pochhammer-Symbol.
// Function: double gsl_sf_poch (double a, double x)
  fun gsl_sf_poch: double * double -> double = 'gsl_sf_poch($a)';
// Function: int gsl_sf_poch_e (double a, double x, gsl_sf_result * result)
  fun gsl_sf_poch_e: double * double * &gsl_sf_result -> int = 'gsl_sf_poch_e($a)';
// Function: double gsl_sf_lnpoch (double a, double x)
  fun gsl_sf_lnpoch: double * double -> double = 'gsl_sf_lnpoch($a)';
// Function: int gsl_sf_lnpoch_e (double a, double x, gsl_sf_result * result)
  fun gsl_sf_lnpoch_e: double * double * &gsl_sf_result -> int = 'gsl_sf_lnpoch_e($a)';
// Function: int gsl_sf_lnpoch_sgn_e (double a, double x, gsl_sf_result * result, double * sgn)
  fun gsl_sf_lnpoch_sgn_e: double * double * &gsl_sf_result * &double -> int = 'gsl_sf_lnpoch_sgn_e($a)';
// Function: double gsl_sf_pochrel (double a, double x)
  fun gsl_sf_pochrel: double * double -> double = 'gsl_sf_pochrel($a)';
// Function: int gsl_sf_pochrel_e (double a, double x, gsl_sf_result * result)
  fun gsl_sf_pochrel_e: double * double * &gsl_sf_result -> int = 'gsl_sf_pochrel_e($a)';
//*****
// 07.19.04 Incomplete-Gamma-Functions.
// Function: double gsl_sf_gamma_inc (double a, double x)
  fun gsl_sf_gamma_inc: double * double -> double = 'gsl_sf_gamma_inc($a)';
// Function: int gsl_sf_gamma_inc_e (double a, double x, gsl_sf_result * result)
  fun gsl_sf_gamma_inc_e: double * double * &gsl_sf_result -> int = 'gsl_sf_gamma_inc_e($a)';
// Function: double gsl_sf_gamma_inc_Q (double a, double x)
  fun gsl_sf_gamma_inc_Q: double * double -> double = 'gsl_sf_gamma_inc_Q($a)';
// Function: int gsl_sf_gamma_inc_Q_e (double a, double x, gsl_sf_result * result)
  fun gsl_sf_gamma_inc_Q_e: double * double * &gsl_sf_result -> int = 'gsl_sf_gamma_inc_Q_e($a)';
// Function: double gsl_sf_gamma_inc_P (double a, double x)
  fun gsl_sf_gamma_inc_P: double * double -> double = 'gsl_sf_gamma_inc_P($a)';
// Function: int gsl_sf_gamma_inc_P_e (double a, double x, gsl_sf_result * result)
  fun gsl_sf_gamma_inc_P_e: double * double * &gsl_sf_result -> int = 'gsl_sf_gamma_inc_P_e($a)';
//*****
// 07.19.05 Beta-Functions.
// Function: double gsl_sf_beta (double a, double b)
  fun gsl_sf_beta: double * double -> double = 'gsl_sf_beta($a)';
// Function: int gsl_sf_beta_e (double a, double b, gsl_sf_result * result)
  fun gsl_sf_beta_e: double * double * &gsl_sf_result -> int = 'gsl_sf_beta_e($a)';
// Function: double gsl_sf_lnbeta (double a, double b)
  fun gsl_sf_lnbeta: double * double -> double = 'gsl_sf_lnbeta($a)';
// Function: int gsl_sf_lnbeta_e (double a, double b, gsl_sf_result * result)
  fun gsl_sf_lnbeta_e: double * double * &gsl_sf_result -> int = 'gsl_sf_lnbeta_e($a)';
//*****
// 07.19.06 Incomplete-Beta-Function.
// Function: double gsl_sf_beta_inc (double a, double b, double x)
  fun gsl_sf_beta_inc: double * double * double -> double = 'gsl_sf_beta_inc($a)';
// Function: int gsl_sf_beta_inc_e (double a, double b, double x, gsl_sf_result * result)
  fun gsl_sf_beta_inc_e: double * double * double * &gsl_sf_result -> int = 'gsl_sf_beta_inc_e($a)';
//*****
// 07.20.00 Gegenbauer-Functions.
// Function: double gsl_sf_gegenpoly_1 (double lambda, double x)
  fun gsl_sf_gegenpoly_1: double * double -> double = 'gsl_sf_gegenpoly_1($a)';
// Function: double gsl_sf_gegenpoly_2 (double lambda, double x)
  fun gsl_sf_gegenpoly_2: double * double -> double = 'gsl_sf_gegenpoly_2($a)';
// Function: double gsl_sf_gegenpoly_3 (double lambda, double x)
  fun gsl_sf_gegenpoly_3: double * double -> double = 'gsl_sf_gegenpoly_3($a)';
// Function: int gsl_sf_gegenpoly_1_e (double lambda, double x, gsl_sf_result * result)
  fun gsl_sf_gegenpoly_1_e: double * double * &gsl_sf_result -> int = 'gsl_sf_gegenpoly_1_e($a)';
// Function: int gsl_sf_gegenpoly_2_e (double lambda, double x, gsl_sf_result * result)
  fun gsl_sf_gegenpoly_2_e: double * double * &gsl_sf_result -> int = 'gsl_sf_gegenpoly_2_e($a)';
// Function: int gsl_sf_gegenpoly_3_e (double lambda, double x, gsl_sf_result * result)
  fun gsl_sf_gegenpoly_3_e: double * double * &gsl_sf_result -> int = 'gsl_sf_gegenpoly_3_e($a)';
// Function: double gsl_sf_gegenpoly_n (int n, double lambda, double x)
  fun gsl_sf_gegenpoly_n: int * double * double -> double = 'gsl_sf_gegenpoly_n($a)';
// Function: int gsl_sf_gegenpoly_n_e (int n, double lambda, double x, gsl_sf_result * result)
  fun gsl_sf_gegenpoly_n_e: int * double * double * &gsl_sf_result -> int = 'gsl_sf_gegenpoly_n_e($a)';
// Function: int gsl_sf_gegenpoly_array (int nmax, double lambda, double x, double result_array[])
  fun gsl_sf_gegenpoly_array: int * double * double * +double -> int = 'gsl_sf_gegenpoly_array($a)';
//*****
// 07.21.00 Hypergeometric-Functions.
// Function: double gsl_sf_hyperg_0F1 (double c, double x)
  fun gsl_sf_hyperg_0F1: double * double -> double = 'gsl_sf_hyperg_0F1($a)';
// Function: int gsl_sf_hyperg_0F1_e (double c, double x, gsl_sf_result * result)
  fun gsl_sf_hyperg_0F1_e: double * double * &gsl_sf_result -> int = 'gsl_sf_hyperg_0F1_e($a)';
// Function: double gsl_sf_hyperg_1F1_int (int m, int n, double x)
  fun gsl_sf_hyperg_1F1_int: int * int * double -> double = 'gsl_sf_hyperg_1F1_int($a)';
// Function: int gsl_sf_hyperg_1F1_int_e (int m, int n, double x, gsl_sf_result * result)
  fun gsl_sf_hyperg_1F1_int_e: int * int * double * &gsl_sf_result -> int = 'gsl_sf_hyperg_1F1_int_e($a)';
// Function: double gsl_sf_hyperg_1F1 (double a, double b, double x)
  fun gsl_sf_hyperg_1F1: double * double * double -> double = 'gsl_sf_hyperg_1F1($a)';
// Function: int gsl_sf_hyperg_1F1_e (double a, double b, double x, gsl_sf_result * result)
  fun gsl_sf_hyperg_1F1_e: double * double * double * &gsl_sf_result -> int = 'gsl_sf_hyperg_1F1_e($a)';
// Function: double gsl_sf_hyperg_U_int (int m, int n, double x)
  fun gsl_sf_hyperg_U_int: int * int * double -> double = 'gsl_sf_hyperg_U_int($a)';
// Function: int gsl_sf_hyperg_U_int_e (int m, int n, double x, gsl_sf_result * result)
  fun gsl_sf_hyperg_U_int_e: int * int * double * &gsl_sf_result -> int = 'gsl_sf_hyperg_U_int_e($a)';
// Function: int gsl_sf_hyperg_U_int_e10_e (int m, int n, double x, gsl_sf_result_e10 * result)
  fun gsl_sf_hyperg_U_int_e10_e: int * int * double * &gsl_sf_result_e10 -> int = 'gsl_sf_hyperg_U_int_e10_e($a)';
// Function: double gsl_sf_hyperg_U (double a, double b, double x)
  fun gsl_sf_hyperg_U: double * double * double -> double = 'gsl_sf_hyperg_U($a)';
// Function: int gsl_sf_hyperg_U_e (double a, double b, double x, gsl_sf_result * result)
  fun gsl_sf_hyperg_U_e: double * double * double * &gsl_sf_result -> int = 'gsl_sf_hyperg_U_e($a)';
// Function: int gsl_sf_hyperg_U_e10_e (double a, double b, double x, gsl_sf_result_e10 * result)
  fun gsl_sf_hyperg_U_e10_e: double * double * double * &gsl_sf_result_e10 -> int = 'gsl_sf_hyperg_U_e10_e($a)';
// Function: double gsl_sf_hyperg_2F1 (double a, double b, double c, double x)
  fun gsl_sf_hyperg_2F1: double * double * double * double -> double = 'gsl_sf_hyperg_2F1($a)';
// Function: int gsl_sf_hyperg_2F1_e (double a, double b, double c, double x, gsl_sf_result * result)
  fun gsl_sf_hyperg_2F1_e: double * double * double * double * &gsl_sf_result -> int = 'gsl_sf_hyperg_2F1_e($a)';
// Function: double gsl_sf_hyperg_2F1_conj (double aR, double aI, double c, double x)
  fun gsl_sf_hyperg_2F1_conj: double * double * double * double -> double = 'gsl_sf_hyperg_2F1_conj($a)';
// Function: int gsl_sf_hyperg_2F1_conj_e (double aR, double aI, double c, double x, gsl_sf_result * result)
  fun gsl_sf_hyperg_2F1_conj_e: double * double * double * double * &gsl_sf_result -> int = 'gsl_sf_hyperg_2F1_conj_e($a)';
// Function: double gsl_sf_hyperg_2F1_renorm (double a, double b, double c, double x)
  fun gsl_sf_hyperg_2F1_renorm: double * double * double * double -> double = 'gsl_sf_hyperg_2F1_renorm($a)';
// Function: int gsl_sf_hyperg_2F1_renorm_e (double a, double b, double c, double x, gsl_sf_result * result)
  fun gsl_sf_hyperg_2F1_renorm_e: double * double * double * double * &gsl_sf_result -> int = 'gsl_sf_hyperg_2F1_renorm_e($a)';
// Function: double gsl_sf_hyperg_2F1_conj_renorm (double aR, double aI, double c, double x)
  fun gsl_sf_hyperg_2F1_conj_renorm: double * double * double * double -> double = 'gsl_sf_hyperg_2F1_conj_renorm($a)';
// Function: int gsl_sf_hyperg_2F1_conj_renorm_e (double aR, double aI, double c, double x, gsl_sf_result * result)
  fun gsl_sf_hyperg_2F1_conj_renorm_e: double * double * double * double * &gsl_sf_result -> int = 'gsl_sf_hyperg_2F1_conj_renorm_e($a)';
// Function: double gsl_sf_hyperg_2F0 (double a, double b, double x)
  fun gsl_sf_hyperg_2F0: double * double * double -> double = 'gsl_sf_hyperg_2F0($a)';
// Function: int gsl_sf_hyperg_2F0_e (double a, double b, double x, gsl_sf_result * result)
  fun gsl_sf_hyperg_2F0_e: double * double * double * &gsl_sf_result -> int = 'gsl_sf_hyperg_2F0_e($a)';
//*****
// 07.22.00 Laguerre-Functions.
// Function: double gsl_sf_laguerre_1 (double a, double x)
  fun gsl_sf_laguerre_1: double * double -> double = 'gsl_sf_laguerre_1($a)';
// Function: double gsl_sf_laguerre_2 (double a, double x)
  fun gsl_sf_laguerre_2: double * double -> double = 'gsl_sf_laguerre_2($a)';
// Function: double gsl_sf_laguerre_3 (double a, double x)
  fun gsl_sf_laguerre_3: double * double -> double = 'gsl_sf_laguerre_3($a)';
// Function: int gsl_sf_laguerre_1_e (double a, double x, gsl_sf_result * result)
  fun gsl_sf_laguerre_1_e: double * double * &gsl_sf_result -> int = 'gsl_sf_laguerre_1_e($a)';
// Function: int gsl_sf_laguerre_2_e (double a, double x, gsl_sf_result * result)
  fun gsl_sf_laguerre_2_e: double * double * &gsl_sf_result -> int = 'gsl_sf_laguerre_2_e($a)';
// Function: int gsl_sf_laguerre_3_e (double a, double x, gsl_sf_result * result)
  fun gsl_sf_laguerre_3_e: double * double * &gsl_sf_result -> int = 'gsl_sf_laguerre_3_e($a)';
// Function: double gsl_sf_laguerre_n (const int n, const double a, const double x)
  fun gsl_sf_laguerre_n: int * double * double -> double = 'gsl_sf_laguerre_n($a)';
// Function: int gsl_sf_laguerre_n_e (int n, double a, double x, gsl_sf_result * result)
  fun gsl_sf_laguerre_n_e: int * double * double * &gsl_sf_result -> int = 'gsl_sf_laguerre_n_e($a)';
//*****
// 07.23.00 Lambert-W-Functions.
// Function: double gsl_sf_lambert_W0 (double x)
  fun gsl_sf_lambert_W0: double -> double = 'gsl_sf_lambert_W0($a)';
// Function: int gsl_sf_lambert_W0_e (double x, gsl_sf_result * result)
  fun gsl_sf_lambert_W0_e: double * &gsl_sf_result -> int = 'gsl_sf_lambert_W0_e($a)';
// Function: double gsl_sf_lambert_Wm1 (double x)
  fun gsl_sf_lambert_Wm1: double -> double = 'gsl_sf_lambert_Wm1($a)';
// Function: int gsl_sf_lambert_Wm1_e (double x, gsl_sf_result * result)
  fun gsl_sf_lambert_Wm1_e: double * &gsl_sf_result -> int = 'gsl_sf_lambert_Wm1_e($a)';
//*****
// 07.24.00 Legendre-Functions-and-Spherical-Harmonics.
//*****
// 07.24.01 Legendre-Polynomials.
// Function: double gsl_sf_legendre_P1 (double x)
  fun gsl_sf_legendre_P1: double -> double = 'gsl_sf_legendre_P1($a)';
// Function: double gsl_sf_legendre_P2 (double x)
  fun gsl_sf_legendre_P2: double -> double = 'gsl_sf_legendre_P2($a)';
// Function: double gsl_sf_legendre_P3 (double x)
  fun gsl_sf_legendre_P3: double -> double = 'gsl_sf_legendre_P3($a)';
// Function: int gsl_sf_legendre_P1_e (double x, gsl_sf_result * result)
  fun gsl_sf_legendre_P1_e: double * &gsl_sf_result -> int = 'gsl_sf_legendre_P1_e($a)';
// Function: int gsl_sf_legendre_P2_e (double x, gsl_sf_result * result)
  fun gsl_sf_legendre_P2_e: double * &gsl_sf_result -> int = 'gsl_sf_legendre_P2_e($a)';
// Function: int gsl_sf_legendre_P3_e (double x, gsl_sf_result * result)
  fun gsl_sf_legendre_P3_e: double * &gsl_sf_result -> int = 'gsl_sf_legendre_P3_e($a)';
// Function: double gsl_sf_legendre_Pl (int l, double x)
  fun gsl_sf_legendre_Pl: int * double -> double = 'gsl_sf_legendre_Pl($a)';
// Function: int gsl_sf_legendre_Pl_e (int l, double x, gsl_sf_result * result)
  fun gsl_sf_legendre_Pl_e: int * double * &gsl_sf_result -> int = 'gsl_sf_legendre_Pl_e($a)';
// Function: int gsl_sf_legendre_Pl_array (int lmax, double x, double result_array[])
  fun gsl_sf_legendre_Pl_array: int * double * +double -> int = 'gsl_sf_legendre_Pl_array($a)';
// Function: int gsl_sf_legendre_Pl_deriv_array (int lmax, double x, double result_array[], double result_deriv_array[])
  fun gsl_sf_legendre_Pl_deriv_array: int * double * +double * +double -> int = 'gsl_sf_legendre_Pl_deriv_array($a)';
// Function: double gsl_sf_legendre_Q0 (double x)
  fun gsl_sf_legendre_Q0: double -> double = 'gsl_sf_legendre_Q0($a)';
// Function: int gsl_sf_legendre_Q0_e (double x, gsl_sf_result * result)
  fun gsl_sf_legendre_Q0_e: double * &gsl_sf_result -> int = 'gsl_sf_legendre_Q0_e($a)';
// Function: double gsl_sf_legendre_Q1 (double x)
  fun gsl_sf_legendre_Q1: double -> double = 'gsl_sf_legendre_Q1($a)';
// Function: int gsl_sf_legendre_Q1_e (double x, gsl_sf_result * result)
  fun gsl_sf_legendre_Q1_e: double * &gsl_sf_result -> int = 'gsl_sf_legendre_Q1_e($a)';
// Function: double gsl_sf_legendre_Ql (int l, double x)
  fun gsl_sf_legendre_Ql: int * double -> double = 'gsl_sf_legendre_Ql($a)';
// Function: int gsl_sf_legendre_Ql_e (int l, double x, gsl_sf_result * result)
  fun gsl_sf_legendre_Ql_e: int * double * &gsl_sf_result -> int = 'gsl_sf_legendre_Ql_e($a)';
//*****
// 07.24.02 Associated-Legendre-Polynomials-and-Spherical-Harmonics.
// Function: double gsl_sf_legendre_Plm (int l, int m, double x)
  fun gsl_sf_legendre_Plm: int * int * double -> double = 'gsl_sf_legendre_Plm($a)';
// Function: int gsl_sf_legendre_Plm_e (int l, int m, double x, gsl_sf_result * result)
  fun gsl_sf_legendre_Plm_e: int * int * double * &gsl_sf_result -> int = 'gsl_sf_legendre_Plm_e($a)';
// Function: int gsl_sf_legendre_Plm_array (int lmax, int m, double x, double result_array[])
  fun gsl_sf_legendre_Plm_array: int * int * double * +double -> int = 'gsl_sf_legendre_Plm_array($a)';
// Function: int gsl_sf_legendre_Plm_deriv_array (int lmax, int m, double x, double result_array[], double result_deriv_array[])
  fun gsl_sf_legendre_Plm_deriv_array: int * int * double * +double * +double -> int = 'gsl_sf_legendre_Plm_deriv_array($a)';
// Function: double gsl_sf_legendre_sphPlm (int l, int m, double x)
  fun gsl_sf_legendre_sphPlm: int * int * double -> double = 'gsl_sf_legendre_sphPlm($a)';
// Function: int gsl_sf_legendre_sphPlm_e (int l, int m, double x, gsl_sf_result * result)
  fun gsl_sf_legendre_sphPlm_e: int * int * double * &gsl_sf_result -> int = 'gsl_sf_legendre_sphPlm_e($a)';
// Function: int gsl_sf_legendre_sphPlm_array (int lmax, int m, double x, double result_array[])
  fun gsl_sf_legendre_sphPlm_array: int * int * double * +double -> int = 'gsl_sf_legendre_sphPlm_array($a)';
// Function: int gsl_sf_legendre_sphPlm_deriv_array (int lmax, int m, double x, double result_array[], double result_deriv_array[])
  fun gsl_sf_legendre_sphPlm_deriv_array: int * int * double * +double * +double -> int = 'gsl_sf_legendre_sphPlm_deriv_array($a)';
// Function: int gsl_sf_legendre_array_size (const int lmax, const int m)
  fun gsl_sf_legendre_array_size: int * int -> int = 'gsl_sf_legendre_array_size($a)';
//*****
// 07.24.03 Conical-Functions.
// Function: double gsl_sf_conicalP_half (double lambda, double x)
  fun gsl_sf_conicalP_half: double * double -> double = 'gsl_sf_conicalP_half($a)';
// Function: int gsl_sf_conicalP_half_e (double lambda, double x, gsl_sf_result * result)
  fun gsl_sf_conicalP_half_e: double * double * &gsl_sf_result -> int = 'gsl_sf_conicalP_half_e($a)';
// Function: double gsl_sf_conicalP_mhalf (double lambda, double x)
  fun gsl_sf_conicalP_mhalf: double * double -> double = 'gsl_sf_conicalP_mhalf($a)';
// Function: int gsl_sf_conicalP_mhalf_e (double lambda, double x, gsl_sf_result * result)
  fun gsl_sf_conicalP_mhalf_e: double * double * &gsl_sf_result -> int = 'gsl_sf_conicalP_mhalf_e($a)';
// Function: double gsl_sf_conicalP_0 (double lambda, double x)
  fun gsl_sf_conicalP_0: double * double -> double = 'gsl_sf_conicalP_0($a)';
// Function: int gsl_sf_conicalP_0_e (double lambda, double x, gsl_sf_result * result)
  fun gsl_sf_conicalP_0_e: double * double * &gsl_sf_result -> int = 'gsl_sf_conicalP_0_e($a)';
// Function: double gsl_sf_conicalP_1 (double lambda, double x)
  fun gsl_sf_conicalP_1: double * double -> double = 'gsl_sf_conicalP_1($a)';
// Function: int gsl_sf_conicalP_1_e (double lambda, double x, gsl_sf_result * result)
  fun gsl_sf_conicalP_1_e: double * double * &gsl_sf_result -> int = 'gsl_sf_conicalP_1_e($a)';
// Function: double gsl_sf_conicalP_sph_reg (int l, double lambda, double x)
  fun gsl_sf_conicalP_sph_reg: int * double * double -> double = 'gsl_sf_conicalP_sph_reg($a)';
// Function: int gsl_sf_conicalP_sph_reg_e (int l, double lambda, double x, gsl_sf_result * result)
  fun gsl_sf_conicalP_sph_reg_e: int * double * double * &gsl_sf_result -> int = 'gsl_sf_conicalP_sph_reg_e($a)';
// Function: double gsl_sf_conicalP_cyl_reg (int m, double lambda, double x)
  fun gsl_sf_conicalP_cyl_reg: int * double * double -> double = 'gsl_sf_conicalP_cyl_reg($a)';
// Function: int gsl_sf_conicalP_cyl_reg_e (int m, double lambda, double x, gsl_sf_result * result)
  fun gsl_sf_conicalP_cyl_reg_e: int * double * double * &gsl_sf_result -> int = 'gsl_sf_conicalP_cyl_reg_e($a)';
//*****
// 07.24.04 Radial-Functions-for-Hyperbolic-Space.
// Function: double gsl_sf_legendre_H3d_0 (double lambda, double eta)
  fun gsl_sf_legendre_H3d_0: double * double -> double = 'gsl_sf_legendre_H3d_0($a)';
// Function: int gsl_sf_legendre_H3d_0_e (double lambda, double eta, gsl_sf_result * result)
  fun gsl_sf_legendre_H3d_0_e: double * double * &gsl_sf_result -> int = 'gsl_sf_legendre_H3d_0_e($a)';
// Function: double gsl_sf_legendre_H3d_1 (double lambda, double eta)
  fun gsl_sf_legendre_H3d_1: double * double -> double = 'gsl_sf_legendre_H3d_1($a)';
// Function: int gsl_sf_legendre_H3d_1_e (double lambda, double eta, gsl_sf_result * result)
  fun gsl_sf_legendre_H3d_1_e: double * double * &gsl_sf_result -> int = 'gsl_sf_legendre_H3d_1_e($a)';
// Function: double gsl_sf_legendre_H3d (int l, double lambda, double eta)
  fun gsl_sf_legendre_H3d: int * double * double -> double = 'gsl_sf_legendre_H3d($a)';
// Function: int gsl_sf_legendre_H3d_e (int l, double lambda, double eta, gsl_sf_result * result)
  fun gsl_sf_legendre_H3d_e: int * double * double * &gsl_sf_result -> int = 'gsl_sf_legendre_H3d_e($a)';
// Function: int gsl_sf_legendre_H3d_array (int lmax, double lambda, double eta, double result_array[])
  fun gsl_sf_legendre_H3d_array: int * double * double * +double -> int = 'gsl_sf_legendre_H3d_array($a)';
//*****
// 07.25.00 Logarithm-and-Related-Functions.
// Function: double gsl_sf_log (double x)
  fun gsl_sf_log: double -> double = 'gsl_sf_log($a)';
// Function: int gsl_sf_log_e (double x, gsl_sf_result * result)
  fun gsl_sf_log_e: double * &gsl_sf_result -> int = 'gsl_sf_log_e($a)';
// Function: double gsl_sf_log_abs (double x)
  fun gsl_sf_log_abs: double -> double = 'gsl_sf_log_abs($a)';
// Function: int gsl_sf_log_abs_e (double x, gsl_sf_result * result)
  fun gsl_sf_log_abs_e: double * &gsl_sf_result -> int = 'gsl_sf_log_abs_e($a)';
// Function: int gsl_sf_complex_log_e (double zr, double zi, gsl_sf_result * lnr, gsl_sf_result * theta)
  fun gsl_sf_complex_log_e: double * double * &gsl_sf_result * &gsl_sf_result -> int = 'gsl_sf_complex_log_e($a)';
// Function: double gsl_sf_log_1plusx (double x)
  fun gsl_sf_log_1plusx: double -> double = 'gsl_sf_log_1plusx($a)';
// Function: int gsl_sf_log_1plusx_e (double x, gsl_sf_result * result)
  fun gsl_sf_log_1plusx_e: double * &gsl_sf_result -> int = 'gsl_sf_log_1plusx_e($a)';
// Function: double gsl_sf_log_1plusx_mx (double x)
  fun gsl_sf_log_1plusx_mx: double -> double = 'gsl_sf_log_1plusx_mx($a)';
// Function: int gsl_sf_log_1plusx_mx_e (double x, gsl_sf_result * result)
  fun gsl_sf_log_1plusx_mx_e: double * &gsl_sf_result -> int = 'gsl_sf_log_1plusx_mx_e($a)';
//*****
// 07.26.00 Mathieu-Functions.
//*****
// 07.26.01 Mathieu-Function-Workspace.
// Function: gsl_sf_mathieu_workspace * gsl_sf_mathieu_alloc (size_t n, double qmax)
  fun gsl_sf_mathieu_alloc: size * double -> &gsl_sf_mathieu_workspace = 'gsl_sf_mathieu_alloc($a)';
// Function: void gsl_sf_mathieu_free (gsl_sf_mathieu_workspace * work)
  proc gsl_sf_mathieu_free: &gsl_sf_mathieu_workspace = 'gsl_sf_mathieu_free($a);';
//*****
// 07.26.02 Mathieu-Function-Characteristic-Values.
// Function: int gsl_sf_mathieu_a (int n, double q, gsl_sf_result * result)
  fun gsl_sf_mathieu_a: int * double * &gsl_sf_result -> int = 'gsl_sf_mathieu_a($a)';
// Function: int gsl_sf_mathieu_b (int n, double q, gsl_sf_result * result)
  fun gsl_sf_mathieu_b: int * double * &gsl_sf_result -> int = 'gsl_sf_mathieu_b($a)';
// Function: int gsl_sf_mathieu_a_array (int order_min, int order_max, double q, gsl_sf_mathieu_workspace * work, double result_array[])
  fun gsl_sf_mathieu_a_array: int * int * double * &gsl_sf_mathieu_workspace * +double -> int = 'gsl_sf_mathieu_a_array($a)';
// Function: int gsl_sf_mathieu_b_array (int order_min, int order_max, double q, gsl_sf_mathieu_workspace * work, double result_array[])
  fun gsl_sf_mathieu_b_array: int * int * double * &gsl_sf_mathieu_workspace * +double -> int = 'gsl_sf_mathieu_b_array($a)';
//*****
// 07.26.03 Angular-Mathieu-Functions.
// Function: int gsl_sf_mathieu_ce (int n, double q, double x, gsl_sf_result * result)
  fun gsl_sf_mathieu_ce: int * double * double * &gsl_sf_result -> int = 'gsl_sf_mathieu_ce($a)';
// Function: int gsl_sf_mathieu_se (int n, double q, double x, gsl_sf_result * result)
  fun gsl_sf_mathieu_se: int * double * double * &gsl_sf_result -> int = 'gsl_sf_mathieu_se($a)';
// Function: int gsl_sf_mathieu_ce_array (int nmin, int nmax, double q, double x, gsl_sf_mathieu_workspace * work, double result_array[])
  fun gsl_sf_mathieu_ce_array: int * int * double * double * &gsl_sf_mathieu_workspace * +double -> int = 'gsl_sf_mathieu_ce_array($a)';
// Function: int gsl_sf_mathieu_se_array (int nmin, int nmax, double q, double x, gsl_sf_mathieu_workspace * work, double result_array[])
  fun gsl_sf_mathieu_se_array: int * int * double * double * &gsl_sf_mathieu_workspace * +double -> int = 'gsl_sf_mathieu_se_array($a)';
//*****
// 07.26.04 Radial-Mathieu-Functions.
// Function: int gsl_sf_mathieu_Mc (int j, int n, double q, double x, gsl_sf_result * result)
  fun gsl_sf_mathieu_Mc: int * int * double * double * &gsl_sf_result -> int = 'gsl_sf_mathieu_Mc($a)';
// Function: int gsl_sf_mathieu_Ms (int j, int n, double q, double x, gsl_sf_result * result)
  fun gsl_sf_mathieu_Ms: int * int * double * double * &gsl_sf_result -> int = 'gsl_sf_mathieu_Ms($a)';
// Function: int gsl_sf_mathieu_Mc_array (int j, int nmin, int nmax, double q, double x, gsl_sf_mathieu_workspace * work, double result_array[])
  fun gsl_sf_mathieu_Mc_array: int * int * int * double * double * &gsl_sf_mathieu_workspace * +double -> int = 'gsl_sf_mathieu_Mc_array($a)';
// Function: int gsl_sf_mathieu_Ms_array (int j, int nmin, int nmax, double q, double x, gsl_sf_mathieu_workspace * work, double result_array[])
  fun gsl_sf_mathieu_Ms_array: int * int * int * double * double * &gsl_sf_mathieu_workspace * +double -> int = 'gsl_sf_mathieu_Ms_array($a)';
//*****
// 07.27.00 Power-Function.
// Function: double gsl_sf_pow_int (double x, int n)
  fun gsl_sf_pow_int: double * int -> double = 'gsl_sf_pow_int($a)';
// Function: int gsl_sf_pow_int_e (double x, int n, gsl_sf_result * result)
  fun gsl_sf_pow_int_e: double * int * &gsl_sf_result -> int = 'gsl_sf_pow_int_e($a)';
//*****
// 07.28.00 Psi-(Digamma)-Function.
//*****
// 07.28.01 Digamma-Function.
// Function: double gsl_sf_psi_int (int n)
  fun gsl_sf_psi_int: int -> double = 'gsl_sf_psi_int($a)';
// Function: int gsl_sf_psi_int_e (int n, gsl_sf_result * result)
  fun gsl_sf_psi_int_e: int * &gsl_sf_result -> int = 'gsl_sf_psi_int_e($a)';
// Function: double gsl_sf_psi (double x)
  fun gsl_sf_psi: double -> double = 'gsl_sf_psi($a)';
// Function: int gsl_sf_psi_e (double x, gsl_sf_result * result)
  fun gsl_sf_psi_e: double * &gsl_sf_result -> int = 'gsl_sf_psi_e($a)';
// Function: double gsl_sf_psi_1piy (double y)
  fun gsl_sf_psi_1piy: double -> double = 'gsl_sf_psi_1piy($a)';
// Function: int gsl_sf_psi_1piy_e (double y, gsl_sf_result * result)
  fun gsl_sf_psi_1piy_e: double * &gsl_sf_result -> int = 'gsl_sf_psi_1piy_e($a)';
//*****
// 07.28.02 Trigamma-Function.
// Function: double gsl_sf_psi_1_int (int n)
  fun gsl_sf_psi_1_int: int -> double = 'gsl_sf_psi_1_int($a)';
// Function: int gsl_sf_psi_1_int_e (int n, gsl_sf_result * result)
  fun gsl_sf_psi_1_int_e: int * &gsl_sf_result -> int = 'gsl_sf_psi_1_int_e($a)';
// Function: double gsl_sf_psi_1 (double x)
  fun gsl_sf_psi_1: double -> double = 'gsl_sf_psi_1($a)';
// Function: int gsl_sf_psi_1_e (double x, gsl_sf_result * result)
  fun gsl_sf_psi_1_e: double * &gsl_sf_result -> int = 'gsl_sf_psi_1_e($a)';
//*****
// 07.28.03 Polygamma-Function.
// Function: double gsl_sf_psi_n (int n, double x)
  fun gsl_sf_psi_n: int * double -> double = 'gsl_sf_psi_n($a)';
// Function: int gsl_sf_psi_n_e (int n, double x, gsl_sf_result * result)
  fun gsl_sf_psi_n_e: int * double * &gsl_sf_result -> int = 'gsl_sf_psi_n_e($a)';
//*****
// 07.29.00 Synchrotron-Functions.
// Function: double gsl_sf_synchrotron_1 (double x)
  fun gsl_sf_synchrotron_1: double -> double = 'gsl_sf_synchrotron_1($a)';
// Function: int gsl_sf_synchrotron_1_e (double x, gsl_sf_result * result)
  fun gsl_sf_synchrotron_1_e: double * &gsl_sf_result -> int = 'gsl_sf_synchrotron_1_e($a)';
// Function: double gsl_sf_synchrotron_2 (double x)
  fun gsl_sf_synchrotron_2: double -> double = 'gsl_sf_synchrotron_2($a)';
// Function: int gsl_sf_synchrotron_2_e (double x, gsl_sf_result * result)
  fun gsl_sf_synchrotron_2_e: double * &gsl_sf_result -> int = 'gsl_sf_synchrotron_2_e($a)';
//*****
// 07.30.00 Transport-Functions.
// Function: double gsl_sf_transport_2 (double x)
  fun gsl_sf_transport_2: double -> double = 'gsl_sf_transport_2($a)';
// Function: int gsl_sf_transport_2_e (double x, gsl_sf_result * result)
  fun gsl_sf_transport_2_e: double * &gsl_sf_result -> int = 'gsl_sf_transport_2_e($a)';
// Function: double gsl_sf_transport_3 (double x)
  fun gsl_sf_transport_3: double -> double = 'gsl_sf_transport_3($a)';
// Function: int gsl_sf_transport_3_e (double x, gsl_sf_result * result)
  fun gsl_sf_transport_3_e: double * &gsl_sf_result -> int = 'gsl_sf_transport_3_e($a)';
// Function: double gsl_sf_transport_4 (double x)
  fun gsl_sf_transport_4: double -> double = 'gsl_sf_transport_4($a)';
// Function: int gsl_sf_transport_4_e (double x, gsl_sf_result * result)
  fun gsl_sf_transport_4_e: double * &gsl_sf_result -> int = 'gsl_sf_transport_4_e($a)';
// Function: double gsl_sf_transport_5 (double x)
  fun gsl_sf_transport_5: double -> double = 'gsl_sf_transport_5($a)';
// Function: int gsl_sf_transport_5_e (double x, gsl_sf_result * result)
  fun gsl_sf_transport_5_e: double * &gsl_sf_result -> int = 'gsl_sf_transport_5_e($a)';
//*****
// 07.31.00 Trigonometric-Functions.
//*****
// 07.31.01 Circular-Trigonometric-Functions.
// Function: double gsl_sf_sin (double x)
  fun gsl_sf_sin: double -> double = 'gsl_sf_sin($a)';
// Function: int gsl_sf_sin_e (double x, gsl_sf_result * result)
  fun gsl_sf_sin_e: double * &gsl_sf_result -> int = 'gsl_sf_sin_e($a)';
// Function: double gsl_sf_cos (double x)
  fun gsl_sf_cos: double -> double = 'gsl_sf_cos($a)';
// Function: int gsl_sf_cos_e (double x, gsl_sf_result * result)
  fun gsl_sf_cos_e: double * &gsl_sf_result -> int = 'gsl_sf_cos_e($a)';
// Function: double gsl_sf_hypot (double x, double y)
  fun gsl_sf_hypot: double * double -> double = 'gsl_sf_hypot($a)';
// Function: int gsl_sf_hypot_e (double x, double y, gsl_sf_result * result)
  fun gsl_sf_hypot_e: double * double * &gsl_sf_result -> int = 'gsl_sf_hypot_e($a)';
// Function: double gsl_sf_sinc (double x)
  fun gsl_sf_sinc: double -> double = 'gsl_sf_sinc($a)';
// Function: int gsl_sf_sinc_e (double x, gsl_sf_result * result)
  fun gsl_sf_sinc_e: double * &gsl_sf_result -> int = 'gsl_sf_sinc_e($a)';
//*****
// 07.31.02 Trigonometric-Functions-for-Complex-Arguments.
// Function: int gsl_sf_complex_sin_e (double zr, double zi, gsl_sf_result * szr, gsl_sf_result * szi)
  fun gsl_sf_complex_sin_e: double * double * &gsl_sf_result * &gsl_sf_result -> int = 'gsl_sf_complex_sin_e($a)';
// Function: int gsl_sf_complex_cos_e (double zr, double zi, gsl_sf_result * czr, gsl_sf_result * czi)
  fun gsl_sf_complex_cos_e: double * double * &gsl_sf_result * &gsl_sf_result -> int = 'gsl_sf_complex_cos_e($a)';
// Function: int gsl_sf_complex_logsin_e (double zr, double zi, gsl_sf_result * lszr, gsl_sf_result * lszi)
  fun gsl_sf_complex_logsin_e: double * double * &gsl_sf_result * &gsl_sf_result -> int = 'gsl_sf_complex_logsin_e($a)';
//*****
// 07.31.03 Hyperbolic-Trigonometric-Functions.
// Function: double gsl_sf_lnsinh (double x)
  fun gsl_sf_lnsinh: double -> double = 'gsl_sf_lnsinh($a)';
// Function: int gsl_sf_lnsinh_e (double x, gsl_sf_result * result)
  fun gsl_sf_lnsinh_e: double * &gsl_sf_result -> int = 'gsl_sf_lnsinh_e($a)';
// Function: double gsl_sf_lncosh (double x)
  fun gsl_sf_lncosh: double -> double = 'gsl_sf_lncosh($a)';
// Function: int gsl_sf_lncosh_e (double x, gsl_sf_result * result)
  fun gsl_sf_lncosh_e: double * &gsl_sf_result -> int = 'gsl_sf_lncosh_e($a)';
//*****
// 07.31.04 Conversion-Functions.
// Function: int gsl_sf_polar_to_rect (double r, double theta, gsl_sf_result * x, gsl_sf_result * y);
  fun gsl_sf_polar_to_rect: double * double * &gsl_sf_result * &gsl_sf_result -> int = 'gsl_sf_polar_to_rect($a)';
// Function: int gsl_sf_rect_to_polar (double x, double y, gsl_sf_result * r, gsl_sf_result * theta)
  fun gsl_sf_rect_to_polar: double * double * &gsl_sf_result * &gsl_sf_result -> int = 'gsl_sf_rect_to_polar($a)';
//*****
// 07.31.05 Restriction-Functions.
// Function: double gsl_sf_angle_restrict_symm (double theta)
  fun gsl_sf_angle_restrict_symm: double -> double = 'gsl_sf_angle_restrict_symm($a)';
// Function: int gsl_sf_angle_restrict_symm_e (double * theta)
  fun gsl_sf_angle_restrict_symm_e: &double -> int = 'gsl_sf_angle_restrict_symm_e($a)';
// Function: double gsl_sf_angle_restrict_pos (double theta)
  fun gsl_sf_angle_restrict_pos: double -> double = 'gsl_sf_angle_restrict_pos($a)';
// Function: int gsl_sf_angle_restrict_pos_e (double * theta)
  fun gsl_sf_angle_restrict_pos_e: &double -> int = 'gsl_sf_angle_restrict_pos_e($a)';
//*****
// 07.31.06 Trigonometric-Functions-With-Error-Estimates.
// Function: int gsl_sf_sin_err_e (double x, double dx, gsl_sf_result * result)
  fun gsl_sf_sin_err_e: double * double * &gsl_sf_result -> int = 'gsl_sf_sin_err_e($a)';
// Function: int gsl_sf_cos_err_e (double x, double dx, gsl_sf_result * result)
  fun gsl_sf_cos_err_e: double * double * &gsl_sf_result -> int = 'gsl_sf_cos_err_e($a)';
//*****
// 07.32.00 Zeta-Functions.
//*****
// 07.32.01 Riemann-Zeta-Function.
// Function: double gsl_sf_zeta_int (int n)
  fun gsl_sf_zeta_int: int -> double = 'gsl_sf_zeta_int($a)';
// Function: int gsl_sf_zeta_int_e (int n, gsl_sf_result * result)
  fun gsl_sf_zeta_int_e: int * &gsl_sf_result -> int = 'gsl_sf_zeta_int_e($a)';
// Function: double gsl_sf_zeta (double s)
  fun gsl_sf_zeta: double -> double = 'gsl_sf_zeta($a)';
// Function: int gsl_sf_zeta_e (double s, gsl_sf_result * result)
  fun gsl_sf_zeta_e: double * &gsl_sf_result -> int = 'gsl_sf_zeta_e($a)';
//*****
// 07.32.02 Riemann-Zeta-Function-Minus-One.
// Function: double gsl_sf_zetam1_int (int n)
  fun gsl_sf_zetam1_int: int -> double = 'gsl_sf_zetam1_int($a)';
// Function: int gsl_sf_zetam1_int_e (int n, gsl_sf_result * result)
  fun gsl_sf_zetam1_int_e: int * &gsl_sf_result -> int = 'gsl_sf_zetam1_int_e($a)';
// Function: double gsl_sf_zetam1 (double s)
  fun gsl_sf_zetam1: double -> double = 'gsl_sf_zetam1($a)';
// Function: int gsl_sf_zetam1_e (double s, gsl_sf_result * result)
  fun gsl_sf_zetam1_e: double * &gsl_sf_result -> int = 'gsl_sf_zetam1_e($a)';
//*****
// 07.32.03 Hurwitz-Zeta-Function.
// Function: double gsl_sf_hzeta (double s, double q)
  fun gsl_sf_hzeta: double * double -> double = 'gsl_sf_hzeta($a)';
// Function: int gsl_sf_hzeta_e (double s, double q, gsl_sf_result * result)
  fun gsl_sf_hzeta_e: double * double * &gsl_sf_result -> int = 'gsl_sf_hzeta_e($a)';
//*****
// 07.32.04 Eta-Function.
// Function: double gsl_sf_eta_int (int n)
  fun gsl_sf_eta_int: int -> double = 'gsl_sf_eta_int($a)';
// Function: int gsl_sf_eta_int_e (int n, gsl_sf_result * result)
  fun gsl_sf_eta_int_e: int * &gsl_sf_result -> int = 'gsl_sf_eta_int_e($a)';
// Function: double gsl_sf_eta (double s)
  fun gsl_sf_eta: double -> double = 'gsl_sf_eta($a)';
// Function: int gsl_sf_eta_e (double s, gsl_sf_result * result)
  fun gsl_sf_eta_e: double * &gsl_sf_result -> int = 'gsl_sf_eta_e($a)';
//*****
// 08.00.00 Vectors-and-Matrices.
//*****
// 08.01.00 Data-types.
//*****
// 08.02.00 Blocks.
//*****
// 08.02.01 Block-allocation.
// Function: gsl_block * gsl_block_alloc (size_t n)
  fun gsl_block_alloc: size -> &gsl_block = 'gsl_block_alloc($a)';
// Function: gsl_block * gsl_block_calloc (size_t n)
  fun gsl_block_calloc: size -> &gsl_block = 'gsl_block_calloc($a)';
// Function: void gsl_block_free (gsl_block * b)
  proc gsl_block_free: &gsl_block = 'gsl_block_free($a);';
//*****
// 08.02.02 Reading-and-writing-blocks.
// Function: int gsl_block_fwrite (FILE * stream, const gsl_block * b)
  fun gsl_block_fwrite: &FILE * &gsl_block -> int = 'gsl_block_fwrite($a)';
// Function: int gsl_block_fread (FILE * stream, gsl_block * b)
  fun gsl_block_fread: &FILE * &gsl_block -> int = 'gsl_block_fread($a)';
// Function: int gsl_block_fprintf (FILE * stream, const gsl_block * b, const char * format)
  fun gsl_block_fprintf: &FILE * &gsl_block * &char -> int = 'gsl_block_fprintf($a)';
// Function: int gsl_block_fscanf (FILE * stream, gsl_block * b)
  fun gsl_block_fscanf: &FILE * &gsl_block -> int = 'gsl_block_fscanf($a)';
//*****
// 08.03.00 Vectors.
//*****
// 08.03.01 Vector-allocation.
// Function: gsl_vector * gsl_vector_alloc (size_t n)
  fun gsl_vector_alloc: size -> &gsl_vector = 'gsl_vector_alloc($a)';
// Function: gsl_vector * gsl_vector_calloc (size_t n)
  fun gsl_vector_calloc: size -> &gsl_vector = 'gsl_vector_calloc($a)';
// Function: void gsl_vector_free (gsl_vector * v)
  proc gsl_vector_free: &gsl_vector = 'gsl_vector_free($a);';
//*****
// 08.03.02 Accessing-vector-elements.
// Function: double gsl_vector_get (const gsl_vector * v, size_t i)
  fun gsl_vector_get: &gsl_vector * size -> double = 'gsl_vector_get($a)';
// Function: void gsl_vector_set (gsl_vector * v, size_t i, double x)
  proc gsl_vector_set: &gsl_vector * size * double = 'gsl_vector_set($a);';
// Function: double * gsl_vector_ptr (gsl_vector * v, size_t i)
  fun gsl_vector_ptr: &gsl_vector * size -> &double = 'gsl_vector_ptr($a)';
// Function: const double * gsl_vector_const_ptr (const gsl_vector * v, size_t i)
  fun gsl_vector_const_ptr: &gsl_vector * size -> &double = 'gsl_vector_const_ptr($a)';
//*****
// 08.03.03 Initialising-vector-elements.
// Function: void gsl_vector_set_all (gsl_vector * v, double x)
  proc gsl_vector_set_all: &gsl_vector * double = 'gsl_vector_set_all($a);';
// Function: void gsl_vector_set_zero (gsl_vector * v)
  proc gsl_vector_set_zero: &gsl_vector = 'gsl_vector_set_zero($a);';
// Function: int gsl_vector_set_basis (gsl_vector * v, size_t i)
  fun gsl_vector_set_basis: &gsl_vector * size -> int = 'gsl_vector_set_basis($a)';
//*****
// 08.03.04 Reading-and-writing-vectors.
// Function: int gsl_vector_fwrite (FILE * stream, const gsl_vector * v)
  fun gsl_vector_fwrite: &FILE * &gsl_vector -> int = 'gsl_vector_fwrite($a)';
// Function: int gsl_vector_fread (FILE * stream, gsl_vector * v)
  fun gsl_vector_fread: &FILE * &gsl_vector -> int = 'gsl_vector_fread($a)';
// Function: int gsl_vector_fprintf (FILE * stream, const gsl_vector * v, const char * format)
  fun gsl_vector_fprintf: &FILE * &gsl_vector * &char -> int = 'gsl_vector_fprintf($a)';
// Function: int gsl_vector_fscanf (FILE * stream, gsl_vector * v)
  fun gsl_vector_fscanf: &FILE * &gsl_vector -> int = 'gsl_vector_fscanf($a)';
//*****
// 08.03.05 Vector-views.
// Function: gsl_vector_view gsl_vector_subvector (gsl_vector * v, size_t offset, size_t n)
  fun gsl_vector_subvector: &gsl_vector * size * size -> gsl_vector_view = 'gsl_vector_subvector($a)';
// Function: gsl_vector_const_view gsl_vector_const_subvector (const gsl_vector * v, size_t offset, size_t n)
  fun gsl_vector_const_subvector: &gsl_vector * size * size -> gsl_vector_const_view = 'gsl_vector_const_subvector($a)';
// Function: gsl_vector_view gsl_vector_subvector_with_stride (gsl_vector * v, size_t offset, size_t stride, size_t n)
  fun gsl_vector_subvector_with_stride: &gsl_vector * size * size * size -> gsl_vector_view = 'gsl_vector_subvector_with_stride($a)';
// Function: gsl_vector_const_view gsl_vector_const_subvector_with_stride (const gsl_vector * v, size_t offset, size_t stride, size_t n)
  fun gsl_vector_const_subvector_with_stride: &gsl_vector * size * size * size -> gsl_vector_const_view = 'gsl_vector_const_subvector_with_stride($a)';
// Function: gsl_vector_view gsl_vector_complex_real (gsl_vector_complex * v)
  fun gsl_vector_complex_real: &gsl_vector_complex -> gsl_vector_view = 'gsl_vector_complex_real($a)';
// Function: gsl_vector_const_view gsl_vector_complex_const_real (const gsl_vector_complex * v)
  fun gsl_vector_complex_const_real: &gsl_vector_complex -> gsl_vector_const_view = 'gsl_vector_complex_const_real($a)';
// Function: gsl_vector_view gsl_vector_complex_imag (gsl_vector_complex * v)
  fun gsl_vector_complex_imag: &gsl_vector_complex -> gsl_vector_view = 'gsl_vector_complex_imag($a)';
// Function: gsl_vector_const_view gsl_vector_complex_const_imag (const gsl_vector_complex * v)
  fun gsl_vector_complex_const_imag: &gsl_vector_complex -> gsl_vector_const_view = 'gsl_vector_complex_const_imag($a)';
// Function: gsl_vector_view gsl_vector_view_array (double * base, size_t n)
  fun gsl_vector_view_array: &double * size -> gsl_vector_view = 'gsl_vector_view_array($a)';
// Function: gsl_vector_const_view gsl_vector_const_view_array (const double * base, size_t n)
  fun gsl_vector_const_view_array: &double * size -> gsl_vector_const_view = 'gsl_vector_const_view_array($a)';
// Function: gsl_vector_view gsl_vector_view_array_with_stride (double * base, size_t stride, size_t n)
  fun gsl_vector_view_array_with_stride: &double * size * size -> gsl_vector_view = 'gsl_vector_view_array_with_stride($a)';
// Function: gsl_vector_const_view gsl_vector_const_view_array_with_stride (const double * base, size_t stride, size_t n)
  fun gsl_vector_const_view_array_with_stride: &double * size * size -> gsl_vector_const_view = 'gsl_vector_const_view_array_with_stride($a)';
//*****
// 08.03.06 Copying-vectors.
// Function: int gsl_vector_memcpy (gsl_vector * dest, const gsl_vector * src)
  fun gsl_vector_memcpy: &gsl_vector * &gsl_vector -> int = 'gsl_vector_memcpy($a)';
// Function: int gsl_vector_swap (gsl_vector * v, gsl_vector * w)
  fun gsl_vector_swap: &gsl_vector * &gsl_vector -> int = 'gsl_vector_swap($a)';
//*****
// 08.03.07 Exchanging-elements.
// Function: int gsl_vector_swap_elements (gsl_vector * v, size_t i, size_t j)
  fun gsl_vector_swap_elements: &gsl_vector * size * size -> int = 'gsl_vector_swap_elements($a)';
// Function: int gsl_vector_reverse (gsl_vector * v)
  fun gsl_vector_reverse: &gsl_vector -> int = 'gsl_vector_reverse($a)';
//*****
// 08.03.08 Vector-operations.
// Function: int gsl_vector_add (gsl_vector * a, const gsl_vector * b)
  fun gsl_vector_add: &gsl_vector * &gsl_vector -> int = 'gsl_vector_add($a)';
// Function: int gsl_vector_sub (gsl_vector * a, const gsl_vector * b)
  fun gsl_vector_sub: &gsl_vector * &gsl_vector -> int = 'gsl_vector_sub($a)';
// Function: int gsl_vector_mul (gsl_vector * a, const gsl_vector * b)
  fun gsl_vector_mul: &gsl_vector * &gsl_vector -> int = 'gsl_vector_mul($a)';
// Function: int gsl_vector_div (gsl_vector * a, const gsl_vector * b)
  fun gsl_vector_div: &gsl_vector * &gsl_vector -> int = 'gsl_vector_div($a)';
// Function: int gsl_vector_scale (gsl_vector * a, const double x)
  fun gsl_vector_scale: &gsl_vector * double -> int = 'gsl_vector_scale($a)';
// Function: int gsl_vector_add_constant (gsl_vector * a, const double x)
  fun gsl_vector_add_constant: &gsl_vector * double -> int = 'gsl_vector_add_constant($a)';
//*****
// 08.03.09 Finding-maximum-and-minimum-elemnts-of-vectors.
// Function: double gsl_vector_max (const gsl_vector * v)
  fun gsl_vector_max: &gsl_vector -> double = 'gsl_vector_max($a)';
// Function: double gsl_vector_min (const gsl_vector * v)
  fun gsl_vector_min: &gsl_vector -> double = 'gsl_vector_min($a)';
// Function: void gsl_vector_minmax (const gsl_vector * v, double * min_out, double * max_out)
  proc gsl_vector_minmax: &gsl_vector * &double * &double = 'gsl_vector_minmax($a);';
// Function: size_t gsl_vector_max_index (const gsl_vector * v)
  fun gsl_vector_max_index: &gsl_vector -> size = 'gsl_vector_max_index($a)';
// Function: size_t gsl_vector_min_index (const gsl_vector * v)
  fun gsl_vector_min_index: &gsl_vector -> size = 'gsl_vector_min_index($a)';
// Function: void gsl_vector_minmax_index (const gsl_vector * v, size_t * imin, size_t * imax)
  proc gsl_vector_minmax_index: &gsl_vector * &size * &size = 'gsl_vector_minmax_index($a);';
//*****
// 08.03.10 vector-properties.
// Function: int gsl_vector_isnull (const gsl_vector * v)
  fun gsl_vector_isnull: &gsl_vector -> int = 'gsl_vector_isnull($a)';
// Function: int gsl_vector_ispos (const gsl_vector * v)
  fun gsl_vector_ispos: &gsl_vector -> int = 'gsl_vector_ispos($a)';
// Function: int gsl_vector_isneg (const gsl_vector * v)
  fun gsl_vector_isneg: &gsl_vector -> int = 'gsl_vector_isneg($a)';
// Function: int gsl_vector_isnonneg (const gsl_vector * v)
  fun gsl_vector_isnonneg: &gsl_vector -> int = 'gsl_vector_isnonneg($a)';
// Function: int gsl_vector_equal (const gsl_vector * u, const gsl_vector * v)
  fun gsl_vector_equal: &gsl_vector * &gsl_vector -> int = 'gsl_vector_equal($a)';
//*****
// 08.04.00 Matrices.
//*****
// 08.04.01 Matrix-allocation.
// Function: gsl_matrix * gsl_matrix_alloc (size_t n1, size_t n2)
  fun gsl_matrix_alloc: size * size -> &gsl_matrix = 'gsl_matrix_alloc($a)';
// Function: gsl_matrix * gsl_matrix_calloc (size_t n1, size_t n2)
  fun gsl_matrix_calloc: size * size -> &gsl_matrix = 'gsl_matrix_calloc($a)';
// Function: void gsl_matrix_free (gsl_matrix * m)
  proc gsl_matrix_free: &gsl_matrix = 'gsl_matrix_free($a);';
//*****
// 08.04.02 Accessing-matrix-elements.
// Function: double gsl_matrix_get (const gsl_matrix * m, size_t i, size_t j)
  fun gsl_matrix_get: &gsl_matrix * size * size -> double = 'gsl_matrix_get($a)';
// Function: void gsl_matrix_set (gsl_matrix * m, size_t i, size_t j, double x)
  proc gsl_matrix_set: &gsl_matrix * size * size * double = 'gsl_matrix_set($a);';
// Function: double * gsl_matrix_ptr (gsl_matrix * m, size_t i, size_t j)
  fun gsl_matrix_ptr: &gsl_matrix * size * size -> &double = 'gsl_matrix_ptr($a)';
// Function: const double * gsl_matrix_const_ptr (const gsl_matrix * m, size_t i, size_t j)
  fun gsl_matrix_const_ptr: &gsl_matrix * size * size -> &double = 'gsl_matrix_const_ptr($a)';
//*****
// 08.04.02 Initialising-matrix-elements.
// Function: double gsl_matrix_get (const gsl_matrix * m, size_t i, size_t j)
  fun gsl_matrix_get: &gsl_matrix * size * size -> double = 'gsl_matrix_get($a)';
// Function: void gsl_matrix_set (gsl_matrix * m, size_t i, size_t j, double x)
  proc gsl_matrix_set: &gsl_matrix * size * size * double = 'gsl_matrix_set($a);';
// Function: double * gsl_matrix_ptr (gsl_matrix * m, size_t i, size_t j)
  fun gsl_matrix_ptr: &gsl_matrix * size * size -> &double = 'gsl_matrix_ptr($a)';
// Function: const double * gsl_matrix_const_ptr (const gsl_matrix * m, size_t i, size_t j)
  fun gsl_matrix_const_ptr: &gsl_matrix * size * size -> &double = 'gsl_matrix_const_ptr($a)';
//*****
// 08.04.04 Reading-and-writing-matrices.
// Function: int gsl_matrix_fwrite (FILE * stream, const gsl_matrix * m)
  fun gsl_matrix_fwrite: &FILE * &gsl_matrix -> int = 'gsl_matrix_fwrite($a)';
// Function: int gsl_matrix_fread (FILE * stream, gsl_matrix * m)
  fun gsl_matrix_fread: &FILE * &gsl_matrix -> int = 'gsl_matrix_fread($a)';
// Function: int gsl_matrix_fprintf (FILE * stream, const gsl_matrix * m, const char * format)
  fun gsl_matrix_fprintf: &FILE * &gsl_matrix * &char -> int = 'gsl_matrix_fprintf($a)';
// Function: int gsl_matrix_fscanf (FILE * stream, gsl_matrix * m)
  fun gsl_matrix_fscanf: &FILE * &gsl_matrix -> int = 'gsl_matrix_fscanf($a)';
//*****
// 08.04.05 Matrix-views.
// Function: gsl_matrix_view gsl_matrix_submatrix (gsl_matrix * m, size_t k1, size_t k2, size_t n1, size_t n2)
  fun gsl_matrix_submatrix: &gsl_matrix * size * size * size * size -> gsl_matrix_view = 'gsl_matrix_submatrix($a)';
// Function: gsl_matrix_const_view gsl_matrix_const_submatrix (const gsl_matrix * m, size_t k1, size_t k2, size_t n1, size_t n2)
  fun gsl_matrix_const_submatrix: &gsl_matrix * size * size * size * size -> gsl_matrix_const_view = 'gsl_matrix_const_submatrix($a)';
// Function: gsl_matrix_view gsl_matrix_view_array (double * base, size_t n1, size_t n2)
  fun gsl_matrix_view_array: &double * size * size -> gsl_matrix_view = 'gsl_matrix_view_array($a)';
// Function: gsl_matrix_const_view gsl_matrix_const_view_array (const double * base, size_t n1, size_t n2)
  fun gsl_matrix_const_view_array: &double * size * size -> gsl_matrix_const_view = 'gsl_matrix_const_view_array($a)';
// Function: gsl_matrix_view gsl_matrix_view_array_with_tda (double * base, size_t n1, size_t n2, size_t tda)
  fun gsl_matrix_view_array_with_tda: &double * size * size * size -> gsl_matrix_view = 'gsl_matrix_view_array_with_tda($a)';
// Function: gsl_matrix_const_view gsl_matrix_const_view_array_with_tda (const double * base, size_t n1, size_t n2, size_t tda)
  fun gsl_matrix_const_view_array_with_tda: &double * size * size * size -> gsl_matrix_const_view = 'gsl_matrix_const_view_array_with_tda($a)';
// Function: gsl_matrix_view gsl_matrix_view_vector (gsl_vector * v, size_t n1, size_t n2)
  fun gsl_matrix_view_vector: &gsl_vector * size * size -> gsl_matrix_view = 'gsl_matrix_view_vector($a)';
// Function: gsl_matrix_const_view gsl_matrix_const_view_vector (const gsl_vector * v, size_t n1, size_t n2)
  fun gsl_matrix_const_view_vector: &gsl_vector * size * size -> gsl_matrix_const_view = 'gsl_matrix_const_view_vector($a)';
// Function: gsl_matrix_view gsl_matrix_view_vector_with_tda (gsl_vector * v, size_t n1, size_t n2, size_t tda)
  fun gsl_matrix_view_vector_with_tda: &gsl_vector * size * size * size -> gsl_matrix_view = 'gsl_matrix_view_vector_with_tda($a)';
// Function: gsl_matrix_const_view gsl_matrix_const_view_vector_with_tda (const gsl_vector * v, size_t n1, size_t n2, size_t tda)
  fun gsl_matrix_const_view_vector_with_tda: &gsl_vector * size * size * size -> gsl_matrix_const_view = 'gsl_matrix_const_view_vector_with_tda($a)';
//*****
// 08.04.06 Creating-row-and-column-views.
// Function: gsl_vector_view gsl_matrix_row (gsl_matrix * m, size_t i)
  fun gsl_matrix_row: &gsl_matrix * size -> gsl_vector_view = 'gsl_matrix_row($a)';
// Function: gsl_vector_const_view gsl_matrix_const_row (const gsl_matrix * m, size_t i)
  fun gsl_matrix_const_row: &gsl_matrix * size -> gsl_vector_const_view = 'gsl_matrix_const_row($a)';
// Function: gsl_vector_view gsl_matrix_column (gsl_matrix * m, size_t j)
  fun gsl_matrix_column: &gsl_matrix * size -> gsl_vector_view = 'gsl_matrix_column($a)';
// Function: gsl_vector_const_view gsl_matrix_const_column (const gsl_matrix * m, size_t j)
  fun gsl_matrix_const_column: &gsl_matrix * size -> gsl_vector_const_view = 'gsl_matrix_const_column($a)';
// Function: gsl_vector_view gsl_matrix_subrow (gsl_matrix * m, size_t i, size_t offset, size_t n)
  fun gsl_matrix_subrow: &gsl_matrix * size * size * size -> gsl_vector_view = 'gsl_matrix_subrow($a)';
// Function: gsl_vector_const_view gsl_matrix_const_subrow (const gsl_matrix * m, size_t i, size_t offset, size_t n)
  fun gsl_matrix_const_subrow: &gsl_matrix * size * size * size -> gsl_vector_const_view = 'gsl_matrix_const_subrow($a)';
// Function: gsl_vector_view gsl_matrix_subcolumn (gsl_matrix * m, size_t j, size_t offset, size_t n)
  fun gsl_matrix_subcolumn: &gsl_matrix * size * size * size -> gsl_vector_view = 'gsl_matrix_subcolumn($a)';
// Function: gsl_vector_const_view gsl_matrix_const_subcolumn (const gsl_matrix * m, size_t j, size_t offset, size_t n)
  fun gsl_matrix_const_subcolumn: &gsl_matrix * size * size * size -> gsl_vector_const_view = 'gsl_matrix_const_subcolumn($a)';
// Function: gsl_vector_view gsl_matrix_diagonal (gsl_matrix * m)
  fun gsl_matrix_diagonal: &gsl_matrix -> gsl_vector_view = 'gsl_matrix_diagonal($a)';
// Function: gsl_vector_const_view gsl_matrix_const_diagonal (const gsl_matrix * m)
  fun gsl_matrix_const_diagonal: &gsl_matrix -> gsl_vector_const_view = 'gsl_matrix_const_diagonal($a)';
// Function: gsl_vector_view gsl_matrix_subdiagonal (gsl_matrix * m, size_t k)
  fun gsl_matrix_subdiagonal: &gsl_matrix * size -> gsl_vector_view = 'gsl_matrix_subdiagonal($a)';
// Function: gsl_vector_const_view gsl_matrix_const_subdiagonal (const gsl_matrix * m, size_t k)
  fun gsl_matrix_const_subdiagonal: &gsl_matrix * size -> gsl_vector_const_view = 'gsl_matrix_const_subdiagonal($a)';
// Function: gsl_vector_view gsl_matrix_superdiagonal (gsl_matrix * m, size_t k)
  fun gsl_matrix_superdiagonal: &gsl_matrix * size -> gsl_vector_view = 'gsl_matrix_superdiagonal($a)';
// Function: gsl_vector_const_view gsl_matrix_const_superdiagonal (const gsl_matrix * m, size_t k)
  fun gsl_matrix_const_superdiagonal: &gsl_matrix * size -> gsl_vector_const_view = 'gsl_matrix_const_superdiagonal($a)';
//*****
// 08.04.07 Copying-matrices.
// Function: int gsl_matrix_memcpy (gsl_matrix * dest, const gsl_matrix * src)
  fun gsl_matrix_memcpy: &gsl_matrix * &gsl_matrix -> int = 'gsl_matrix_memcpy($a)';
// Function: int gsl_matrix_swap (gsl_matrix * m1, gsl_matrix * m2)
  fun gsl_matrix_swap: &gsl_matrix * &gsl_matrix -> int = 'gsl_matrix_swap($a)';
//*****
// 08.04.08 Copying-rows-and-columns.
// Function: int gsl_matrix_get_row (gsl_vector * v, const gsl_matrix * m, size_t i)
  fun gsl_matrix_get_row: &gsl_vector * &gsl_matrix * size -> int = 'gsl_matrix_get_row($a)';
// Function: int gsl_matrix_get_col (gsl_vector * v, const gsl_matrix * m, size_t j)
  fun gsl_matrix_get_col: &gsl_vector * &gsl_matrix * size -> int = 'gsl_matrix_get_col($a)';
// Function: int gsl_matrix_set_row (gsl_matrix * m, size_t i, const gsl_vector * v)
  fun gsl_matrix_set_row: &gsl_matrix * size * &gsl_vector -> int = 'gsl_matrix_set_row($a)';
// Function: int gsl_matrix_set_col (gsl_matrix * m, size_t j, const gsl_vector * v)
  fun gsl_matrix_set_col: &gsl_matrix * size * &gsl_vector -> int = 'gsl_matrix_set_col($a)';
//*****
// 08.04.09 Exchanging-rows-and-columns.
// Function: int gsl_matrix_swap_rows (gsl_matrix * m, size_t i, size_t j)
  fun gsl_matrix_swap_rows: &gsl_matrix * size * size -> int = 'gsl_matrix_swap_rows($a)';
// Function: int gsl_matrix_swap_columns (gsl_matrix * m, size_t i, size_t j)
  fun gsl_matrix_swap_columns: &gsl_matrix * size * size -> int = 'gsl_matrix_swap_columns($a)';
// Function: int gsl_matrix_swap_rowcol (gsl_matrix * m, size_t i, size_t j)
  fun gsl_matrix_swap_rowcol: &gsl_matrix * size * size -> int = 'gsl_matrix_swap_rowcol($a)';
// Function: int gsl_matrix_transpose_memcpy (gsl_matrix * dest, const gsl_matrix * src)
  fun gsl_matrix_transpose_memcpy: &gsl_matrix * &gsl_matrix -> int = 'gsl_matrix_transpose_memcpy($a)';
// Function: int gsl_matrix_transpose (gsl_matrix * m)
  fun gsl_matrix_transpose: &gsl_matrix -> int = 'gsl_matrix_transpose($a)';
//*****
// 08.04.10 Matrix-operations.
// Function: int gsl_matrix_add (gsl_matrix * a, const gsl_matrix * b)
  fun gsl_matrix_add: &gsl_matrix * &gsl_matrix -> int = 'gsl_matrix_add($a)';
// Function: int gsl_matrix_sub (gsl_matrix * a, const gsl_matrix * b)
  fun gsl_matrix_sub: &gsl_matrix * &gsl_matrix -> int = 'gsl_matrix_sub($a)';
// Function: int gsl_matrix_mul_elements (gsl_matrix * a, const gsl_matrix * b)
  fun gsl_matrix_mul_elements: &gsl_matrix * &gsl_matrix -> int = 'gsl_matrix_mul_elements($a)';
// Function: int gsl_matrix_div_elements (gsl_matrix * a, const gsl_matrix * b)
  fun gsl_matrix_div_elements: &gsl_matrix * &gsl_matrix -> int = 'gsl_matrix_div_elements($a)';
// Function: int gsl_matrix_scale (gsl_matrix * a, const double x)
  fun gsl_matrix_scale: &gsl_matrix * double -> int = 'gsl_matrix_scale($a)';
// Function: int gsl_matrix_add_constant (gsl_matrix * a, const double x)
  fun gsl_matrix_add_constant: &gsl_matrix * double -> int = 'gsl_matrix_add_constant($a)';
//*****
// 08.04.11 Finding-maximum-and-minimum-elements-of-matrices.
// Function: double gsl_matrix_max (const gsl_matrix * m)
  fun gsl_matrix_max: &gsl_matrix -> double = 'gsl_matrix_max($a)';
// Function: double gsl_matrix_min (const gsl_matrix * m)
  fun gsl_matrix_min: &gsl_matrix -> double = 'gsl_matrix_min($a)';
// Function: void gsl_matrix_minmax (const gsl_matrix * m, double * min_out, double * max_out)
  proc gsl_matrix_minmax: &gsl_matrix * &double * &double = 'gsl_matrix_minmax($a);';
// Function: void gsl_matrix_max_index (const gsl_matrix * m, size_t * imax, size_t * jmax)
  proc gsl_matrix_max_index: &gsl_matrix * &size * &size = 'gsl_matrix_max_index($a);';
// Function: void gsl_matrix_min_index (const gsl_matrix * m, size_t * imin, size_t * jmin)
  proc gsl_matrix_min_index: &gsl_matrix * &size * &size = 'gsl_matrix_min_index($a);';
// Function: void gsl_matrix_minmax_index (const gsl_matrix * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax)
  proc gsl_matrix_minmax_index: &gsl_matrix * &size * &size * &size * &size = 'gsl_matrix_minmax_index($a);';
//*****
// 08.04.12 Matrix-properties.
// Function: int gsl_matrix_isnull (const gsl_matrix * m)
  fun gsl_matrix_isnull: &gsl_matrix -> int = 'gsl_matrix_isnull($a)';
// Function: int gsl_matrix_ispos (const gsl_matrix * m)
  fun gsl_matrix_ispos: &gsl_matrix -> int = 'gsl_matrix_ispos($a)';
// Function: int gsl_matrix_isneg (const gsl_matrix * m)
  fun gsl_matrix_isneg: &gsl_matrix -> int = 'gsl_matrix_isneg($a)';
// Function: int gsl_matrix_isnonneg (const gsl_matrix * m)
  fun gsl_matrix_isnonneg: &gsl_matrix -> int = 'gsl_matrix_isnonneg($a)';
// Function: int gsl_matrix_equal (const gsl_matrix * a, const gsl_matrix * b)
  fun gsl_matrix_equal: &gsl_matrix * &gsl_matrix -> int = 'gsl_matrix_equal($a)';
//*****
// 09.00.00 Permutations.
//*****
// 09.01.00 The-Permutation-struct.
//*****
// 09.02.00 Permutation-allocation.
// Function: gsl_permutation * gsl_permutation_alloc (size_t n)
  fun gsl_permutation_alloc: size -> &gsl_permutation = 'gsl_permutation_alloc($a)';
// Function: gsl_permutation * gsl_permutation_calloc (size_t n)
  fun gsl_permutation_calloc: size -> &gsl_permutation = 'gsl_permutation_calloc($a)';
// Function: void gsl_permutation_init (gsl_permutation * p)
  proc gsl_permutation_init: &gsl_permutation = 'gsl_permutation_init($a);';
// Function: void gsl_permutation_free (gsl_permutation * p)
  proc gsl_permutation_free: &gsl_permutation = 'gsl_permutation_free($a);';
// Function: int gsl_permutation_memcpy (gsl_permutation * dest, const gsl_permutation * src)
  fun gsl_permutation_memcpy: &gsl_permutation * &gsl_permutation -> int = 'gsl_permutation_memcpy($a)';
//*****
// 09.03.00 Accessing-permutation-elements.
// Function: size_t gsl_permutation_get (const gsl_permutation * p, const size_t i)
  fun gsl_permutation_get: &gsl_permutation * size -> size = 'gsl_permutation_get($a)';
// Function: int gsl_permutation_swap (gsl_permutation * p, const size_t i, const size_t j)
  fun gsl_permutation_swap: &gsl_permutation * size * size -> int = 'gsl_permutation_swap($a)';
//*****
// 09.04.00 Permutation-properties.
// Function: size_t gsl_permutation_size (const gsl_permutation * p)
  fun gsl_permutation_size: &gsl_permutation -> size = 'gsl_permutation_size($a)';
// Function: size_t * gsl_permutation_data (const gsl_permutation * p)
  fun gsl_permutation_data: &gsl_permutation -> &size = 'gsl_permutation_data($a)';
// Function: int gsl_permutation_valid (const gsl_permutation * p)
  fun gsl_permutation_valid: &gsl_permutation -> int = 'gsl_permutation_valid($a)';
//*****
// 09.05.00 Permutation-functions.
// Function: void gsl_permutation_reverse (gsl_permutation * p)
  proc gsl_permutation_reverse: &gsl_permutation = 'gsl_permutation_reverse($a);';
// Function: int gsl_permutation_inverse (gsl_permutation * inv, const gsl_permutation * p)
  fun gsl_permutation_inverse: &gsl_permutation * &gsl_permutation -> int = 'gsl_permutation_inverse($a)';
// Function: int gsl_permutation_next (gsl_permutation * p)
  fun gsl_permutation_next: &gsl_permutation -> int = 'gsl_permutation_next($a)';
// Function: int gsl_permutation_prev (gsl_permutation * p)
  fun gsl_permutation_prev: &gsl_permutation -> int = 'gsl_permutation_prev($a)';
//*****
// 09.06.00 Applying-Permutations.
// Function: int gsl_permute (const size_t * p, double * data, size_t stride, size_t n)
  fun gsl_permute: &size * &double * size * size -> int = 'gsl_permute($a)';
// Function: int gsl_permute_inverse (const size_t * p, double * data, size_t stride, size_t n)
  fun gsl_permute_inverse: &size * &double * size * size -> int = 'gsl_permute_inverse($a)';
// Function: int gsl_permute_vector (const gsl_permutation * p, gsl_vector * v)
  fun gsl_permute_vector: &gsl_permutation * &gsl_vector -> int = 'gsl_permute_vector($a)';
// Function: int gsl_permute_vector_inverse (const gsl_permutation * p, gsl_vector * v)
  fun gsl_permute_vector_inverse: &gsl_permutation * &gsl_vector -> int = 'gsl_permute_vector_inverse($a)';
// Function: int gsl_permutation_mul (gsl_permutation * p, const gsl_permutation * pa, const gsl_permutation * pb)
  fun gsl_permutation_mul: &gsl_permutation * &gsl_permutation * &gsl_permutation -> int = 'gsl_permutation_mul($a)';
//*****
// 09.07.00 Reading-and-writing-permutations.
// Function: int gsl_permutation_fwrite (FILE * stream, const gsl_permutation * p)
  fun gsl_permutation_fwrite: &FILE * &gsl_permutation -> int = 'gsl_permutation_fwrite($a)';
// Function: int gsl_permutation_fread (FILE * stream, gsl_permutation * p)
  fun gsl_permutation_fread: &FILE * &gsl_permutation -> int = 'gsl_permutation_fread($a)';
// Function: int gsl_permutation_fprintf (FILE * stream, const gsl_permutation * p, const char * format)
  fun gsl_permutation_fprintf: &FILE * &gsl_permutation * &char -> int = 'gsl_permutation_fprintf($a)';
// Function: int gsl_permutation_fscanf (FILE * stream, gsl_permutation * p)
  fun gsl_permutation_fscanf: &FILE * &gsl_permutation -> int = 'gsl_permutation_fscanf($a)';
//*****
// 09.08.00 Permutations-in-cyclic-form.
// Function: int gsl_permutation_linear_to_canonical (gsl_permutation * q, const gsl_permutation * p)
  fun gsl_permutation_linear_to_canonical: &gsl_permutation * &gsl_permutation -> int = 'gsl_permutation_linear_to_canonical($a)';
// Function: int gsl_permutation_canonical_to_linear (gsl_permutation * p, const gsl_permutation * q)
  fun gsl_permutation_canonical_to_linear: &gsl_permutation * &gsl_permutation -> int = 'gsl_permutation_canonical_to_linear($a)';
// Function: size_t gsl_permutation_inversions (const gsl_permutation * p)
  fun gsl_permutation_inversions: &gsl_permutation -> size = 'gsl_permutation_inversions($a)';
// Function: size_t gsl_permutation_linear_cycles (const gsl_permutation * p)
  fun gsl_permutation_linear_cycles: &gsl_permutation -> size = 'gsl_permutation_linear_cycles($a)';
// Function: size_t gsl_permutation_canonical_cycles (const gsl_permutation * q)
  fun gsl_permutation_canonical_cycles: &gsl_permutation -> size = 'gsl_permutation_canonical_cycles($a)';
//*****
// 10.00.00 Combinations.
//*****
// 10.01.00 The-Combination-struct.
//*****
// 10.02.00 Combination-allocation.
// Function: gsl_combination * gsl_combination_alloc (size_t n, size_t k)
  fun gsl_combination_alloc: size * size -> &gsl_combination = 'gsl_combination_alloc($a)';
// Function: gsl_combination * gsl_combination_calloc (size_t n, size_t k)
  fun gsl_combination_calloc: size * size -> &gsl_combination = 'gsl_combination_calloc($a)';
// Function: void gsl_combination_init_first (gsl_combination * c)
  proc gsl_combination_init_first: &gsl_combination = 'gsl_combination_init_first($a);';
// Function: void gsl_combination_init_last (gsl_combination * c)
  proc gsl_combination_init_last: &gsl_combination = 'gsl_combination_init_last($a);';
// Function: void gsl_combination_free (gsl_combination * c)
  proc gsl_combination_free: &gsl_combination = 'gsl_combination_free($a);';
// Function: int gsl_combination_memcpy (gsl_combination * dest, const gsl_combination * src)
  fun gsl_combination_memcpy: &gsl_combination * &gsl_combination -> int = 'gsl_combination_memcpy($a)';
//*****
// 10.03.00 Accessing-combination-elements.
// Function: size_t gsl_combination_get (const gsl_combination * c, const size_t i)
  fun gsl_combination_get: &gsl_combination * size -> size = 'gsl_combination_get($a)';
//*****
// 10.04.00 Combination-properties.
// Function: size_t gsl_combination_n (const gsl_combination * c)
  fun gsl_combination_n: &gsl_combination -> size = 'gsl_combination_n($a)';
// Function: size_t gsl_combination_k (const gsl_combination * c)
  fun gsl_combination_k: &gsl_combination -> size = 'gsl_combination_k($a)';
// Function: size_t * gsl_combination_data (const gsl_combination * c)
  fun gsl_combination_data: &gsl_combination -> &size = 'gsl_combination_data($a)';
// Function: int gsl_combination_valid (gsl_combination * c)
  fun gsl_combination_valid: &gsl_combination -> int = 'gsl_combination_valid($a)';
//*****
// 10.05.00 Combination-functions.
// Function: int gsl_combination_next (gsl_combination * c)
  fun gsl_combination_next: &gsl_combination -> int = 'gsl_combination_next($a)';
// Function: int gsl_combination_prev (gsl_combination * c)
  fun gsl_combination_prev: &gsl_combination -> int = 'gsl_combination_prev($a)';
//*****
// 10.06.00 Reading-and-writing-combinations.
// Function: int gsl_combination_fwrite (FILE * stream, const gsl_combination * c)
  fun gsl_combination_fwrite: &FILE * &gsl_combination -> int = 'gsl_combination_fwrite($a)';
// Function: int gsl_combination_fread (FILE * stream, gsl_combination * c)
  fun gsl_combination_fread: &FILE * &gsl_combination -> int = 'gsl_combination_fread($a)';
// Function: int gsl_combination_fprintf (FILE * stream, const gsl_combination * c, const char * format)
  fun gsl_combination_fprintf: &FILE * &gsl_combination * &char -> int = 'gsl_combination_fprintf($a)';
// Function: int gsl_combination_fscanf (FILE * stream, gsl_combination * c)
  fun gsl_combination_fscanf: &FILE * &gsl_combination -> int = 'gsl_combination_fscanf($a)';
//*****
// 11.00.00 Multisets.
//*****
// 11.01.00 The-Multiset-struct.
//*****
// 11.02.00 Multiset-allocation.
// Function: gsl_multiset * gsl_multiset_alloc (size_t n, size_t k)
  fun gsl_multiset_alloc: size * size -> &gsl_multiset = 'gsl_multiset_alloc($a)';
// Function: gsl_multiset * gsl_multiset_calloc (size_t n, size_t k)
  fun gsl_multiset_calloc: size * size -> &gsl_multiset = 'gsl_multiset_calloc($a)';
// Function: void gsl_multiset_init_first (gsl_multiset * c)
  proc gsl_multiset_init_first: &gsl_multiset = 'gsl_multiset_init_first($a);';
// Function: void gsl_multiset_init_last (gsl_multiset * c)
  proc gsl_multiset_init_last: &gsl_multiset = 'gsl_multiset_init_last($a);';
// Function: void gsl_multiset_free (gsl_multiset * c)
  proc gsl_multiset_free: &gsl_multiset = 'gsl_multiset_free($a);';
// Function: int gsl_multiset_memcpy (gsl_multiset * dest, const gsl_multiset * src)
  fun gsl_multiset_memcpy: &gsl_multiset * &gsl_multiset -> int = 'gsl_multiset_memcpy($a)';
//*****
// 11.03.00 Accessing-multiset-elements.
// Function: size_t gsl_multiset_get (const gsl_multiset * c, const size_t i)
  fun gsl_multiset_get: &gsl_multiset * size -> size = 'gsl_multiset_get($a)';
//*****
// 11.04.00 Multiset-properties.
// Function: size_t gsl_multiset_n (const gsl_multiset * c)
  fun gsl_multiset_n: &gsl_multiset -> size = 'gsl_multiset_n($a)';
// Function: size_t gsl_multiset_k (const gsl_multiset * c)
  fun gsl_multiset_k: &gsl_multiset -> size = 'gsl_multiset_k($a)';
// Function: size_t * gsl_multiset_data (const gsl_multiset * c)
  fun gsl_multiset_data: &gsl_multiset -> &size = 'gsl_multiset_data($a)';
// Function: int gsl_multiset_valid (gsl_multiset * c)
  fun gsl_multiset_valid: &gsl_multiset -> int = 'gsl_multiset_valid($a)';
//*****
// 11.05.00 Multiset-functions.
// Function: int gsl_multiset_next (gsl_multiset * c)
  fun gsl_multiset_next: &gsl_multiset -> int = 'gsl_multiset_next($a)';
// Function: int gsl_multiset_prev (gsl_multiset * c)
  fun gsl_multiset_prev: &gsl_multiset -> int = 'gsl_multiset_prev($a)';
//*****
// 11.06.00 Reading-and-writing-multisets.
// Function: int gsl_multiset_fwrite (FILE * stream, const gsl_multiset * c)
  fun gsl_multiset_fwrite: &FILE * &gsl_multiset -> int = 'gsl_multiset_fwrite($a)';
// Function: int gsl_multiset_fread (FILE * stream, gsl_multiset * c)
  fun gsl_multiset_fread: &FILE * &gsl_multiset -> int = 'gsl_multiset_fread($a)';
// Function: int gsl_multiset_fprintf (FILE * stream, const gsl_multiset * c, const char * format)
  fun gsl_multiset_fprintf: &FILE * &gsl_multiset * &char -> int = 'gsl_multiset_fprintf($a)';
// Function: int gsl_multiset_fscanf (FILE * stream, gsl_multiset * c)
  fun gsl_multiset_fscanf: &FILE * &gsl_multiset -> int = 'gsl_multiset_fscanf($a)';
//*****
// 12.00.00 Sorting.
//*****
// 12.01.00 Sorting-objects.
// Function: void gsl_heapsort (void * array, size_t count, size_t size, gsl_comparison_fn_t compare)
  proc gsl_heapsort: &void * size * size * gsl_comparison_fn_t = 'gsl_heapsort($a);';
// Function: int gsl_heapsort_index (size_t * p, const void * array, size_t count, size_t size, gsl_comparison_fn_t compare)
  fun gsl_heapsort_index: &size * &void * size * size * gsl_comparison_fn_t -> int = 'gsl_heapsort_index($a)';
//*****
// 12.02.00 Sorting-vectors.
// Function: void gsl_sort (double * data, const size_t stride, size_t n)
  proc gsl_sort: &double * size * size = 'gsl_sort($a);';
// Function: void gsl_sort2 (double * data1, const size_t stride1, double * data2, const size_t stride2, size_t n)
  proc gsl_sort2: &double * size * &double * size * size = 'gsl_sort2($a);';
// Function: void gsl_sort_vector (gsl_vector * v)
  proc gsl_sort_vector: &gsl_vector = 'gsl_sort_vector($a);';
// Function: void gsl_sort_vector2 (gsl_vector * v1, gsl_vector * v2)
  proc gsl_sort_vector2: &gsl_vector * &gsl_vector = 'gsl_sort_vector2($a);';
// Function: void gsl_sort_index (size_t * p, const double * data, size_t stride, size_t n)
  proc gsl_sort_index: &size * &double * size * size = 'gsl_sort_index($a);';
// Function: int gsl_sort_vector_index (gsl_permutation * p, const gsl_vector * v)
  fun gsl_sort_vector_index: &gsl_permutation * &gsl_vector -> int = 'gsl_sort_vector_index($a)';
//*****
// 12.03.00 Selecting-the-k-smallest-or-largest-elements.
// Function: int gsl_sort_smallest (double * dest, size_t k, const double * src, size_t stride, size_t n)
  fun gsl_sort_smallest: &double * size * &double * size * size -> int = 'gsl_sort_smallest($a)';
// Function: int gsl_sort_largest (double * dest, size_t k, const double * src, size_t stride, size_t n)
  fun gsl_sort_largest: &double * size * &double * size * size -> int = 'gsl_sort_largest($a)';
// Function: int gsl_sort_vector_smallest (double * dest, size_t k, const gsl_vector * v)
  fun gsl_sort_vector_smallest: &double * size * &gsl_vector -> int = 'gsl_sort_vector_smallest($a)';
// Function: int gsl_sort_vector_largest (double * dest, size_t k, const gsl_vector * v)
  fun gsl_sort_vector_largest: &double * size * &gsl_vector -> int = 'gsl_sort_vector_largest($a)';
// Function: int gsl_sort_smallest_index (size_t * p, size_t k, const double * src, size_t stride, size_t n)
  fun gsl_sort_smallest_index: &size * size * &double * size * size -> int = 'gsl_sort_smallest_index($a)';
// Function: int gsl_sort_largest_index (size_t * p, size_t k, const double * src, size_t stride, size_t n)
  fun gsl_sort_largest_index: &size * size * &double * size * size -> int = 'gsl_sort_largest_index($a)';
// Function: int gsl_sort_vector_smallest_index (size_t * p, size_t k, const gsl_vector * v)
  fun gsl_sort_vector_smallest_index: &size * size * &gsl_vector -> int = 'gsl_sort_vector_smallest_index($a)';
// Function: int gsl_sort_vector_largest_index (size_t * p, size_t k, const gsl_vector * v)
  fun gsl_sort_vector_largest_index: &size * size * &gsl_vector -> int = 'gsl_sort_vector_largest_index($a)';
//*****
// 13.00.00 BLAS-Support.
//*****
// 13.01.00 GSL-BLAS-Interface.
//*****
// 13.01.01 GSL-BLAS-Level-1.
// Function: int gsl_blas_sdsdot (float alpha, const gsl_vector_float * x, const gsl_vector_float * y, float * result)
  fun gsl_blas_sdsdot: float * &gsl_vector_float * &gsl_vector_float * &float -> int = 'gsl_blas_sdsdot($a)';
// Function: int gsl_blas_sdot (const gsl_vector_float * x, const gsl_vector_float * y, float * result)
  fun gsl_blas_sdot: &gsl_vector_float * &gsl_vector_float * &float -> int = 'gsl_blas_sdot($a)';
// Function: int gsl_blas_dsdot (const gsl_vector_float * x, const gsl_vector_float * y, double * result)
  fun gsl_blas_dsdot: &gsl_vector_float * &gsl_vector_float * &double -> int = 'gsl_blas_dsdot($a)';
// Function: int gsl_blas_ddot (const gsl_vector * x, const gsl_vector * y, double * result)
  fun gsl_blas_ddot: &gsl_vector * &gsl_vector * &double -> int = 'gsl_blas_ddot($a)';
// Function: int gsl_blas_cdotu (const gsl_vector_complex_float * x, const gsl_vector_complex_float * y, gsl_complex_float * dotu)
  fun gsl_blas_cdotu: &gsl_vector_complex_float * &gsl_vector_complex_float * &gsl_complex_float -> int = 'gsl_blas_cdotu($a)';
// Function: int gsl_blas_zdotu (const gsl_vector_complex * x, const gsl_vector_complex * y, gsl_complex * dotu)
  fun gsl_blas_zdotu: &gsl_vector_complex * &gsl_vector_complex * &gsl_complex -> int = 'gsl_blas_zdotu($a)';
// Function: int gsl_blas_cdotc (const gsl_vector_complex_float * x, const gsl_vector_complex_float * y, gsl_complex_float * dotc)
  fun gsl_blas_cdotc: &gsl_vector_complex_float * &gsl_vector_complex_float * &gsl_complex_float -> int = 'gsl_blas_cdotc($a)';
// Function: int gsl_blas_zdotc (const gsl_vector_complex * x, const gsl_vector_complex * y, gsl_complex * dotc)
  fun gsl_blas_zdotc: &gsl_vector_complex * &gsl_vector_complex * &gsl_complex -> int = 'gsl_blas_zdotc($a)';
// Function: float gsl_blas_snrm2 (const gsl_vector_float * x)
  fun gsl_blas_snrm2: &gsl_vector_float -> float = 'gsl_blas_snrm2($a)';
// Function: double gsl_blas_dnrm2 (const gsl_vector * x)
  fun gsl_blas_dnrm2: &gsl_vector -> double = 'gsl_blas_dnrm2($a)';
// Function: float gsl_blas_scnrm2 (const gsl_vector_complex_float * x)
  fun gsl_blas_scnrm2: &gsl_vector_complex_float -> float = 'gsl_blas_scnrm2($a)';
// Function: double gsl_blas_dznrm2 (const gsl_vector_complex * x)
  fun gsl_blas_dznrm2: &gsl_vector_complex -> double = 'gsl_blas_dznrm2($a)';
// Function: float gsl_blas_sasum (const gsl_vector_float * x)
  fun gsl_blas_sasum: &gsl_vector_float -> float = 'gsl_blas_sasum($a)';
// Function: double gsl_blas_dasum (const gsl_vector * x)
  fun gsl_blas_dasum: &gsl_vector -> double = 'gsl_blas_dasum($a)';
// Function: float gsl_blas_scasum (const gsl_vector_complex_float * x)
  fun gsl_blas_scasum: &gsl_vector_complex_float -> float = 'gsl_blas_scasum($a)';
// Function: double gsl_blas_dzasum (const gsl_vector_complex * x)
  fun gsl_blas_dzasum: &gsl_vector_complex -> double = 'gsl_blas_dzasum($a)';
// Function: CBLAS_INDEX_t gsl_blas_isamax (const gsl_vector_float * x)
  fun gsl_blas_isamax: &gsl_vector_float -> CBLAS_INDEX_t = 'gsl_blas_isamax($a)';
// Function: CBLAS_INDEX_t gsl_blas_idamax (const gsl_vector * x)
  fun gsl_blas_idamax: &gsl_vector -> CBLAS_INDEX_t = 'gsl_blas_idamax($a)';
// Function: CBLAS_INDEX_t gsl_blas_icamax (const gsl_vector_complex_float * x)
  fun gsl_blas_icamax: &gsl_vector_complex_float -> CBLAS_INDEX_t = 'gsl_blas_icamax($a)';
// Function: CBLAS_INDEX_t gsl_blas_izamax (const gsl_vector_complex * x)
  fun gsl_blas_izamax: &gsl_vector_complex -> CBLAS_INDEX_t = 'gsl_blas_izamax($a)';
// Function: int gsl_blas_sswap (gsl_vector_float * x, gsl_vector_float * y)
  fun gsl_blas_sswap: &gsl_vector_float * &gsl_vector_float -> int = 'gsl_blas_sswap($a)';
// Function: int gsl_blas_dswap (gsl_vector * x, gsl_vector * y)
  fun gsl_blas_dswap: &gsl_vector * &gsl_vector -> int = 'gsl_blas_dswap($a)';
// Function: int gsl_blas_cswap (gsl_vector_complex_float * x, gsl_vector_complex_float * y)
  fun gsl_blas_cswap: &gsl_vector_complex_float * &gsl_vector_complex_float -> int = 'gsl_blas_cswap($a)';
// Function: int gsl_blas_zswap (gsl_vector_complex * x, gsl_vector_complex * y)
  fun gsl_blas_zswap: &gsl_vector_complex * &gsl_vector_complex -> int = 'gsl_blas_zswap($a)';
// Function: int gsl_blas_scopy (const gsl_vector_float * x, gsl_vector_float * y)
  fun gsl_blas_scopy: &gsl_vector_float * &gsl_vector_float -> int = 'gsl_blas_scopy($a)';
// Function: int gsl_blas_dcopy (const gsl_vector * x, gsl_vector * y)
  fun gsl_blas_dcopy: &gsl_vector * &gsl_vector -> int = 'gsl_blas_dcopy($a)';
// Function: int gsl_blas_ccopy (const gsl_vector_complex_float * x, gsl_vector_complex_float * y)
  fun gsl_blas_ccopy: &gsl_vector_complex_float * &gsl_vector_complex_float -> int = 'gsl_blas_ccopy($a)';
// Function: int gsl_blas_zcopy (const gsl_vector_complex * x, gsl_vector_complex * y)
  fun gsl_blas_zcopy: &gsl_vector_complex * &gsl_vector_complex -> int = 'gsl_blas_zcopy($a)';
// Function: int gsl_blas_saxpy (float alpha, const gsl_vector_float * x, gsl_vector_float * y)
  fun gsl_blas_saxpy: float * &gsl_vector_float * &gsl_vector_float -> int = 'gsl_blas_saxpy($a)';
// Function: int gsl_blas_daxpy (double alpha, const gsl_vector * x, gsl_vector * y)
  fun gsl_blas_daxpy: double * &gsl_vector * &gsl_vector -> int = 'gsl_blas_daxpy($a)';
// Function: int gsl_blas_caxpy (const gsl_complex_float alpha, const gsl_vector_complex_float * x, gsl_vector_complex_float * y)
  fun gsl_blas_caxpy: gsl_complex_float * &gsl_vector_complex_float * &gsl_vector_complex_float -> int = 'gsl_blas_caxpy($a)';
// Function: int gsl_blas_zaxpy (const gsl_complex alpha, const gsl_vector_complex * x, gsl_vector_complex * y)
  fun gsl_blas_zaxpy: gsl_complex * &gsl_vector_complex * &gsl_vector_complex -> int = 'gsl_blas_zaxpy($a)';
// Function: void gsl_blas_sscal (float alpha, gsl_vector_float * x)
  proc gsl_blas_sscal: float * &gsl_vector_float = 'gsl_blas_sscal($a);';
// Function: void gsl_blas_dscal (double alpha, gsl_vector * x)
  proc gsl_blas_dscal: double * &gsl_vector = 'gsl_blas_dscal($a);';
// Function: void gsl_blas_cscal (const gsl_complex_float alpha, gsl_vector_complex_float * x)
  proc gsl_blas_cscal: gsl_complex_float * &gsl_vector_complex_float = 'gsl_blas_cscal($a);';
// Function: void gsl_blas_zscal (const gsl_complex alpha, gsl_vector_complex * x)
  proc gsl_blas_zscal: gsl_complex * &gsl_vector_complex = 'gsl_blas_zscal($a);';
// Function: void gsl_blas_csscal (float alpha, gsl_vector_complex_float * x)
  proc gsl_blas_csscal: float * &gsl_vector_complex_float = 'gsl_blas_csscal($a);';
// Function: void gsl_blas_zdscal (double alpha, gsl_vector_complex * x)
  proc gsl_blas_zdscal: double * &gsl_vector_complex = 'gsl_blas_zdscal($a);';
// Function: int gsl_blas_srotg (float a[], float b[], float c[], float s[])
  fun gsl_blas_srotg: +float * +float * +float * +float -> int = 'gsl_blas_srotg($a)';
// Function: int gsl_blas_drotg (double a[], double b[], double c[], double s[])
  fun gsl_blas_drotg: +double * +double * +double * +double -> int = 'gsl_blas_drotg($a)';
// Function: int gsl_blas_srot (gsl_vector_float * x, gsl_vector_float * y, float c, float s)
  fun gsl_blas_srot: &gsl_vector_float * &gsl_vector_float * float * float -> int = 'gsl_blas_srot($a)';
// Function: int gsl_blas_drot (gsl_vector * x, gsl_vector * y, const double c, const double s)
  fun gsl_blas_drot: &gsl_vector * &gsl_vector * double * double -> int = 'gsl_blas_drot($a)';
// Function: int gsl_blas_srotmg (float d1[], float d2[], float b1[], float b2, float P[])
  fun gsl_blas_srotmg: +float * +float * +float * float * +float -> int = 'gsl_blas_srotmg($a)';
// Function: int gsl_blas_drotmg (double d1[], double d2[], double b1[], double b2, double P[])
  fun gsl_blas_drotmg: +double * +double * +double * double * +double -> int = 'gsl_blas_drotmg($a)';
// Function: int gsl_blas_srotm (gsl_vector_float * x, gsl_vector_float * y, const float P[])
  fun gsl_blas_srotm: &gsl_vector_float * &gsl_vector_float * +float -> int = 'gsl_blas_srotm($a)';
// Function: int gsl_blas_drotm (gsl_vector * x, gsl_vector * y, const double P[])
  fun gsl_blas_drotm: &gsl_vector * &gsl_vector * +double -> int = 'gsl_blas_drotm($a)';
//*****
// 13.01.02 GSL-BLAS-Level-2.
// Function: int gsl_blas_sgemv (CBLAS_TRANSPOSE_t TransA, float alpha, const gsl_matrix_float * A, const gsl_vector_float * x, float beta, gsl_vector_float * y)
  fun gsl_blas_sgemv: CBLAS_TRANSPOSE_t * float * &gsl_matrix_float * &gsl_vector_float * float * &gsl_vector_float -> int = 'gsl_blas_sgemv($a)';
// Function: int gsl_blas_dgemv (CBLAS_TRANSPOSE_t TransA, double alpha, const gsl_matrix * A, const gsl_vector * x, double beta, gsl_vector * y)
  fun gsl_blas_dgemv: CBLAS_TRANSPOSE_t * double * &gsl_matrix * &gsl_vector * double * &gsl_vector -> int = 'gsl_blas_dgemv($a)';
// Function: int gsl_blas_cgemv (CBLAS_TRANSPOSE_t TransA, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_vector_complex_float * x, const gsl_complex_float beta, gsl_vector_complex_float * y)
  fun gsl_blas_cgemv: CBLAS_TRANSPOSE_t * gsl_complex_float * &gsl_matrix_complex_float * &gsl_vector_complex_float * gsl_complex_float * &gsl_vector_complex_float -> int = 'gsl_blas_cgemv($a)';
// Function: int gsl_blas_zgemv (CBLAS_TRANSPOSE_t TransA, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_vector_complex * x, const gsl_complex beta, gsl_vector_complex * y)
  fun gsl_blas_zgemv: CBLAS_TRANSPOSE_t * gsl_complex * &gsl_matrix_complex * &gsl_vector_complex * gsl_complex * &gsl_vector_complex -> int = 'gsl_blas_zgemv($a)';
// Function: int gsl_blas_strmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_float * A, gsl_vector_float * x)
  fun gsl_blas_strmv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * &gsl_matrix_float * &gsl_vector_float -> int = 'gsl_blas_strmv($a)';
// Function: int gsl_blas_dtrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * x)
  fun gsl_blas_dtrmv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * &gsl_matrix * &gsl_vector -> int = 'gsl_blas_dtrmv($a)';
// Function: int gsl_blas_ctrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_complex_float * A, gsl_vector_complex_float * x)
  fun gsl_blas_ctrmv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * &gsl_matrix_complex_float * &gsl_vector_complex_float -> int = 'gsl_blas_ctrmv($a)';
// Function: int gsl_blas_ztrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_complex * A, gsl_vector_complex * x)
  fun gsl_blas_ztrmv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * &gsl_matrix_complex * &gsl_vector_complex -> int = 'gsl_blas_ztrmv($a)';
// Function: int gsl_blas_strsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_float * A, gsl_vector_float * x)
  fun gsl_blas_strsv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * &gsl_matrix_float * &gsl_vector_float -> int = 'gsl_blas_strsv($a)';
// Function: int gsl_blas_dtrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * x)
  fun gsl_blas_dtrsv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * &gsl_matrix * &gsl_vector -> int = 'gsl_blas_dtrsv($a)';
// Function: int gsl_blas_ctrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_complex_float * A, gsl_vector_complex_float * x)
  fun gsl_blas_ctrsv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * &gsl_matrix_complex_float * &gsl_vector_complex_float -> int = 'gsl_blas_ctrsv($a)';
// Function: int gsl_blas_ztrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_matrix_complex * A, gsl_vector_complex * x)
  fun gsl_blas_ztrsv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * &gsl_matrix_complex * &gsl_vector_complex -> int = 'gsl_blas_ztrsv($a)';
// Function: int gsl_blas_ssymv (CBLAS_UPLO_t Uplo, float alpha, const gsl_matrix_float * A, const gsl_vector_float * x, float beta, gsl_vector_float * y)
  fun gsl_blas_ssymv: CBLAS_UPLO_t * float * &gsl_matrix_float * &gsl_vector_float * float * &gsl_vector_float -> int = 'gsl_blas_ssymv($a)';
// Function: int gsl_blas_dsymv (CBLAS_UPLO_t Uplo, double alpha, const gsl_matrix * A, const gsl_vector * x, double beta, gsl_vector * y)
  fun gsl_blas_dsymv: CBLAS_UPLO_t * double * &gsl_matrix * &gsl_vector * double * &gsl_vector -> int = 'gsl_blas_dsymv($a)';
// Function: int gsl_blas_chemv (CBLAS_UPLO_t Uplo, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_vector_complex_float * x, const gsl_complex_float beta, gsl_vector_complex_float * y)
  fun gsl_blas_chemv: CBLAS_UPLO_t * gsl_complex_float * &gsl_matrix_complex_float * &gsl_vector_complex_float * gsl_complex_float * &gsl_vector_complex_float -> int = 'gsl_blas_chemv($a)';
// Function: int gsl_blas_zhemv (CBLAS_UPLO_t Uplo, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_vector_complex * x, const gsl_complex beta, gsl_vector_complex * y)
  fun gsl_blas_zhemv: CBLAS_UPLO_t * gsl_complex * &gsl_matrix_complex * &gsl_vector_complex * gsl_complex * &gsl_vector_complex -> int = 'gsl_blas_zhemv($a)';
// Function: int gsl_blas_sger (float alpha, const gsl_vector_float * x, const gsl_vector_float * y, gsl_matrix_float * A)
  fun gsl_blas_sger: float * &gsl_vector_float * &gsl_vector_float * &gsl_matrix_float -> int = 'gsl_blas_sger($a)';
// Function: int gsl_blas_dger (double alpha, const gsl_vector * x, const gsl_vector * y, gsl_matrix * A)
  fun gsl_blas_dger: double * &gsl_vector * &gsl_vector * &gsl_matrix -> int = 'gsl_blas_dger($a)';
// Function: int gsl_blas_cgeru (const gsl_complex_float alpha, const gsl_vector_complex_float * x, const gsl_vector_complex_float * y, gsl_matrix_complex_float * A)
  fun gsl_blas_cgeru: gsl_complex_float * &gsl_vector_complex_float * &gsl_vector_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_cgeru($a)';
// Function: int gsl_blas_zgeru (const gsl_complex alpha, const gsl_vector_complex * x, const gsl_vector_complex * y, gsl_matrix_complex * A)
  fun gsl_blas_zgeru: gsl_complex * &gsl_vector_complex * &gsl_vector_complex * &gsl_matrix_complex -> int = 'gsl_blas_zgeru($a)';
// Function: int gsl_blas_cgerc (const gsl_complex_float alpha, const gsl_vector_complex_float * x, const gsl_vector_complex_float * y, gsl_matrix_complex_float * A)
  fun gsl_blas_cgerc: gsl_complex_float * &gsl_vector_complex_float * &gsl_vector_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_cgerc($a)';
// Function: int gsl_blas_zgerc (const gsl_complex alpha, const gsl_vector_complex * x, const gsl_vector_complex * y, gsl_matrix_complex * A)
  fun gsl_blas_zgerc: gsl_complex * &gsl_vector_complex * &gsl_vector_complex * &gsl_matrix_complex -> int = 'gsl_blas_zgerc($a)';
// Function: int gsl_blas_ssyr (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_float * x, gsl_matrix_float * A)
  fun gsl_blas_ssyr: CBLAS_UPLO_t * float * &gsl_vector_float * &gsl_matrix_float -> int = 'gsl_blas_ssyr($a)';
// Function: int gsl_blas_dsyr (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector * x, gsl_matrix * A)
  fun gsl_blas_dsyr: CBLAS_UPLO_t * double * &gsl_vector * &gsl_matrix -> int = 'gsl_blas_dsyr($a)';
// Function: int gsl_blas_cher (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_complex_float * x, gsl_matrix_complex_float * A)
  fun gsl_blas_cher: CBLAS_UPLO_t * float * &gsl_vector_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_cher($a)';
// Function: int gsl_blas_zher (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector_complex * x, gsl_matrix_complex * A)
  fun gsl_blas_zher: CBLAS_UPLO_t * double * &gsl_vector_complex * &gsl_matrix_complex -> int = 'gsl_blas_zher($a)';
// Function: int gsl_blas_ssyr2 (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_float * x, const gsl_vector_float * y, gsl_matrix_float * A)
  fun gsl_blas_ssyr2: CBLAS_UPLO_t * float * &gsl_vector_float * &gsl_vector_float * &gsl_matrix_float -> int = 'gsl_blas_ssyr2($a)';
// Function: int gsl_blas_dsyr2 (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector * x, const gsl_vector * y, gsl_matrix * A)
  fun gsl_blas_dsyr2: CBLAS_UPLO_t * double * &gsl_vector * &gsl_vector * &gsl_matrix -> int = 'gsl_blas_dsyr2($a)';
// Function: int gsl_blas_cher2 (CBLAS_UPLO_t Uplo, const gsl_complex_float alpha, const gsl_vector_complex_float * x, const gsl_vector_complex_float * y, gsl_matrix_complex_float * A)
  fun gsl_blas_cher2: CBLAS_UPLO_t * gsl_complex_float * &gsl_vector_complex_float * &gsl_vector_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_cher2($a)';
// Function: int gsl_blas_zher2 (CBLAS_UPLO_t Uplo, const gsl_complex alpha, const gsl_vector_complex * x, const gsl_vector_complex * y, gsl_matrix_complex * A)
  fun gsl_blas_zher2: CBLAS_UPLO_t * gsl_complex * &gsl_vector_complex * &gsl_vector_complex * &gsl_matrix_complex -> int = 'gsl_blas_zher2($a)';
//*****
// 13.01.03 GSL-BLAS-Level-3.
// Function: int gsl_blas_sgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB, float alpha, const gsl_matrix_float * A, const gsl_matrix_float * B, float beta, gsl_matrix_float * C)
  fun gsl_blas_sgemm: CBLAS_TRANSPOSE_t * CBLAS_TRANSPOSE_t * float * &gsl_matrix_float * &gsl_matrix_float * float * &gsl_matrix_float -> int = 'gsl_blas_sgemm($a)';
// Function: int gsl_blas_dgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB, double alpha, const gsl_matrix * A, const gsl_matrix * B, double beta, gsl_matrix * C)
  fun gsl_blas_dgemm: CBLAS_TRANSPOSE_t * CBLAS_TRANSPOSE_t * double * &gsl_matrix * &gsl_matrix * double * &gsl_matrix -> int = 'gsl_blas_dgemm($a)';
// Function: int gsl_blas_cgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_matrix_complex_float * B, const gsl_complex_float beta, gsl_matrix_complex_float * C)
  fun gsl_blas_cgemm: CBLAS_TRANSPOSE_t * CBLAS_TRANSPOSE_t * gsl_complex_float * &gsl_matrix_complex_float * &gsl_matrix_complex_float * gsl_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_cgemm($a)';
// Function: int gsl_blas_zgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_matrix_complex * B, const gsl_complex beta, gsl_matrix_complex * C)
  fun gsl_blas_zgemm: CBLAS_TRANSPOSE_t * CBLAS_TRANSPOSE_t * gsl_complex * &gsl_matrix_complex * &gsl_matrix_complex * gsl_complex * &gsl_matrix_complex -> int = 'gsl_blas_zgemm($a)';
// Function: int gsl_blas_ssymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, float alpha, const gsl_matrix_float * A, const gsl_matrix_float * B, float beta, gsl_matrix_float * C)
  fun gsl_blas_ssymm: CBLAS_SIDE_t * CBLAS_UPLO_t * float * &gsl_matrix_float * &gsl_matrix_float * float * &gsl_matrix_float -> int = 'gsl_blas_ssymm($a)';
// Function: int gsl_blas_dsymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, double alpha, const gsl_matrix * A, const gsl_matrix * B, double beta, gsl_matrix * C)
  fun gsl_blas_dsymm: CBLAS_SIDE_t * CBLAS_UPLO_t * double * &gsl_matrix * &gsl_matrix * double * &gsl_matrix -> int = 'gsl_blas_dsymm($a)';
// Function: int gsl_blas_csymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_matrix_complex_float * B, const gsl_complex_float beta, gsl_matrix_complex_float * C)
  fun gsl_blas_csymm: CBLAS_SIDE_t * CBLAS_UPLO_t * gsl_complex_float * &gsl_matrix_complex_float * &gsl_matrix_complex_float * gsl_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_csymm($a)';
// Function: int gsl_blas_zsymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_matrix_complex * B, const gsl_complex beta, gsl_matrix_complex * C)
  fun gsl_blas_zsymm: CBLAS_SIDE_t * CBLAS_UPLO_t * gsl_complex * &gsl_matrix_complex * &gsl_matrix_complex * gsl_complex * &gsl_matrix_complex -> int = 'gsl_blas_zsymm($a)';
// Function: int gsl_blas_chemm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_matrix_complex_float * B, const gsl_complex_float beta, gsl_matrix_complex_float * C)
  fun gsl_blas_chemm: CBLAS_SIDE_t * CBLAS_UPLO_t * gsl_complex_float * &gsl_matrix_complex_float * &gsl_matrix_complex_float * gsl_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_chemm($a)';
// Function: int gsl_blas_zhemm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_matrix_complex * B, const gsl_complex beta, gsl_matrix_complex * C)
  fun gsl_blas_zhemm: CBLAS_SIDE_t * CBLAS_UPLO_t * gsl_complex * &gsl_matrix_complex * &gsl_matrix_complex * gsl_complex * &gsl_matrix_complex -> int = 'gsl_blas_zhemm($a)';
// Function: int gsl_blas_strmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, float alpha, const gsl_matrix_float * A, gsl_matrix_float * B)
  fun gsl_blas_strmm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * float * &gsl_matrix_float * &gsl_matrix_float -> int = 'gsl_blas_strmm($a)';
// Function: int gsl_blas_dtrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, double alpha, const gsl_matrix * A, gsl_matrix * B)
  fun gsl_blas_dtrmm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * double * &gsl_matrix * &gsl_matrix -> int = 'gsl_blas_dtrmm($a)';
// Function: int gsl_blas_ctrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, gsl_matrix_complex_float * B)
  fun gsl_blas_ctrmm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * gsl_complex_float * &gsl_matrix_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_ctrmm($a)';
// Function: int gsl_blas_ztrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_complex alpha, const gsl_matrix_complex * A, gsl_matrix_complex * B)
  fun gsl_blas_ztrmm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * gsl_complex * &gsl_matrix_complex * &gsl_matrix_complex -> int = 'gsl_blas_ztrmm($a)';
// Function: int gsl_blas_strsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, float alpha, const gsl_matrix_float * A, gsl_matrix_float * B)
  fun gsl_blas_strsm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * float * &gsl_matrix_float * &gsl_matrix_float -> int = 'gsl_blas_strsm($a)';
// Function: int gsl_blas_dtrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, double alpha, const gsl_matrix * A, gsl_matrix * B)
  fun gsl_blas_dtrsm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * double * &gsl_matrix * &gsl_matrix -> int = 'gsl_blas_dtrsm($a)';
// Function: int gsl_blas_ctrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, gsl_matrix_complex_float * B)
  fun gsl_blas_ctrsm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * gsl_complex_float * &gsl_matrix_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_ctrsm($a)';
// Function: int gsl_blas_ztrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, const gsl_complex alpha, const gsl_matrix_complex * A, gsl_matrix_complex * B)
  fun gsl_blas_ztrsm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * gsl_complex * &gsl_matrix_complex * &gsl_matrix_complex -> int = 'gsl_blas_ztrsm($a)';
// Function: int gsl_blas_ssyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha, const gsl_matrix_float * A, float beta, gsl_matrix_float * C)
  fun gsl_blas_ssyrk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * float * &gsl_matrix_float * float * &gsl_matrix_float -> int = 'gsl_blas_ssyrk($a)';
// Function: int gsl_blas_dsyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha, const gsl_matrix * A, double beta, gsl_matrix * C)
  fun gsl_blas_dsyrk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * double * &gsl_matrix * double * &gsl_matrix -> int = 'gsl_blas_dsyrk($a)';
// Function: int gsl_blas_csyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_complex_float beta, gsl_matrix_complex_float * C)
  fun gsl_blas_csyrk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex_float * &gsl_matrix_complex_float * gsl_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_csyrk($a)';
// Function: int gsl_blas_zsyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_complex beta, gsl_matrix_complex * C)
  fun gsl_blas_zsyrk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex * &gsl_matrix_complex * gsl_complex * &gsl_matrix_complex -> int = 'gsl_blas_zsyrk($a)';
// Function: int gsl_blas_cherk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha, const gsl_matrix_complex_float * A, float beta, gsl_matrix_complex_float * C)
  fun gsl_blas_cherk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * float * &gsl_matrix_complex_float * float * &gsl_matrix_complex_float -> int = 'gsl_blas_cherk($a)';
// Function: int gsl_blas_zherk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha, const gsl_matrix_complex * A, double beta, gsl_matrix_complex * C)
  fun gsl_blas_zherk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * double * &gsl_matrix_complex * double * &gsl_matrix_complex -> int = 'gsl_blas_zherk($a)';
// Function: int gsl_blas_ssyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha, const gsl_matrix_float * A, const gsl_matrix_float * B, float beta, gsl_matrix_float * C)
  fun gsl_blas_ssyr2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * float * &gsl_matrix_float * &gsl_matrix_float * float * &gsl_matrix_float -> int = 'gsl_blas_ssyr2k($a)';
// Function: int gsl_blas_dsyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha, const gsl_matrix * A, const gsl_matrix * B, double beta, gsl_matrix * C)
  fun gsl_blas_dsyr2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * double * &gsl_matrix * &gsl_matrix * double * &gsl_matrix -> int = 'gsl_blas_dsyr2k($a)';
// Function: int gsl_blas_csyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_matrix_complex_float * B, const gsl_complex_float beta, gsl_matrix_complex_float * C)
  fun gsl_blas_csyr2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex_float * &gsl_matrix_complex_float * &gsl_matrix_complex_float * gsl_complex_float * &gsl_matrix_complex_float -> int = 'gsl_blas_csyr2k($a)';
// Function: int gsl_blas_zsyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_matrix_complex * B, const gsl_complex beta, gsl_matrix_complex * C)
  fun gsl_blas_zsyr2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex * &gsl_matrix_complex * &gsl_matrix_complex * gsl_complex * &gsl_matrix_complex -> int = 'gsl_blas_zsyr2k($a)';
// Function: int gsl_blas_cher2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, const gsl_complex_float alpha, const gsl_matrix_complex_float * A, const gsl_matrix_complex_float * B, float beta, gsl_matrix_complex_float * C)
  fun gsl_blas_cher2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex_float * &gsl_matrix_complex_float * &gsl_matrix_complex_float * float * &gsl_matrix_complex_float -> int = 'gsl_blas_cher2k($a)';
// Function: int gsl_blas_zher2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, const gsl_complex alpha, const gsl_matrix_complex * A, const gsl_matrix_complex * B, double beta, gsl_matrix_complex * C)
  fun gsl_blas_zher2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex * &gsl_matrix_complex * &gsl_matrix_complex * double * &gsl_matrix_complex -> int = 'gsl_blas_zher2k($a)';
//*****
// 14.00.00 Linear-Algebra.
//*****
// 14.01.00 LU-Decomposition.
// Function: int gsl_linalg_LU_decomp (gsl_matrix * A, gsl_permutation * p, int * signum)
  fun gsl_linalg_LU_decomp: &gsl_matrix * &gsl_permutation * &int -> int = 'gsl_linalg_LU_decomp($a)';
// Function: int gsl_linalg_complex_LU_decomp (gsl_matrix_complex * A, gsl_permutation * p, int * signum)
  fun gsl_linalg_complex_LU_decomp: &gsl_matrix_complex * &gsl_permutation * &int -> int = 'gsl_linalg_complex_LU_decomp($a)';
// Function: int gsl_linalg_LU_solve (const gsl_matrix * LU, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_LU_solve: &gsl_matrix * &gsl_permutation * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_LU_solve($a)';
// Function: int gsl_linalg_complex_LU_solve (const gsl_matrix_complex * LU, const gsl_permutation * p, const gsl_vector_complex * b, gsl_vector_complex * x)
  fun gsl_linalg_complex_LU_solve: &gsl_matrix_complex * &gsl_permutation * &gsl_vector_complex * &gsl_vector_complex -> int = 'gsl_linalg_complex_LU_solve($a)';
// Function: int gsl_linalg_LU_svx (const gsl_matrix * LU, const gsl_permutation * p, gsl_vector * x)
  fun gsl_linalg_LU_svx: &gsl_matrix * &gsl_permutation * &gsl_vector -> int = 'gsl_linalg_LU_svx($a)';
// Function: int gsl_linalg_complex_LU_svx (const gsl_matrix_complex * LU, const gsl_permutation * p, gsl_vector_complex * x)
  fun gsl_linalg_complex_LU_svx: &gsl_matrix_complex * &gsl_permutation * &gsl_vector_complex -> int = 'gsl_linalg_complex_LU_svx($a)';
// Function: int gsl_linalg_LU_refine (const gsl_matrix * A, const gsl_matrix * LU, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x, gsl_vector * residual)
  fun gsl_linalg_LU_refine: &gsl_matrix * &gsl_matrix * &gsl_permutation * &gsl_vector * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_LU_refine($a)';
// Function: int gsl_linalg_complex_LU_refine (const gsl_matrix_complex * A, const gsl_matrix_complex * LU, const gsl_permutation * p, const gsl_vector_complex * b, gsl_vector_complex * x, gsl_vector_complex * residual)
  fun gsl_linalg_complex_LU_refine: &gsl_matrix_complex * &gsl_matrix_complex * &gsl_permutation * &gsl_vector_complex * &gsl_vector_complex * &gsl_vector_complex -> int = 'gsl_linalg_complex_LU_refine($a)';
// Function: int gsl_linalg_LU_invert (const gsl_matrix * LU, const gsl_permutation * p, gsl_matrix * inverse)
  fun gsl_linalg_LU_invert: &gsl_matrix * &gsl_permutation * &gsl_matrix -> int = 'gsl_linalg_LU_invert($a)';
// Function: int gsl_linalg_complex_LU_invert (const gsl_matrix_complex * LU, const gsl_permutation * p, gsl_matrix_complex * inverse)
  fun gsl_linalg_complex_LU_invert: &gsl_matrix_complex * &gsl_permutation * &gsl_matrix_complex -> int = 'gsl_linalg_complex_LU_invert($a)';
// Function: double gsl_linalg_LU_det (gsl_matrix * LU, int signum)
  fun gsl_linalg_LU_det: &gsl_matrix * int -> double = 'gsl_linalg_LU_det($a)';
// Function: gsl_complex gsl_linalg_complex_LU_det (gsl_matrix_complex * LU, int signum)
  fun gsl_linalg_complex_LU_det: &gsl_matrix_complex * int -> gsl_complex = 'gsl_linalg_complex_LU_det($a)';
// Function: double gsl_linalg_LU_lndet (gsl_matrix * LU)
  fun gsl_linalg_LU_lndet: &gsl_matrix -> double = 'gsl_linalg_LU_lndet($a)';
// Function: double gsl_linalg_complex_LU_lndet (gsl_matrix_complex * LU)
  fun gsl_linalg_complex_LU_lndet: &gsl_matrix_complex -> double = 'gsl_linalg_complex_LU_lndet($a)';
// Function: int gsl_linalg_LU_sgndet (gsl_matrix * LU, int signum)
  fun gsl_linalg_LU_sgndet: &gsl_matrix * int -> int = 'gsl_linalg_LU_sgndet($a)';
// Function: gsl_complex gsl_linalg_complex_LU_sgndet (gsl_matrix_complex * LU, int signum)
  fun gsl_linalg_complex_LU_sgndet: &gsl_matrix_complex * int -> gsl_complex = 'gsl_linalg_complex_LU_sgndet($a)';
//*****
// 14.02.00 QR-Decomposition.
// Function: int gsl_linalg_QR_decomp (gsl_matrix * A, gsl_vector * tau)
  fun gsl_linalg_QR_decomp: &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_QR_decomp($a)';
// Function: int gsl_linalg_QR_solve (const gsl_matrix * QR, const gsl_vector * tau, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_QR_solve: &gsl_matrix * &gsl_vector * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QR_solve($a)';
// Function: int gsl_linalg_QR_svx (const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * x)
  fun gsl_linalg_QR_svx: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QR_svx($a)';
// Function: int gsl_linalg_QR_lssolve (const gsl_matrix * QR, const gsl_vector * tau, const gsl_vector * b, gsl_vector * x, gsl_vector * residual)
  fun gsl_linalg_QR_lssolve: &gsl_matrix * &gsl_vector * &gsl_vector * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QR_lssolve($a)';
// Function: int gsl_linalg_QR_QTvec (const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * v)
  fun gsl_linalg_QR_QTvec: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QR_QTvec($a)';
// Function: int gsl_linalg_QR_Qvec (const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * v)
  fun gsl_linalg_QR_Qvec: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QR_Qvec($a)';
// Function: int gsl_linalg_QR_QTmat (const gsl_matrix * QR, const gsl_vector * tau, gsl_matrix * A)
  fun gsl_linalg_QR_QTmat: &gsl_matrix * &gsl_vector * &gsl_matrix -> int = 'gsl_linalg_QR_QTmat($a)';
// Function: int gsl_linalg_QR_Rsolve (const gsl_matrix * QR, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_QR_Rsolve: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QR_Rsolve($a)';
// Function: int gsl_linalg_QR_Rsvx (const gsl_matrix * QR, gsl_vector * x)
  fun gsl_linalg_QR_Rsvx: &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_QR_Rsvx($a)';
// Function: int gsl_linalg_QR_unpack (const gsl_matrix * QR, const gsl_vector * tau, gsl_matrix * Q, gsl_matrix * R)
  fun gsl_linalg_QR_unpack: &gsl_matrix * &gsl_vector * &gsl_matrix * &gsl_matrix -> int = 'gsl_linalg_QR_unpack($a)';
// Function: int gsl_linalg_QR_QRsolve (gsl_matrix * Q, gsl_matrix * R, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_QR_QRsolve: &gsl_matrix * &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QR_QRsolve($a)';
// Function: int gsl_linalg_QR_update (gsl_matrix * Q, gsl_matrix * R, gsl_vector * w, const gsl_vector * v)
  fun gsl_linalg_QR_update: &gsl_matrix * &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QR_update($a)';
// Function: int gsl_linalg_R_solve (const gsl_matrix * R, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_R_solve: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_R_solve($a)';
// Function: int gsl_linalg_R_svx (const gsl_matrix * R, gsl_vector * x)
  fun gsl_linalg_R_svx: &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_R_svx($a)';
//*****
// 14.03.00 QR-Decomposition-with-Column-Pivoting.
// Function: int gsl_linalg_QRPT_decomp (gsl_matrix * A, gsl_vector * tau, gsl_permutation * p, int * signum, gsl_vector * norm)
  fun gsl_linalg_QRPT_decomp: &gsl_matrix * &gsl_vector * &gsl_permutation * &int * &gsl_vector -> int = 'gsl_linalg_QRPT_decomp($a)';
// Function: int gsl_linalg_QRPT_decomp2 (const gsl_matrix * A, gsl_matrix * q, gsl_matrix * r, gsl_vector * tau, gsl_permutation * p, int * signum, gsl_vector * norm)
  fun gsl_linalg_QRPT_decomp2: &gsl_matrix * &gsl_matrix * &gsl_matrix * &gsl_vector * &gsl_permutation * &int * &gsl_vector -> int = 'gsl_linalg_QRPT_decomp2($a)';
// Function: int gsl_linalg_QRPT_solve (const gsl_matrix * QR, const gsl_vector * tau, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_QRPT_solve: &gsl_matrix * &gsl_vector * &gsl_permutation * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QRPT_solve($a)';
// Function: int gsl_linalg_QRPT_svx (const gsl_matrix * QR, const gsl_vector * tau, const gsl_permutation * p, gsl_vector * x)
  fun gsl_linalg_QRPT_svx: &gsl_matrix * &gsl_vector * &gsl_permutation * &gsl_vector -> int = 'gsl_linalg_QRPT_svx($a)';
// Function: int gsl_linalg_QRPT_QRsolve (const gsl_matrix * Q, const gsl_matrix * R, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_QRPT_QRsolve: &gsl_matrix * &gsl_matrix * &gsl_permutation * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QRPT_QRsolve($a)';
// Function: int gsl_linalg_QRPT_update (gsl_matrix * Q, gsl_matrix * R, const gsl_permutation * p, gsl_vector * w, const gsl_vector * v)
  fun gsl_linalg_QRPT_update: &gsl_matrix * &gsl_matrix * &gsl_permutation * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QRPT_update($a)';
// Function: int gsl_linalg_QRPT_Rsolve (const gsl_matrix * QR, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_QRPT_Rsolve: &gsl_matrix * &gsl_permutation * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_QRPT_Rsolve($a)';
// Function: int gsl_linalg_QRPT_Rsvx (const gsl_matrix * QR, const gsl_permutation * p, gsl_vector * x)
  fun gsl_linalg_QRPT_Rsvx: &gsl_matrix * &gsl_permutation * &gsl_vector -> int = 'gsl_linalg_QRPT_Rsvx($a)';
//*****
// 14.04.00 Singular-Value-Decomposition.
// Function: int gsl_linalg_SV_decomp (gsl_matrix * A, gsl_matrix * V, gsl_vector * S, gsl_vector * work)
  fun gsl_linalg_SV_decomp: &gsl_matrix * &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_SV_decomp($a)';
// Function: int gsl_linalg_SV_decomp_mod (gsl_matrix * A, gsl_matrix * X, gsl_matrix * V, gsl_vector * S, gsl_vector * work)
  fun gsl_linalg_SV_decomp_mod: &gsl_matrix * &gsl_matrix * &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_SV_decomp_mod($a)';
// Function: int gsl_linalg_SV_decomp_jacobi (gsl_matrix * A, gsl_matrix * V, gsl_vector * S)
  fun gsl_linalg_SV_decomp_jacobi: &gsl_matrix * &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_SV_decomp_jacobi($a)';
// Function: int gsl_linalg_SV_solve (const gsl_matrix * U, const gsl_matrix * V, const gsl_vector * S, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_SV_solve: &gsl_matrix * &gsl_matrix * &gsl_vector * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_SV_solve($a)';
// Function: int gsl_linalg_SV_leverage (const gsl_matrix * U, gsl_vector * h)
  fun gsl_linalg_SV_leverage: &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_SV_leverage($a)';
//*****
// 14.05.00 Cholesky-Decomposition.
// Function: int gsl_linalg_cholesky_decomp (gsl_matrix * A)
  fun gsl_linalg_cholesky_decomp: &gsl_matrix -> int = 'gsl_linalg_cholesky_decomp($a)';
// Function: int gsl_linalg_complex_cholesky_decomp (gsl_matrix_complex * A)
  fun gsl_linalg_complex_cholesky_decomp: &gsl_matrix_complex -> int = 'gsl_linalg_complex_cholesky_decomp($a)';
// Function: int gsl_linalg_cholesky_solve (const gsl_matrix * cholesky, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_cholesky_solve: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_cholesky_solve($a)';
// Function: int gsl_linalg_complex_cholesky_solve (const gsl_matrix_complex * cholesky, const gsl_vector_complex * b, gsl_vector_complex * x)
  fun gsl_linalg_complex_cholesky_solve: &gsl_matrix_complex * &gsl_vector_complex * &gsl_vector_complex -> int = 'gsl_linalg_complex_cholesky_solve($a)';
// Function: int gsl_linalg_cholesky_svx (const gsl_matrix * cholesky, gsl_vector * x)
  fun gsl_linalg_cholesky_svx: &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_cholesky_svx($a)';
// Function: int gsl_linalg_complex_cholesky_svx (const gsl_matrix_complex * cholesky, gsl_vector_complex * x)
  fun gsl_linalg_complex_cholesky_svx: &gsl_matrix_complex * &gsl_vector_complex -> int = 'gsl_linalg_complex_cholesky_svx($a)';
// Function: int gsl_linalg_cholesky_invert (gsl_matrix * cholesky)
  fun gsl_linalg_cholesky_invert: &gsl_matrix -> int = 'gsl_linalg_cholesky_invert($a)';
// Function: int gsl_linalg_complex_cholesky_invert (gsl_matrix_complex * cholesky)
  fun gsl_linalg_complex_cholesky_invert: &gsl_matrix_complex -> int = 'gsl_linalg_complex_cholesky_invert($a)';
//*****
// 14.06.00 Tridiagonal-Decomposition-of-Hermitian-Matrics.
// Function: int gsl_linalg_symmtd_decomp (gsl_matrix * A, gsl_vector * tau)
  fun gsl_linalg_symmtd_decomp: &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_symmtd_decomp($a)';
// Function: int gsl_linalg_symmtd_unpack (const gsl_matrix * A, const gsl_vector * tau, gsl_matrix * Q, gsl_vector * diag, gsl_vector * subdiag)
  fun gsl_linalg_symmtd_unpack: &gsl_matrix * &gsl_vector * &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_symmtd_unpack($a)';
// Function: int gsl_linalg_symmtd_unpack_T (const gsl_matrix * A, gsl_vector * diag, gsl_vector * subdiag)
  fun gsl_linalg_symmtd_unpack_T: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_symmtd_unpack_T($a)';
//*****
// 14.06.00 Tridiagonal-Decomposition-of-Real-Symmetric-Matrics.
// Function: int gsl_linalg_symmtd_decomp (gsl_matrix * A, gsl_vector * tau)
  fun gsl_linalg_symmtd_decomp: &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_symmtd_decomp($a)';
// Function: int gsl_linalg_symmtd_unpack (const gsl_matrix * A, const gsl_vector * tau, gsl_matrix * Q, gsl_vector * diag, gsl_vector * subdiag)
  fun gsl_linalg_symmtd_unpack: &gsl_matrix * &gsl_vector * &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_symmtd_unpack($a)';
// Function: int gsl_linalg_symmtd_unpack_T (const gsl_matrix * A, gsl_vector * diag, gsl_vector * subdiag)
  fun gsl_linalg_symmtd_unpack_T: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_symmtd_unpack_T($a)';
//*****
// 14.08.00 Hessenberg-Decomposiion-of-Real-Matrices.
// Function: int gsl_linalg_hessenberg_decomp (gsl_matrix * A, gsl_vector * tau)
  fun gsl_linalg_hessenberg_decomp: &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_hessenberg_decomp($a)';
// Function: int gsl_linalg_hessenberg_unpack (gsl_matrix * H, gsl_vector * tau, gsl_matrix * U)
  fun gsl_linalg_hessenberg_unpack: &gsl_matrix * &gsl_vector * &gsl_matrix -> int = 'gsl_linalg_hessenberg_unpack($a)';
// Function: int gsl_linalg_hessenberg_unpack_accum (gsl_matrix * H, gsl_vector * tau, gsl_matrix * V)
  fun gsl_linalg_hessenberg_unpack_accum: &gsl_matrix * &gsl_vector * &gsl_matrix -> int = 'gsl_linalg_hessenberg_unpack_accum($a)';
// Function: int gsl_linalg_hessenberg_set_zero (gsl_matrix * H)
  fun gsl_linalg_hessenberg_set_zero: &gsl_matrix -> int = 'gsl_linalg_hessenberg_set_zero($a)';
//*****
// 14.09.00 Hessenberg-Triangular-Decomposiion-of-Real-Matrices.
// Function: int gsl_linalg_hesstri_decomp (gsl_matrix * A, gsl_matrix * B, gsl_matrix * U, gsl_matrix * V, gsl_vector * work)
  fun gsl_linalg_hesstri_decomp: &gsl_matrix * &gsl_matrix * &gsl_matrix * &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_hesstri_decomp($a)';
//*****
// 14.10.00 Bidiagonalisation.
// Function: int gsl_linalg_bidiag_decomp (gsl_matrix * A, gsl_vector * tau_U, gsl_vector * tau_V)
  fun gsl_linalg_bidiag_decomp: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_bidiag_decomp($a)';
// Function: int gsl_linalg_bidiag_unpack (const gsl_matrix * A, const gsl_vector * tau_U, gsl_matrix * U, const gsl_vector * tau_V, gsl_matrix * V, gsl_vector * diag, gsl_vector * superdiag)
  fun gsl_linalg_bidiag_unpack: &gsl_matrix * &gsl_vector * &gsl_matrix * &gsl_vector * &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_bidiag_unpack($a)';
// Function: int gsl_linalg_bidiag_unpack2 (gsl_matrix * A, gsl_vector * tau_U, gsl_vector * tau_V, gsl_matrix * V)
  fun gsl_linalg_bidiag_unpack2: &gsl_matrix * &gsl_vector * &gsl_vector * &gsl_matrix -> int = 'gsl_linalg_bidiag_unpack2($a)';
// Function: int gsl_linalg_bidiag_unpack_B (const gsl_matrix * A, gsl_vector * diag, gsl_vector * superdiag)
  fun gsl_linalg_bidiag_unpack_B: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_bidiag_unpack_B($a)';
//*****
// 14.11.00 Householder-Transformations.
// Function: double gsl_linalg_householder_transform (gsl_vector * v)
  fun gsl_linalg_householder_transform: &gsl_vector -> double = 'gsl_linalg_householder_transform($a)';
// Function: gsl_complex gsl_linalg_complex_householder_transform (gsl_vector_complex * v)
  fun gsl_linalg_complex_householder_transform: &gsl_vector_complex -> gsl_complex = 'gsl_linalg_complex_householder_transform($a)';
// Function: int gsl_linalg_householder_hm (double tau, const gsl_vector * v, gsl_matrix * A)
  fun gsl_linalg_householder_hm: double * &gsl_vector * &gsl_matrix -> int = 'gsl_linalg_householder_hm($a)';
// Function: int gsl_linalg_complex_householder_hm (gsl_complex tau, const gsl_vector_complex * v, gsl_matrix_complex * A)
  fun gsl_linalg_complex_householder_hm: gsl_complex * &gsl_vector_complex * &gsl_matrix_complex -> int = 'gsl_linalg_complex_householder_hm($a)';
// Function: int gsl_linalg_householder_mh (double tau, const gsl_vector * v, gsl_matrix * A)
  fun gsl_linalg_householder_mh: double * &gsl_vector * &gsl_matrix -> int = 'gsl_linalg_householder_mh($a)';
// Function: int gsl_linalg_complex_householder_mh (gsl_complex tau, const gsl_vector_complex * v, gsl_matrix_complex * A)
  fun gsl_linalg_complex_householder_mh: gsl_complex * &gsl_vector_complex * &gsl_matrix_complex -> int = 'gsl_linalg_complex_householder_mh($a)';
// Function: int gsl_linalg_householder_hv (double tau, const gsl_vector * v, gsl_vector * w)
  fun gsl_linalg_householder_hv: double * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_householder_hv($a)';
// Function: int gsl_linalg_complex_householder_hv (gsl_complex tau, const gsl_vector_complex * v, gsl_vector_complex * w)
  fun gsl_linalg_complex_householder_hv: gsl_complex * &gsl_vector_complex * &gsl_vector_complex -> int = 'gsl_linalg_complex_householder_hv($a)';
//*****
// 14.12.00 Householder-solver-for-linear-systems.
// Function: int gsl_linalg_HH_solve (gsl_matrix * A, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_HH_solve: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_HH_solve($a)';
// Function: int gsl_linalg_HH_svx (gsl_matrix * A, gsl_vector * x)
  fun gsl_linalg_HH_svx: &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_HH_svx($a)';
//*****
// 14.13.00 Tridiagonal-Systems.
// Function: int gsl_linalg_solve_tridiag (const gsl_vector * diag, const gsl_vector * e, const gsl_vector * f, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_solve_tridiag: &gsl_vector * &gsl_vector * &gsl_vector * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_solve_tridiag($a)';
// Function: int gsl_linalg_solve_symm_tridiag (const gsl_vector * diag, const gsl_vector * e, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_solve_symm_tridiag: &gsl_vector * &gsl_vector * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_solve_symm_tridiag($a)';
// Function: int gsl_linalg_solve_cyc_tridiag (const gsl_vector * diag, const gsl_vector * e, const gsl_vector * f, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_solve_cyc_tridiag: &gsl_vector * &gsl_vector * &gsl_vector * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_solve_cyc_tridiag($a)';
// Function: int gsl_linalg_solve_symm_cyc_tridiag (const gsl_vector * diag, const gsl_vector * e, const gsl_vector * b, gsl_vector * x)
  fun gsl_linalg_solve_symm_cyc_tridiag: &gsl_vector * &gsl_vector * &gsl_vector * &gsl_vector -> int = 'gsl_linalg_solve_symm_cyc_tridiag($a)';
//*****
// 14.14.00 Balancing.
// Function: int gsl_linalg_balance_matrix (gsl_matrix * A, gsl_vector * D)
  fun gsl_linalg_balance_matrix: &gsl_matrix * &gsl_vector -> int = 'gsl_linalg_balance_matrix($a)';
//*****
// 15.00.00 Eigensystems.
//*****
// 15.01.00 Real-Symmetric-Matrics.
// Function: gsl_eigen_symm_workspace * gsl_eigen_symm_alloc (const size_t n)
  fun gsl_eigen_symm_alloc: size -> &gsl_eigen_symm_workspace = 'gsl_eigen_symm_alloc($a)';
// Function: void gsl_eigen_symm_free (gsl_eigen_symm_workspace * w)
  proc gsl_eigen_symm_free: &gsl_eigen_symm_workspace = 'gsl_eigen_symm_free($a);';
// Function: int gsl_eigen_symm (gsl_matrix * A, gsl_vector * eval, gsl_eigen_symm_workspace * w)
  fun gsl_eigen_symm: &gsl_matrix * &gsl_vector * &gsl_eigen_symm_workspace -> int = 'gsl_eigen_symm($a)';
// Function: gsl_eigen_symmv_workspace * gsl_eigen_symmv_alloc (const size_t n)
  fun gsl_eigen_symmv_alloc: size -> &gsl_eigen_symmv_workspace = 'gsl_eigen_symmv_alloc($a)';
// Function: void gsl_eigen_symmv_free (gsl_eigen_symmv_workspace * w)
  proc gsl_eigen_symmv_free: &gsl_eigen_symmv_workspace = 'gsl_eigen_symmv_free($a);';
// Function: int gsl_eigen_symmv (gsl_matrix * A, gsl_vector * eval, gsl_matrix * evec, gsl_eigen_symmv_workspace * w)
  fun gsl_eigen_symmv: &gsl_matrix * &gsl_vector * &gsl_matrix * &gsl_eigen_symmv_workspace -> int = 'gsl_eigen_symmv($a)';
//*****
// 15.02.00 Complex-Hermitian-Matrics.
// Function: gsl_eigen_herm_workspace * gsl_eigen_herm_alloc (const size_t n)
  fun gsl_eigen_herm_alloc: size -> &gsl_eigen_herm_workspace = 'gsl_eigen_herm_alloc($a)';
// Function: void gsl_eigen_herm_free (gsl_eigen_herm_workspace * w)
  proc gsl_eigen_herm_free: &gsl_eigen_herm_workspace = 'gsl_eigen_herm_free($a);';
// Function: int gsl_eigen_herm (gsl_matrix_complex * A, gsl_vector * eval, gsl_eigen_herm_workspace * w)
  fun gsl_eigen_herm: &gsl_matrix_complex * &gsl_vector * &gsl_eigen_herm_workspace -> int = 'gsl_eigen_herm($a)';
// Function: gsl_eigen_hermv_workspace * gsl_eigen_hermv_alloc (const size_t n)
  fun gsl_eigen_hermv_alloc: size -> &gsl_eigen_hermv_workspace = 'gsl_eigen_hermv_alloc($a)';
// Function: void gsl_eigen_hermv_free (gsl_eigen_hermv_workspace * w)
  proc gsl_eigen_hermv_free: &gsl_eigen_hermv_workspace = 'gsl_eigen_hermv_free($a);';
// Function: int gsl_eigen_hermv (gsl_matrix_complex * A, gsl_vector * eval, gsl_matrix_complex * evec, gsl_eigen_hermv_workspace * w)
  fun gsl_eigen_hermv: &gsl_matrix_complex * &gsl_vector * &gsl_matrix_complex * &gsl_eigen_hermv_workspace -> int = 'gsl_eigen_hermv($a)';
//*****
// 15.03.00 Real-Nonsymmetric-Matrics.
// Function: gsl_eigen_nonsymm_workspace * gsl_eigen_nonsymm_alloc (const size_t n)
  fun gsl_eigen_nonsymm_alloc: size -> &gsl_eigen_nonsymm_workspace = 'gsl_eigen_nonsymm_alloc($a)';
// Function: void gsl_eigen_nonsymm_free (gsl_eigen_nonsymm_workspace * w)
  proc gsl_eigen_nonsymm_free: &gsl_eigen_nonsymm_workspace = 'gsl_eigen_nonsymm_free($a);';
// Function: void gsl_eigen_nonsymm_params (const int compute_t, const int balance, gsl_eigen_nonsymm_workspace * w)
  proc gsl_eigen_nonsymm_params: int * int * &gsl_eigen_nonsymm_workspace = 'gsl_eigen_nonsymm_params($a);';
// Function: int gsl_eigen_nonsymm (gsl_matrix * A, gsl_vector_complex * eval, gsl_eigen_nonsymm_workspace * w)
  fun gsl_eigen_nonsymm: &gsl_matrix * &gsl_vector_complex * &gsl_eigen_nonsymm_workspace -> int = 'gsl_eigen_nonsymm($a)';
// Function: int gsl_eigen_nonsymm_Z (gsl_matrix * A, gsl_vector_complex * eval, gsl_matrix * Z, gsl_eigen_nonsymm_workspace * w)
  fun gsl_eigen_nonsymm_Z: &gsl_matrix * &gsl_vector_complex * &gsl_matrix * &gsl_eigen_nonsymm_workspace -> int = 'gsl_eigen_nonsymm_Z($a)';
// Function: gsl_eigen_nonsymmv_workspace * gsl_eigen_nonsymmv_alloc (const size_t n)
  fun gsl_eigen_nonsymmv_alloc: size -> &gsl_eigen_nonsymmv_workspace = 'gsl_eigen_nonsymmv_alloc($a)';
// Function: void gsl_eigen_nonsymmv_free (gsl_eigen_nonsymmv_workspace * w)
  proc gsl_eigen_nonsymmv_free: &gsl_eigen_nonsymmv_workspace = 'gsl_eigen_nonsymmv_free($a);';
// Function: void gsl_eigen_nonsymmv_params (const int balance, gsl_eigen_nonsymm_workspace * w)
  proc gsl_eigen_nonsymmv_params: int * &gsl_eigen_nonsymm_workspace = 'gsl_eigen_nonsymmv_params($a);';
// Function: int gsl_eigen_nonsymmv (gsl_matrix * A, gsl_vector_complex * eval, gsl_matrix_complex * evec, gsl_eigen_nonsymmv_workspace * w)
  fun gsl_eigen_nonsymmv: &gsl_matrix * &gsl_vector_complex * &gsl_matrix_complex * &gsl_eigen_nonsymmv_workspace -> int = 'gsl_eigen_nonsymmv($a)';
// Function: int gsl_eigen_nonsymmv_Z (gsl_matrix * A, gsl_vector_complex * eval, gsl_matrix_complex * evec, gsl_matrix * Z, gsl_eigen_nonsymmv_workspace * w)
  fun gsl_eigen_nonsymmv_Z: &gsl_matrix * &gsl_vector_complex * &gsl_matrix_complex * &gsl_matrix * &gsl_eigen_nonsymmv_workspace -> int = 'gsl_eigen_nonsymmv_Z($a)';
//*****
// 15.04.00 Real-Generalized-Symmetric-Definite-Eigensystems.
// Function: gsl_eigen_gensymm_workspace * gsl_eigen_gensymm_alloc (const size_t n)
  fun gsl_eigen_gensymm_alloc: size -> &gsl_eigen_gensymm_workspace = 'gsl_eigen_gensymm_alloc($a)';
// Function: void gsl_eigen_gensymm_free (gsl_eigen_gensymm_workspace * w)
  proc gsl_eigen_gensymm_free: &gsl_eigen_gensymm_workspace = 'gsl_eigen_gensymm_free($a);';
// Function: int gsl_eigen_gensymm (gsl_matrix * A, gsl_matrix * B, gsl_vector * eval, gsl_eigen_gensymm_workspace * w)
  fun gsl_eigen_gensymm: &gsl_matrix * &gsl_matrix * &gsl_vector * &gsl_eigen_gensymm_workspace -> int = 'gsl_eigen_gensymm($a)';
// Function: gsl_eigen_gensymmv_workspace * gsl_eigen_gensymmv_alloc (const size_t n)
  fun gsl_eigen_gensymmv_alloc: size -> &gsl_eigen_gensymmv_workspace = 'gsl_eigen_gensymmv_alloc($a)';
// Function: void gsl_eigen_gensymmv_free (gsl_eigen_gensymmv_workspace * w)
  proc gsl_eigen_gensymmv_free: &gsl_eigen_gensymmv_workspace = 'gsl_eigen_gensymmv_free($a);';
// Function: int gsl_eigen_gensymmv (gsl_matrix * A, gsl_matrix * B, gsl_vector * eval, gsl_matrix * evec, gsl_eigen_gensymmv_workspace * w)
  fun gsl_eigen_gensymmv: &gsl_matrix * &gsl_matrix * &gsl_vector * &gsl_matrix * &gsl_eigen_gensymmv_workspace -> int = 'gsl_eigen_gensymmv($a)';
//*****
// 15.05.00 Complex-Generalized-Hermitian-Definite-Eigensystems.
// Function: gsl_eigen_genherm_workspace * gsl_eigen_genherm_alloc (const size_t n)
  fun gsl_eigen_genherm_alloc: size -> &gsl_eigen_genherm_workspace = 'gsl_eigen_genherm_alloc($a)';
// Function: void gsl_eigen_genherm_free (gsl_eigen_genherm_workspace * w)
  proc gsl_eigen_genherm_free: &gsl_eigen_genherm_workspace = 'gsl_eigen_genherm_free($a);';
// Function: int gsl_eigen_genherm (gsl_matrix_complex * A, gsl_matrix_complex * B, gsl_vector * eval, gsl_eigen_genherm_workspace * w)
  fun gsl_eigen_genherm: &gsl_matrix_complex * &gsl_matrix_complex * &gsl_vector * &gsl_eigen_genherm_workspace -> int = 'gsl_eigen_genherm($a)';
// Function: gsl_eigen_genhermv_workspace * gsl_eigen_genhermv_alloc (const size_t n)
  fun gsl_eigen_genhermv_alloc: size -> &gsl_eigen_genhermv_workspace = 'gsl_eigen_genhermv_alloc($a)';
// Function: void gsl_eigen_genhermv_free (gsl_eigen_genhermv_workspace * w)
  proc gsl_eigen_genhermv_free: &gsl_eigen_genhermv_workspace = 'gsl_eigen_genhermv_free($a);';
// Function: int gsl_eigen_genhermv (gsl_matrix_complex * A, gsl_matrix_complex * B, gsl_vector * eval, gsl_matrix_complex * evec, gsl_eigen_genhermv_workspace * w)
  fun gsl_eigen_genhermv: &gsl_matrix_complex * &gsl_matrix_complex * &gsl_vector * &gsl_matrix_complex * &gsl_eigen_genhermv_workspace -> int = 'gsl_eigen_genhermv($a)';
//*****
// 15.06.00 Real-Generalized-Nonsymmetric-Eigensystems.
// Function: gsl_eigen_gen_workspace * gsl_eigen_gen_alloc (const size_t n)
  fun gsl_eigen_gen_alloc: size -> &gsl_eigen_gen_workspace = 'gsl_eigen_gen_alloc($a)';
// Function: void gsl_eigen_gen_free (gsl_eigen_gen_workspace * w)
  proc gsl_eigen_gen_free: &gsl_eigen_gen_workspace = 'gsl_eigen_gen_free($a);';
// Function: void gsl_eigen_gen_params (const int compute_s, const int compute_t, const int balance, gsl_eigen_gen_workspace * w)
  proc gsl_eigen_gen_params: int * int * int * &gsl_eigen_gen_workspace = 'gsl_eigen_gen_params($a);';
// Function: int gsl_eigen_gen (gsl_matrix * A, gsl_matrix * B, gsl_vector_complex * alpha, gsl_vector * beta, gsl_eigen_gen_workspace * w)
  fun gsl_eigen_gen: &gsl_matrix * &gsl_matrix * &gsl_vector_complex * &gsl_vector * &gsl_eigen_gen_workspace -> int = 'gsl_eigen_gen($a)';
// Function: int gsl_eigen_gen_QZ (gsl_matrix * A, gsl_matrix * B, gsl_vector_complex * alpha, gsl_vector * beta, gsl_matrix * Q, gsl_matrix * Z, gsl_eigen_gen_workspace * w)
  fun gsl_eigen_gen_QZ: &gsl_matrix * &gsl_matrix * &gsl_vector_complex * &gsl_vector * &gsl_matrix * &gsl_matrix * &gsl_eigen_gen_workspace -> int = 'gsl_eigen_gen_QZ($a)';
// Function: gsl_eigen_genv_workspace * gsl_eigen_genv_alloc (const size_t n)
  fun gsl_eigen_genv_alloc: size -> &gsl_eigen_genv_workspace = 'gsl_eigen_genv_alloc($a)';
// Function: void gsl_eigen_genv_free (gsl_eigen_genv_workspace * w)
  proc gsl_eigen_genv_free: &gsl_eigen_genv_workspace = 'gsl_eigen_genv_free($a);';
// Function: int gsl_eigen_genv (gsl_matrix * A, gsl_matrix * B, gsl_vector_complex * alpha, gsl_vector * beta, gsl_matrix_complex * evec, gsl_eigen_genv_workspace * w)
  fun gsl_eigen_genv: &gsl_matrix * &gsl_matrix * &gsl_vector_complex * &gsl_vector * &gsl_matrix_complex * &gsl_eigen_genv_workspace -> int = 'gsl_eigen_genv($a)';
// Function: int gsl_eigen_genv_QZ (gsl_matrix * A, gsl_matrix * B, gsl_vector_complex * alpha, gsl_vector * beta, gsl_matrix_complex * evec, gsl_matrix * Q, gsl_matrix * Z, gsl_eigen_genv_workspace * w)
  fun gsl_eigen_genv_QZ: &gsl_matrix * &gsl_matrix * &gsl_vector_complex * &gsl_vector * &gsl_matrix_complex * &gsl_matrix * &gsl_matrix * &gsl_eigen_genv_workspace -> int = 'gsl_eigen_genv_QZ($a)';
//*****
// 15.07.00 Sorting-Eigenvalues-and-Eigenvectors.
// Function: int gsl_eigen_symmv_sort (gsl_vector * eval, gsl_matrix * evec, gsl_eigen_sort_t sort_type)
  fun gsl_eigen_symmv_sort: &gsl_vector * &gsl_matrix * gsl_eigen_sort_t -> int = 'gsl_eigen_symmv_sort($a)';
// Function: int gsl_eigen_hermv_sort (gsl_vector * eval, gsl_matrix_complex * evec, gsl_eigen_sort_t sort_type)
  fun gsl_eigen_hermv_sort: &gsl_vector * &gsl_matrix_complex * gsl_eigen_sort_t -> int = 'gsl_eigen_hermv_sort($a)';
// Function: int gsl_eigen_nonsymmv_sort (gsl_vector_complex * eval, gsl_matrix_complex * evec, gsl_eigen_sort_t sort_type)
  fun gsl_eigen_nonsymmv_sort: &gsl_vector_complex * &gsl_matrix_complex * gsl_eigen_sort_t -> int = 'gsl_eigen_nonsymmv_sort($a)';
// Function: int gsl_eigen_gensymmv_sort (gsl_vector * eval, gsl_matrix * evec, gsl_eigen_sort_t sort_type)
  fun gsl_eigen_gensymmv_sort: &gsl_vector * &gsl_matrix * gsl_eigen_sort_t -> int = 'gsl_eigen_gensymmv_sort($a)';
// Function: int gsl_eigen_genhermv_sort (gsl_vector * eval, gsl_matrix_complex * evec, gsl_eigen_sort_t sort_type)
  fun gsl_eigen_genhermv_sort: &gsl_vector * &gsl_matrix_complex * gsl_eigen_sort_t -> int = 'gsl_eigen_genhermv_sort($a)';
// Function: int gsl_eigen_genv_sort (gsl_vector_complex * alpha, gsl_vector * beta, gsl_matrix_complex * evec, gsl_eigen_sort_t sort_type)
  fun gsl_eigen_genv_sort: &gsl_vector_complex * &gsl_vector * &gsl_matrix_complex * gsl_eigen_sort_t -> int = 'gsl_eigen_genv_sort($a)';
//*****
// 16.00.00 Fast-Fourier-Transforms-(FFTs).
//*****
// 16.01.00 Mathematical-Definitions.
//*****
// 16.02.00 Overview-of-complex-data-FFTs.
//*****
// 16.03.00 Radix-2-FFT-routines-for-complex-data.
// Function: int gsl_fft_complex_radix2_forward (gsl_complex_packed_array data, size_t stride, size_t n)
  fun gsl_fft_complex_radix2_forward: gsl_complex_packed_array * size * size -> int = 'gsl_fft_complex_radix2_forward($a)';
// Function: int gsl_fft_complex_radix2_transform (gsl_complex_packed_array data, size_t stride, size_t n, gsl_fft_direction sign)
  fun gsl_fft_complex_radix2_transform: gsl_complex_packed_array * size * size * gsl_fft_direction -> int = 'gsl_fft_complex_radix2_transform($a)';
// Function: int gsl_fft_complex_radix2_backward (gsl_complex_packed_array data, size_t stride, size_t n)
  fun gsl_fft_complex_radix2_backward: gsl_complex_packed_array * size * size -> int = 'gsl_fft_complex_radix2_backward($a)';
// Function: int gsl_fft_complex_radix2_inverse (gsl_complex_packed_array data, size_t stride, size_t n)
  fun gsl_fft_complex_radix2_inverse: gsl_complex_packed_array * size * size -> int = 'gsl_fft_complex_radix2_inverse($a)';
// Function: int gsl_fft_complex_radix2_dif_forward (gsl_complex_packed_array data, size_t stride, size_t n)
  fun gsl_fft_complex_radix2_dif_forward: gsl_complex_packed_array * size * size -> int = 'gsl_fft_complex_radix2_dif_forward($a)';
// Function: int gsl_fft_complex_radix2_dif_transform (gsl_complex_packed_array data, size_t stride, size_t n, gsl_fft_direction sign)
  fun gsl_fft_complex_radix2_dif_transform: gsl_complex_packed_array * size * size * gsl_fft_direction -> int = 'gsl_fft_complex_radix2_dif_transform($a)';
// Function: int gsl_fft_complex_radix2_dif_backward (gsl_complex_packed_array data, size_t stride, size_t n)
  fun gsl_fft_complex_radix2_dif_backward: gsl_complex_packed_array * size * size -> int = 'gsl_fft_complex_radix2_dif_backward($a)';
// Function: int gsl_fft_complex_radix2_dif_inverse (gsl_complex_packed_array data, size_t stride, size_t n)
  fun gsl_fft_complex_radix2_dif_inverse: gsl_complex_packed_array * size * size -> int = 'gsl_fft_complex_radix2_dif_inverse($a)';
//*****
// 16.04.00 Mixed-radix-FFT-routines-for-complex-data.
// Function: gsl_fft_complex_wavetable * gsl_fft_complex_wavetable_alloc (size_t n)
  fun gsl_fft_complex_wavetable_alloc: size -> &gsl_fft_complex_wavetable = 'gsl_fft_complex_wavetable_alloc($a)';
// Function: void gsl_fft_complex_wavetable_free (gsl_fft_complex_wavetable * wavetable)
  proc gsl_fft_complex_wavetable_free: &gsl_fft_complex_wavetable = 'gsl_fft_complex_wavetable_free($a);';
// Function: gsl_fft_complex_workspace * gsl_fft_complex_workspace_alloc (size_t n)
  fun gsl_fft_complex_workspace_alloc: size -> &gsl_fft_complex_workspace = 'gsl_fft_complex_workspace_alloc($a)';
// Function: void gsl_fft_complex_workspace_free (gsl_fft_complex_workspace * workspace)
  proc gsl_fft_complex_workspace_free: &gsl_fft_complex_workspace = 'gsl_fft_complex_workspace_free($a);';
// Function: int gsl_fft_complex_forward (gsl_complex_packed_array data, size_t stride, size_t n, const gsl_fft_complex_wavetable * wavetable, gsl_fft_complex_workspace * work)
  fun gsl_fft_complex_forward: gsl_complex_packed_array * size * size * &gsl_fft_complex_wavetable * &gsl_fft_complex_workspace -> int = 'gsl_fft_complex_forward($a)';
// Function: int gsl_fft_complex_transform (gsl_complex_packed_array data, size_t stride, size_t n, const gsl_fft_complex_wavetable * wavetable, gsl_fft_complex_workspace * work, gsl_fft_direction sign)
  fun gsl_fft_complex_transform: gsl_complex_packed_array * size * size * &gsl_fft_complex_wavetable * &gsl_fft_complex_workspace * gsl_fft_direction -> int = 'gsl_fft_complex_transform($a)';
// Function: int gsl_fft_complex_backward (gsl_complex_packed_array data, size_t stride, size_t n, const gsl_fft_complex_wavetable * wavetable, gsl_fft_complex_workspace * work)
  fun gsl_fft_complex_backward: gsl_complex_packed_array * size * size * &gsl_fft_complex_wavetable * &gsl_fft_complex_workspace -> int = 'gsl_fft_complex_backward($a)';
// Function: int gsl_fft_complex_inverse (gsl_complex_packed_array data, size_t stride, size_t n, const gsl_fft_complex_wavetable * wavetable, gsl_fft_complex_workspace * work)
  fun gsl_fft_complex_inverse: gsl_complex_packed_array * size * size * &gsl_fft_complex_wavetable * &gsl_fft_complex_workspace -> int = 'gsl_fft_complex_inverse($a)';
//*****
// 16.05.00 Overview-of-real-data-FFTs.
//*****
// 16.06.00 Radix-2-FFT-routines-for-real-data.
// Function: int gsl_fft_real_radix2_transform (double data[], size_t stride, size_t n)
  fun gsl_fft_real_radix2_transform: +double * size * size -> int = 'gsl_fft_real_radix2_transform($a)';
// Function: int gsl_fft_halfcomplex_radix2_inverse (double data[], size_t stride, size_t n)
  fun gsl_fft_halfcomplex_radix2_inverse: +double * size * size -> int = 'gsl_fft_halfcomplex_radix2_inverse($a)';
// Function: int gsl_fft_halfcomplex_radix2_backward (double data[], size_t stride, size_t n)
  fun gsl_fft_halfcomplex_radix2_backward: +double * size * size -> int = 'gsl_fft_halfcomplex_radix2_backward($a)';
// Function: int gsl_fft_halfcomplex_radix2_unpack (const double halfcomplex_coefficient[], gsl_complex_packed_array complex_coefficient, size_t stride, size_t n)
  fun gsl_fft_halfcomplex_radix2_unpack: +double * gsl_complex_packed_array * size * size -> int = 'gsl_fft_halfcomplex_radix2_unpack($a)';
//*****
// 16.07.00 Mixed-radix-FFT-routines-for-real-data.
// Function: gsl_fft_real_wavetable * gsl_fft_real_wavetable_alloc (size_t n)
  fun gsl_fft_real_wavetable_alloc: size -> &gsl_fft_real_wavetable = 'gsl_fft_real_wavetable_alloc($a)';
// Function: gsl_fft_halfcomplex_wavetable * gsl_fft_halfcomplex_wavetable_alloc (size_t n)
  fun gsl_fft_halfcomplex_wavetable_alloc: size -> &gsl_fft_halfcomplex_wavetable = 'gsl_fft_halfcomplex_wavetable_alloc($a)';
// Function: void gsl_fft_real_wavetable_free (gsl_fft_real_wavetable * wavetable)
  proc gsl_fft_real_wavetable_free: &gsl_fft_real_wavetable = 'gsl_fft_real_wavetable_free($a);';
// Function: void gsl_fft_halfcomplex_wavetable_free (gsl_fft_halfcomplex_wavetable * wavetable)
  proc gsl_fft_halfcomplex_wavetable_free: &gsl_fft_halfcomplex_wavetable = 'gsl_fft_halfcomplex_wavetable_free($a);';
// Function: gsl_fft_real_workspace * gsl_fft_real_workspace_alloc (size_t n)
  fun gsl_fft_real_workspace_alloc: size -> &gsl_fft_real_workspace = 'gsl_fft_real_workspace_alloc($a)';
// Function: void gsl_fft_real_workspace_free (gsl_fft_real_workspace * workspace)
  proc gsl_fft_real_workspace_free: &gsl_fft_real_workspace = 'gsl_fft_real_workspace_free($a);';
// Function: int gsl_fft_real_transform (double data[], size_t stride, size_t n, const gsl_fft_real_wavetable * wavetable, gsl_fft_real_workspace * work)
  fun gsl_fft_real_transform: +double * size * size * &gsl_fft_real_wavetable * &gsl_fft_real_workspace -> int = 'gsl_fft_real_transform($a)';
// Function: int gsl_fft_halfcomplex_transform (double data[], size_t stride, size_t n, const gsl_fft_halfcomplex_wavetable * wavetable, gsl_fft_real_workspace * work)
  fun gsl_fft_halfcomplex_transform: +double * size * size * &gsl_fft_halfcomplex_wavetable * &gsl_fft_real_workspace -> int = 'gsl_fft_halfcomplex_transform($a)';
// Function: int gsl_fft_real_unpack (const double real_coefficient[], gsl_complex_packed_array complex_coefficient, size_t stride, size_t n)
  fun gsl_fft_real_unpack: +double * gsl_complex_packed_array * size * size -> int = 'gsl_fft_real_unpack($a)';
// Function: int gsl_fft_halfcomplex_unpack (const double halfcomplex_coefficient[], gsl_complex_packed_array complex_coefficient, size_t stride, size_t n)
  fun gsl_fft_halfcomplex_unpack: +double * gsl_complex_packed_array * size * size -> int = 'gsl_fft_halfcomplex_unpack($a)';
//*****
// 17.00.00 Numerical-Integration.
//*****
// 17.01.00 Introduction.
//*****
// 17.02.00 QNG-non-adaptive-Gauss-Kronrod-integration.
// Function: int gsl_integration_qng (const gsl_function * f, double a, double b, double epsabs, double epsrel, double * result, double * abserr, size_t * neval)
  fun gsl_integration_qng: &gsl_function * double * double * double * double * &double * &double * &size -> int = 'gsl_integration_qng($a)';
//*****
// 17.03.00 QAG-adaptive-integration.
// Function: gsl_integration_workspace * gsl_integration_workspace_alloc (size_t n)
  fun gsl_integration_workspace_alloc: size -> &gsl_integration_workspace = 'gsl_integration_workspace_alloc($a)';
// Function: void gsl_integration_workspace_free (gsl_integration_workspace * w)
  proc gsl_integration_workspace_free: &gsl_integration_workspace = 'gsl_integration_workspace_free($a);';
// Function: int gsl_integration_qag (const gsl_function * f, double a, double b, double epsabs, double epsrel, size_t limit, int key, gsl_integration_workspace * workspace, double * result, double * abserr)
  fun gsl_integration_qag: &gsl_function * double * double * double * double * size * int * &gsl_integration_workspace * &double * &double -> int = 'gsl_integration_qag($a)';
//*****
// 17.04.00 QAGS-adaptive-integration-with-singularities.
// Function: int gsl_integration_qags (const gsl_function * f, double a, double b, double epsabs, double epsrel, size_t limit, gsl_integration_workspace * workspace, double * result, double * abserr)
  fun gsl_integration_qags: &gsl_function * double * double * double * double * size * &gsl_integration_workspace * &double * &double -> int = 'gsl_integration_qags($a)';
//*****
// 17.05.00 QAGP-adaptive-integration-with-known-singular-points.
// Function: int gsl_integration_qagp (const gsl_function * f, double * pts, size_t npts, double epsabs, double epsrel, size_t limit, gsl_integration_workspace * workspace, double * result, double * abserr)
  fun gsl_integration_qagp: &gsl_function * &double * size * double * double * size * &gsl_integration_workspace * &double * &double -> int = 'gsl_integration_qagp($a)';
//*****
// 17.06.00 QAGI-adaptive-integration-on-infinite-intervals.
// Function: int gsl_integration_qagi (gsl_function * f, double epsabs, double epsrel, size_t limit, gsl_integration_workspace * workspace, double * result, double * abserr)
  fun gsl_integration_qagi: &gsl_function * double * double * size * &gsl_integration_workspace * &double * &double -> int = 'gsl_integration_qagi($a)';
// Function: int gsl_integration_qagiu (gsl_function * f, double a, double epsabs, double epsrel, size_t limit, gsl_integration_workspace * workspace, double * result, double * abserr)
  fun gsl_integration_qagiu: &gsl_function * double * double * double * size * &gsl_integration_workspace * &double * &double -> int = 'gsl_integration_qagiu($a)';
// Function: int gsl_integration_qagil (gsl_function * f, double b, double epsabs, double epsrel, size_t limit, gsl_integration_workspace * workspace, double * result, double * abserr)
  fun gsl_integration_qagil: &gsl_function * double * double * double * size * &gsl_integration_workspace * &double * &double -> int = 'gsl_integration_qagil($a)';
//*****
// 17.07.00 QAWC-adaptive-integration-for-Cauchy-principal-values.
// Function: int gsl_integration_qawc (gsl_function * f, double a, double b, double c, double epsabs, double epsrel, size_t limit, gsl_integration_workspace * workspace, double * result, double * abserr)
  fun gsl_integration_qawc: &gsl_function * double * double * double * double * double * size * &gsl_integration_workspace * &double * &double -> int = 'gsl_integration_qawc($a)';
//*****
// 17.08.00 QAWS-adaptive-integration-for-singular-functions.
// Function: gsl_integration_qaws_table * gsl_integration_qaws_table_alloc (double alpha, double beta, int mu, int nu)
  fun gsl_integration_qaws_table_alloc: double * double * int * int -> &gsl_integration_qaws_table = 'gsl_integration_qaws_table_alloc($a)';
// Function: int gsl_integration_qaws_table_set (gsl_integration_qaws_table * t, double alpha, double beta, int mu, int nu)
  fun gsl_integration_qaws_table_set: &gsl_integration_qaws_table * double * double * int * int -> int = 'gsl_integration_qaws_table_set($a)';
// Function: void gsl_integration_qaws_table_free (gsl_integration_qaws_table * t)
  proc gsl_integration_qaws_table_free: &gsl_integration_qaws_table = 'gsl_integration_qaws_table_free($a);';
// Function: int gsl_integration_qaws (gsl_function * f, const double a, const double b, gsl_integration_qaws_table * t, const double epsabs, const double epsrel, const size_t limit, gsl_integration_workspace * workspace, double * result, double * abserr)
  fun gsl_integration_qaws: &gsl_function * double * double * &gsl_integration_qaws_table * double * double * size * &gsl_integration_workspace * &double * &double -> int = 'gsl_integration_qaws($a)';
//*****
// 17.09.00 QAWS-adaptive-integration-for-oscillatory-functions.
// Function: gsl_integration_qawo_table * gsl_integration_qawo_table_alloc (double omega, double L, enum gsl_integration_qawo_enum sine, size_t n)
  fun gsl_integration_qawo_table_alloc: double * double * gsl_integration_qawo_enum * size -> &gsl_integration_qawo_table = 'gsl_integration_qawo_table_alloc($a)';
// Function: int gsl_integration_qawo_table_set (gsl_integration_qawo_table * t, double omega, double L, enum gsl_integration_qawo_enum sine)
  fun gsl_integration_qawo_table_set: &gsl_integration_qawo_table * double * double * gsl_integration_qawo_enum -> int = 'gsl_integration_qawo_table_set($a)';
// Function: int gsl_integration_qawo_table_set_length (gsl_integration_qawo_table * t, double L)
  fun gsl_integration_qawo_table_set_length: &gsl_integration_qawo_table * double -> int = 'gsl_integration_qawo_table_set_length($a)';
// Function: void gsl_integration_qawo_table_free (gsl_integration_qawo_table * t)
  proc gsl_integration_qawo_table_free: &gsl_integration_qawo_table = 'gsl_integration_qawo_table_free($a);';
// Function: int gsl_integration_qawo (gsl_function * f, const double a, const double epsabs, const double epsrel, const size_t limit, gsl_integration_workspace * workspace, gsl_integration_qawo_table * wf, double * result, double * abserr)
  fun gsl_integration_qawo: &gsl_function * double * double * double * size * &gsl_integration_workspace * &gsl_integration_qawo_table * &double * &double -> int = 'gsl_integration_qawo($a)';
//*****
// 17.10.00 QAWS-adaptive-integration-for-Fourier-integrals.
// Function: int gsl_integration_qawf (gsl_function * f, const double a, const double epsabs, const size_t limit, gsl_integration_workspace * workspace, gsl_integration_workspace * cycle_workspace, gsl_integration_qawo_table * wf, double * result, double * abserr)
  fun gsl_integration_qawf: &gsl_function * double * double * size * &gsl_integration_workspace * &gsl_integration_workspace * &gsl_integration_qawo_table * &double * &double -> int = 'gsl_integration_qawf($a)';
//*****
// 17.11.00 CQUAD-doubly-adaptive-integration.
// Function: gsl_integration_cquad_workspace * gsl_integration_cquad_workspace_alloc (size_t n)
  fun gsl_integration_cquad_workspace_alloc: size -> &gsl_integration_cquad_workspace = 'gsl_integration_cquad_workspace_alloc($a)';
// Function: void gsl_integration_cquad_workspace_free (gsl_integration_cquad_workspace * w)
  proc gsl_integration_cquad_workspace_free: &gsl_integration_cquad_workspace = 'gsl_integration_cquad_workspace_free($a);';
// Function: int gsl_integration_cquad (const gsl_function * f, double a, double b, double epsabs, double epsrel, gsl_integration_cquad_workspace * workspace, double * result, double * abserr, size_t * nevals)
  fun gsl_integration_cquad: &gsl_function * double * double * double * double * &gsl_integration_cquad_workspace * &double * &double * &size -> int = 'gsl_integration_cquad($a)';
//*****
// 17.12.00 Gauss-Legendre-integration.
// Function: gsl_integration_glfixed_table * gsl_integration_glfixed_table_alloc (size_t n)
  fun gsl_integration_glfixed_table_alloc: size -> &gsl_integration_glfixed_table = 'gsl_integration_glfixed_table_alloc($a)';
// Function: double gsl_integration_glfixed (const gsl_function * f, double a, double b, const gsl_integration_glfixed_table * t)
  fun gsl_integration_glfixed: &gsl_function * double * double * &gsl_integration_glfixed_table -> double = 'gsl_integration_glfixed($a)';
// Function: int gsl_integration_glfixed_point (double a, double b, size_t i, double * xi, double * wi, const gsl_integration_glfixed_table * t)
  fun gsl_integration_glfixed_point: double * double * size * &double * &double * &gsl_integration_glfixed_table -> int = 'gsl_integration_glfixed_point($a)';
// Function: void gsl_integration_glfixed_table_free (gsl_integration_glfixed_table * t)
  proc gsl_integration_glfixed_table_free: &gsl_integration_glfixed_table = 'gsl_integration_glfixed_table_free($a);';
//*****
// 17.13.00 Error-codes.
//*****
// 18.00.00 Random-Number-Generation.
//*****
// 18.01.00 General-comments-on-random-numbers.
//*****
// 18.02.00 The-Random-Number-Generator-Interface.
//*****
// 18.03.00 Random-number-generator-initialisation.
// Function: gsl_rng * gsl_rng_alloc (const gsl_rng_type * T)
  fun gsl_rng_alloc: &gsl_rng_type -> &gsl_rng = 'gsl_rng_alloc($a)';
// Function: void gsl_rng_set (const gsl_rng * r, unsigned long int s)
  proc gsl_rng_set: &gsl_rng * ulong = 'gsl_rng_set($a);';
// Function: void gsl_rng_free (gsl_rng * r)
  proc gsl_rng_free: &gsl_rng = 'gsl_rng_free($a);';
//*****
// 18.04.00 Sampling-from-a-random-number-generator.
// Function: unsigned long int gsl_rng_get (const gsl_rng * r)
  fun gsl_rng_get: &gsl_rng -> ulong = 'gsl_rng_get($a)';
// Function: double gsl_rng_uniform (const gsl_rng * r)
  fun gsl_rng_uniform: &gsl_rng -> double = 'gsl_rng_uniform($a)';
// Function: double gsl_rng_uniform_pos (const gsl_rng * r)
  fun gsl_rng_uniform_pos: &gsl_rng -> double = 'gsl_rng_uniform_pos($a)';
// Function: unsigned long int gsl_rng_uniform_int (const gsl_rng * r, unsigned long int n)
  fun gsl_rng_uniform_int: &gsl_rng * ulong -> ulong = 'gsl_rng_uniform_int($a)';
//*****
// 18.05.00 Auxilliary-random-number-generator-functions.
// Function: const char * gsl_rng_name (const gsl_rng * r)
  fun gsl_rng_name: &gsl_rng -> &char = 'gsl_rng_name($a)';
// Function: unsigned long int gsl_rng_max (const gsl_rng * r)
  fun gsl_rng_max: &gsl_rng -> ulong = 'gsl_rng_max($a)';
// Function: unsigned long int gsl_rng_min (const gsl_rng * r)
  fun gsl_rng_min: &gsl_rng -> ulong = 'gsl_rng_min($a)';
// Function: void * gsl_rng_state (const gsl_rng * r)
  fun gsl_rng_state: &gsl_rng -> &void = 'gsl_rng_state($a)';
// Function: size_t gsl_rng_size (const gsl_rng * r)
  fun gsl_rng_size: &gsl_rng -> size = 'gsl_rng_size($a)';
// Function: const gsl_rng_type ** gsl_rng_types_setup (void)
  fun gsl_rng_types_setup: unit -> &&gsl_rng_type = 'gsl_rng_types_setup($a)';
//*****
// 18.06.00 Random-number-environment-variables.
// Function: const gsl_rng_type * gsl_rng_env_setup (void)
  fun gsl_rng_env_setup: unit -> &gsl_rng_type = 'gsl_rng_env_setup($a)';
//*****
// 18.07.00 Copying-random-number-generator-state.
// Function: int gsl_rng_memcpy (gsl_rng * dest, const gsl_rng * src)
  fun gsl_rng_memcpy: &gsl_rng * &gsl_rng -> int = 'gsl_rng_memcpy($a)';
// Function: gsl_rng * gsl_rng_clone (const gsl_rng * r)
  fun gsl_rng_clone: &gsl_rng -> &gsl_rng = 'gsl_rng_clone($a)';
//*****
// 18.08.00 Reading-and-writing-random-number-generator-state.
// Function: int gsl_rng_fwrite (FILE * stream, const gsl_rng * r)
  fun gsl_rng_fwrite: &FILE * &gsl_rng -> int = 'gsl_rng_fwrite($a)';
// Function: int gsl_rng_fread (FILE * stream, gsl_rng * r)
  fun gsl_rng_fread: &FILE * &gsl_rng -> int = 'gsl_rng_fread($a)';
//*****
// 18.09.00 Random-number-generator-algorithms.
//*****
// 18.10.00 Unix-random-number-generators.
//*****
// 18.11.00 Other-random-number-generators.
//*****
// 19.00.00 Quasi-Random-Sequences.
//*****
// 19.01.00 Quasi-random-number-generator-initialisation.
// Function: gsl_qrng * gsl_qrng_alloc (const gsl_qrng_type * T, unsigned int d)
  fun gsl_qrng_alloc: &gsl_qrng_type * uint -> &gsl_qrng = 'gsl_qrng_alloc($a)';
// Function: void gsl_qrng_free (gsl_qrng * q)
  proc gsl_qrng_free: &gsl_qrng = 'gsl_qrng_free($a);';
// Function: void gsl_qrng_init (gsl_qrng * q)
  proc gsl_qrng_init: &gsl_qrng = 'gsl_qrng_init($a);';
//*****
// 19.02.00 Sampling-from-a-quasi-random-number-generator.
// Function: int gsl_qrng_get (const gsl_qrng * q, double x[])
  fun gsl_qrng_get: &gsl_qrng * +double -> int = 'gsl_qrng_get($a)';
//*****
// 19.03.00 Auxilliary-quasi-random-number-generator-functions.
// Function: const char * gsl_qrng_name (const gsl_qrng * q)
  fun gsl_qrng_name: &gsl_qrng -> &char = 'gsl_qrng_name($a)';
// Function: size_t gsl_qrng_size (const gsl_qrng * q)
  fun gsl_qrng_size: &gsl_qrng -> size = 'gsl_qrng_size($a)';
// Function: void * gsl_qrng_state (const gsl_qrng * q)
  fun gsl_qrng_state: &gsl_qrng -> &void = 'gsl_qrng_state($a)';
//*****
// 19.04.00 Saving-and-resorting-quasi-random-number-generator-state.
// Function: int gsl_qrng_memcpy (gsl_qrng * dest, const gsl_qrng * src)
  fun gsl_qrng_memcpy: &gsl_qrng * &gsl_qrng -> int = 'gsl_qrng_memcpy($a)';
// Function: gsl_qrng * gsl_qrng_clone (const gsl_qrng * q)
  fun gsl_qrng_clone: &gsl_qrng -> &gsl_qrng = 'gsl_qrng_clone($a)';
//*****
// 19.05.00 Quasi-random-number-generator-algorithms.
//*****
// 21.00.00 Statistics.
//*****
// 21.01.00 Mean-and-standard-deviation-and-variance.
// Function: double gsl_stats_mean (const double data[], size_t stride, size_t n)
  fun gsl_stats_mean: +double * size * size -> double = 'gsl_stats_mean($a)';
// Function: double gsl_stats_variance (const double data[], size_t stride, size_t n)
  fun gsl_stats_variance: +double * size * size -> double = 'gsl_stats_variance($a)';
// Function: double gsl_stats_variance_m (const double data[], size_t stride, size_t n, double mean)
  fun gsl_stats_variance_m: +double * size * size * double -> double = 'gsl_stats_variance_m($a)';
// Function: double gsl_stats_sd (const double data[], size_t stride, size_t n)
  fun gsl_stats_sd: +double * size * size -> double = 'gsl_stats_sd($a)';
// Function: double gsl_stats_sd_m (const double data[], size_t stride, size_t n, double mean)
  fun gsl_stats_sd_m: +double * size * size * double -> double = 'gsl_stats_sd_m($a)';
// Function: double gsl_stats_tss (const double data[], size_t stride, size_t n)
  fun gsl_stats_tss: +double * size * size -> double = 'gsl_stats_tss($a)';
// Function: double gsl_stats_tss_m (const double data[], size_t stride, size_t n, double mean)
  fun gsl_stats_tss_m: +double * size * size * double -> double = 'gsl_stats_tss_m($a)';
// Function: double gsl_stats_variance_with_fixed_mean (const double data[], size_t stride, size_t n, double mean)
  fun gsl_stats_variance_with_fixed_mean: +double * size * size * double -> double = 'gsl_stats_variance_with_fixed_mean($a)';
// Function: double gsl_stats_sd_with_fixed_mean (const double data[], size_t stride, size_t n, double mean)
  fun gsl_stats_sd_with_fixed_mean: +double * size * size * double -> double = 'gsl_stats_sd_with_fixed_mean($a)';
//*****
// 21.02.00 Absolute-deviation.
// Function: double gsl_stats_absdev (const double data[], size_t stride, size_t n)
  fun gsl_stats_absdev: +double * size * size -> double = 'gsl_stats_absdev($a)';
// Function: double gsl_stats_absdev_m (const double data[], size_t stride, size_t n, double mean)
  fun gsl_stats_absdev_m: +double * size * size * double -> double = 'gsl_stats_absdev_m($a)';
//*****
// 21.03.00 Higher-moments-(skew-and-kurtosis).
// Function: double gsl_stats_skew (const double data[], size_t stride, size_t n)
  fun gsl_stats_skew: +double * size * size -> double = 'gsl_stats_skew($a)';
// Function: double gsl_stats_skew_m_sd (const double data[], size_t stride, size_t n, double mean, double sd)
  fun gsl_stats_skew_m_sd: +double * size * size * double * double -> double = 'gsl_stats_skew_m_sd($a)';
// Function: double gsl_stats_kurtosis (const double data[], size_t stride, size_t n)
  fun gsl_stats_kurtosis: +double * size * size -> double = 'gsl_stats_kurtosis($a)';
// Function: double gsl_stats_kurtosis_m_sd (const double data[], size_t stride, size_t n, double mean, double sd)
  fun gsl_stats_kurtosis_m_sd: +double * size * size * double * double -> double = 'gsl_stats_kurtosis_m_sd($a)';
//*****
// 21.04.00 Autocorrelation.
// Function: double gsl_stats_lag1_autocorrelation (const double data[], const size_t stride, const size_t n)
  fun gsl_stats_lag1_autocorrelation: +double * size * size -> double = 'gsl_stats_lag1_autocorrelation($a)';
// Function: double gsl_stats_lag1_autocorrelation_m (const double data[], const size_t stride, const size_t n, const double mean)
  fun gsl_stats_lag1_autocorrelation_m: +double * size * size * double -> double = 'gsl_stats_lag1_autocorrelation_m($a)';
//*****
// 21.05.00 Covariance.
// Function: double gsl_stats_covariance (const double data1[], const size_t stride1, const double data2[], const size_t stride2, const size_t n)
  fun gsl_stats_covariance: +double * size * +double * size * size -> double = 'gsl_stats_covariance($a)';
// Function: double gsl_stats_covariance_m (const double data1[], const size_t stride1, const double data2[], const size_t stride2, const size_t n, const double mean1, const double mean2)
  fun gsl_stats_covariance_m: +double * size * +double * size * size * double * double -> double = 'gsl_stats_covariance_m($a)';
//*****
// 21.06.00 Correlation.
// Function: double gsl_stats_correlation (const double data1[], const size_t stride1, const double data2[], const size_t stride2, const size_t n)
  fun gsl_stats_correlation: +double * size * +double * size * size -> double = 'gsl_stats_correlation($a)';
// Function: double gsl_stats_spearman (const double data1[], const size_t stride1, const double data2[], const size_t stride2, const size_t n, double work[])
  fun gsl_stats_spearman: +double * size * +double * size * size * +double -> double = 'gsl_stats_spearman($a)';
//*****
// 21.07.00 Weighted-Samples.
// Function: double gsl_stats_wmean (const double w[], size_t wstride, const double data[], size_t stride, size_t n)
  fun gsl_stats_wmean: +double * size * +double * size * size -> double = 'gsl_stats_wmean($a)';
// Function: double gsl_stats_wvariance (const double w[], size_t wstride, const double data[], size_t stride, size_t n)
  fun gsl_stats_wvariance: +double * size * +double * size * size -> double = 'gsl_stats_wvariance($a)';
// Function: double gsl_stats_wvariance_m (const double w[], size_t wstride, const double data[], size_t stride, size_t n, double wmean)
  fun gsl_stats_wvariance_m: +double * size * +double * size * size * double -> double = 'gsl_stats_wvariance_m($a)';
// Function: double gsl_stats_wsd (const double w[], size_t wstride, const double data[], size_t stride, size_t n)
  fun gsl_stats_wsd: +double * size * +double * size * size -> double = 'gsl_stats_wsd($a)';
// Function: double gsl_stats_wsd_m (const double w[], size_t wstride, const double data[], size_t stride, size_t n, double wmean)
  fun gsl_stats_wsd_m: +double * size * +double * size * size * double -> double = 'gsl_stats_wsd_m($a)';
// Function: double gsl_stats_wvariance_with_fixed_mean (const double w[], size_t wstride, const double data[], size_t stride, size_t n, const double mean)
  fun gsl_stats_wvariance_with_fixed_mean: +double * size * +double * size * size * double -> double = 'gsl_stats_wvariance_with_fixed_mean($a)';
// Function: double gsl_stats_wsd_with_fixed_mean (const double w[], size_t wstride, const double data[], size_t stride, size_t n, const double mean)
  fun gsl_stats_wsd_with_fixed_mean: +double * size * +double * size * size * double -> double = 'gsl_stats_wsd_with_fixed_mean($a)';
// Function: double gsl_stats_wtss (const double w[], const size_t wstride, const double data[], size_t stride, size_t n)
  fun gsl_stats_wtss: +double * size * +double * size * size -> double = 'gsl_stats_wtss($a)';
// Function: double gsl_stats_wtss_m (const double w[], const size_t wstride, const double data[], size_t stride, size_t n, double wmean)
  fun gsl_stats_wtss_m: +double * size * +double * size * size * double -> double = 'gsl_stats_wtss_m($a)';
// Function: double gsl_stats_wabsdev (const double w[], size_t wstride, const double data[], size_t stride, size_t n)
  fun gsl_stats_wabsdev: +double * size * +double * size * size -> double = 'gsl_stats_wabsdev($a)';
// Function: double gsl_stats_wabsdev_m (const double w[], size_t wstride, const double data[], size_t stride, size_t n, double wmean)
  fun gsl_stats_wabsdev_m: +double * size * +double * size * size * double -> double = 'gsl_stats_wabsdev_m($a)';
// Function: double gsl_stats_wskew (const double w[], size_t wstride, const double data[], size_t stride, size_t n)
  fun gsl_stats_wskew: +double * size * +double * size * size -> double = 'gsl_stats_wskew($a)';
// Function: double gsl_stats_wskew_m_sd (const double w[], size_t wstride, const double data[], size_t stride, size_t n, double wmean, double wsd)
  fun gsl_stats_wskew_m_sd: +double * size * +double * size * size * double * double -> double = 'gsl_stats_wskew_m_sd($a)';
// Function: double gsl_stats_wkurtosis (const double w[], size_t wstride, const double data[], size_t stride, size_t n)
  fun gsl_stats_wkurtosis: +double * size * +double * size * size -> double = 'gsl_stats_wkurtosis($a)';
// Function: double gsl_stats_wkurtosis_m_sd (const double w[], size_t wstride, const double data[], size_t stride, size_t n, double wmean, double wsd)
  fun gsl_stats_wkurtosis_m_sd: +double * size * +double * size * size * double * double -> double = 'gsl_stats_wkurtosis_m_sd($a)';
//*****
// 21.08.00 Maximum-and-Minimum-values.
// Function: double gsl_stats_max (const double data[], size_t stride, size_t n)
  fun gsl_stats_max: +double * size * size -> double = 'gsl_stats_max($a)';
// Function: double gsl_stats_min (const double data[], size_t stride, size_t n)
  fun gsl_stats_min: +double * size * size -> double = 'gsl_stats_min($a)';
// Function: void gsl_stats_minmax (double * min, double * max, const double data[], size_t stride, size_t n)
  proc gsl_stats_minmax: &double * &double * +double * size * size = 'gsl_stats_minmax($a);';
// Function: size_t gsl_stats_max_index (const double data[], size_t stride, size_t n)
  fun gsl_stats_max_index: +double * size * size -> size = 'gsl_stats_max_index($a)';
// Function: size_t gsl_stats_min_index (const double data[], size_t stride, size_t n)
  fun gsl_stats_min_index: +double * size * size -> size = 'gsl_stats_min_index($a)';
// Function: void gsl_stats_minmax_index (size_t * min_index, size_t * max_index, const double data[], size_t stride, size_t n)
  proc gsl_stats_minmax_index: &size * &size * +double * size * size = 'gsl_stats_minmax_index($a);';
//*****
// 21.09.00 Median-and-Percentiles.
// Function: double gsl_stats_median_from_sorted_data (const double sorted_data[], size_t stride, size_t n)
  fun gsl_stats_median_from_sorted_data: +double * size * size -> double = 'gsl_stats_median_from_sorted_data($a)';
// Function: double gsl_stats_quantile_from_sorted_data (const double sorted_data[], size_t stride, size_t n, double f)
  fun gsl_stats_quantile_from_sorted_data: +double * size * size * double -> double = 'gsl_stats_quantile_from_sorted_data($a)';
//*****
// 22.00.00 Histograms.
//*****
// 22.01.00 The-histogram-struct.
//*****
// 22.02.00 Histogram-allocation.
// Function: gsl_histogram * gsl_histogram_alloc (size_t n)
  fun gsl_histogram_alloc: size -> &gsl_histogram = 'gsl_histogram_alloc($a)';
// Function: int gsl_histogram_set_ranges (gsl_histogram * h, const double range[], size_t size)
  fun gsl_histogram_set_ranges: &gsl_histogram * +double * size -> int = 'gsl_histogram_set_ranges($a)';
// Function: int gsl_histogram_set_ranges_uniform (gsl_histogram * h, double xmin, double xmax)
  fun gsl_histogram_set_ranges_uniform: &gsl_histogram * double * double -> int = 'gsl_histogram_set_ranges_uniform($a)';
// Function: void gsl_histogram_free (gsl_histogram * h)
  proc gsl_histogram_free: &gsl_histogram = 'gsl_histogram_free($a);';
//*****
// 22.03.00 Copying-Histograms.
// Function: int gsl_histogram_memcpy (gsl_histogram * dest, const gsl_histogram * src)
  fun gsl_histogram_memcpy: &gsl_histogram * &gsl_histogram -> int = 'gsl_histogram_memcpy($a)';
// Function: gsl_histogram * gsl_histogram_clone (const gsl_histogram * src)
  fun gsl_histogram_clone: &gsl_histogram -> &gsl_histogram = 'gsl_histogram_clone($a)';
//*****
// 22.04.00 Updating-and-accessing-histogram-elements.
// Function: int gsl_histogram_increment (gsl_histogram * h, double x)
  fun gsl_histogram_increment: &gsl_histogram * double -> int = 'gsl_histogram_increment($a)';
// Function: int gsl_histogram_accumulate (gsl_histogram * h, double x, double weight)
  fun gsl_histogram_accumulate: &gsl_histogram * double * double -> int = 'gsl_histogram_accumulate($a)';
// Function: double gsl_histogram_get (const gsl_histogram * h, size_t i)
  fun gsl_histogram_get: &gsl_histogram * size -> double = 'gsl_histogram_get($a)';
// Function: int gsl_histogram_get_range (const gsl_histogram * h, size_t i, double * lower, double * upper)
  fun gsl_histogram_get_range: &gsl_histogram * size * &double * &double -> int = 'gsl_histogram_get_range($a)';
// Function: double gsl_histogram_max (const gsl_histogram * h)
  fun gsl_histogram_max: &gsl_histogram -> double = 'gsl_histogram_max($a)';
// Function: double gsl_histogram_min (const gsl_histogram * h)
  fun gsl_histogram_min: &gsl_histogram -> double = 'gsl_histogram_min($a)';
// Function: size_t gsl_histogram_bins (const gsl_histogram * h)
  fun gsl_histogram_bins: &gsl_histogram -> size = 'gsl_histogram_bins($a)';
// Function: void gsl_histogram_reset (gsl_histogram * h)
  proc gsl_histogram_reset: &gsl_histogram = 'gsl_histogram_reset($a);';
//*****
// 22.05.00 Searching-historgram-ranges.
// Function: int gsl_histogram_find (const gsl_histogram * h, double x, size_t * i)
  fun gsl_histogram_find: &gsl_histogram * double * &size -> int = 'gsl_histogram_find($a)';
//*****
// 22.06.00 Histogram-Statistics.
// Function: double gsl_histogram_max_val (const gsl_histogram * h)
  fun gsl_histogram_max_val: &gsl_histogram -> double = 'gsl_histogram_max_val($a)';
// Function: size_t gsl_histogram_max_bin (const gsl_histogram * h)
  fun gsl_histogram_max_bin: &gsl_histogram -> size = 'gsl_histogram_max_bin($a)';
// Function: double gsl_histogram_min_val (const gsl_histogram * h)
  fun gsl_histogram_min_val: &gsl_histogram -> double = 'gsl_histogram_min_val($a)';
// Function: size_t gsl_histogram_min_bin (const gsl_histogram * h)
  fun gsl_histogram_min_bin: &gsl_histogram -> size = 'gsl_histogram_min_bin($a)';
// Function: double gsl_histogram_mean (const gsl_histogram * h)
  fun gsl_histogram_mean: &gsl_histogram -> double = 'gsl_histogram_mean($a)';
// Function: double gsl_histogram_sigma (const gsl_histogram * h)
  fun gsl_histogram_sigma: &gsl_histogram -> double = 'gsl_histogram_sigma($a)';
// Function: double gsl_histogram_sum (const gsl_histogram * h)
  fun gsl_histogram_sum: &gsl_histogram -> double = 'gsl_histogram_sum($a)';
//*****
// 22.07.00 Histogram-Operations.
// Function: int gsl_histogram_equal_bins_p (const gsl_histogram * h1, const gsl_histogram * h2)
  fun gsl_histogram_equal_bins_p: &gsl_histogram * &gsl_histogram -> int = 'gsl_histogram_equal_bins_p($a)';
// Function: int gsl_histogram_add (gsl_histogram * h1, const gsl_histogram * h2)
  fun gsl_histogram_add: &gsl_histogram * &gsl_histogram -> int = 'gsl_histogram_add($a)';
// Function: int gsl_histogram_sub (gsl_histogram * h1, const gsl_histogram * h2)
  fun gsl_histogram_sub: &gsl_histogram * &gsl_histogram -> int = 'gsl_histogram_sub($a)';
// Function: int gsl_histogram_mul (gsl_histogram * h1, const gsl_histogram * h2)
  fun gsl_histogram_mul: &gsl_histogram * &gsl_histogram -> int = 'gsl_histogram_mul($a)';
// Function: int gsl_histogram_div (gsl_histogram * h1, const gsl_histogram * h2)
  fun gsl_histogram_div: &gsl_histogram * &gsl_histogram -> int = 'gsl_histogram_div($a)';
// Function: int gsl_histogram_scale (gsl_histogram * h, double scale)
  fun gsl_histogram_scale: &gsl_histogram * double -> int = 'gsl_histogram_scale($a)';
// Function: int gsl_histogram_shift (gsl_histogram * h, double offset)
  fun gsl_histogram_shift: &gsl_histogram * double -> int = 'gsl_histogram_shift($a)';
//*****
// 22.08.00 Reading-and-writing-histograms.
// Function: int gsl_histogram_fwrite (FILE * stream, const gsl_histogram * h)
  fun gsl_histogram_fwrite: &FILE * &gsl_histogram -> int = 'gsl_histogram_fwrite($a)';
// Function: int gsl_histogram_fread (FILE * stream, gsl_histogram * h)
  fun gsl_histogram_fread: &FILE * &gsl_histogram -> int = 'gsl_histogram_fread($a)';
// Function: int gsl_histogram_fprintf (FILE * stream, const gsl_histogram * h, const char * range_format, const char * bin_format)
  fun gsl_histogram_fprintf: &FILE * &gsl_histogram * &char * &char -> int = 'gsl_histogram_fprintf($a)';
// Function: int gsl_histogram_fscanf (FILE * stream, gsl_histogram * h)
  fun gsl_histogram_fscanf: &FILE * &gsl_histogram -> int = 'gsl_histogram_fscanf($a)';
//*****
// 22.09.00 Resampling-from-histograms.
//*****
// 22.10.00 The-histogram-probability-distribution-struct.
// Function: gsl_histogram_pdf * gsl_histogram_pdf_alloc (size_t n)
  fun gsl_histogram_pdf_alloc: size -> &gsl_histogram_pdf = 'gsl_histogram_pdf_alloc($a)';
// Function: int gsl_histogram_pdf_init (gsl_histogram_pdf * p, const gsl_histogram * h)
  fun gsl_histogram_pdf_init: &gsl_histogram_pdf * &gsl_histogram -> int = 'gsl_histogram_pdf_init($a)';
// Function: void gsl_histogram_pdf_free (gsl_histogram_pdf * p)
  proc gsl_histogram_pdf_free: &gsl_histogram_pdf = 'gsl_histogram_pdf_free($a);';
// Function: double gsl_histogram_pdf_sample (const gsl_histogram_pdf * p, double r)
  fun gsl_histogram_pdf_sample: &gsl_histogram_pdf * double -> double = 'gsl_histogram_pdf_sample($a)';
//*****
// 22.12.00 Two-dimensional-histograms.
//*****
// 22.13.00 The-2D-histogram-struct.
//*****
// 22.14.00 2D-histogram-allocation.
// Function: gsl_histogram2d * gsl_histogram2d_alloc (size_t nx, size_t ny)
  fun gsl_histogram2d_alloc: size * size -> &gsl_histogram2d = 'gsl_histogram2d_alloc($a)';
// Function: int gsl_histogram2d_set_ranges (gsl_histogram2d * h, const double xrange[], size_t xsize, const double yrange[], size_t ysize)
  fun gsl_histogram2d_set_ranges: &gsl_histogram2d * +double * size * +double * size -> int = 'gsl_histogram2d_set_ranges($a)';
// Function: int gsl_histogram2d_set_ranges_uniform (gsl_histogram2d * h, double xmin, double xmax, double ymin, double ymax)
  fun gsl_histogram2d_set_ranges_uniform: &gsl_histogram2d * double * double * double * double -> int = 'gsl_histogram2d_set_ranges_uniform($a)';
// Function: void gsl_histogram2d_free (gsl_histogram2d * h)
  proc gsl_histogram2d_free: &gsl_histogram2d = 'gsl_histogram2d_free($a);';
//*****
// 22.15.00 Copying-2D-Histograms.
// Function: int gsl_histogram2d_memcpy (gsl_histogram2d * dest, const gsl_histogram2d * src)
  fun gsl_histogram2d_memcpy: &gsl_histogram2d * &gsl_histogram2d -> int = 'gsl_histogram2d_memcpy($a)';
// Function: gsl_histogram2d * gsl_histogram2d_clone (const gsl_histogram2d * src)
  fun gsl_histogram2d_clone: &gsl_histogram2d -> &gsl_histogram2d = 'gsl_histogram2d_clone($a)';
//*****
// 22.16.00 Updating-and-accessing-2D-histogram-elements.
// Function: int gsl_histogram2d_increment (gsl_histogram2d * h, double x, double y)
  fun gsl_histogram2d_increment: &gsl_histogram2d * double * double -> int = 'gsl_histogram2d_increment($a)';
// Function: int gsl_histogram2d_accumulate (gsl_histogram2d * h, double x, double y, double weight)
  fun gsl_histogram2d_accumulate: &gsl_histogram2d * double * double * double -> int = 'gsl_histogram2d_accumulate($a)';
// Function: double gsl_histogram2d_get (const gsl_histogram2d * h, size_t i, size_t j)
  fun gsl_histogram2d_get: &gsl_histogram2d * size * size -> double = 'gsl_histogram2d_get($a)';
// Function: int gsl_histogram2d_get_xrange (const gsl_histogram2d * h, size_t i, double * xlower, double * xupper)
  fun gsl_histogram2d_get_xrange: &gsl_histogram2d * size * &double * &double -> int = 'gsl_histogram2d_get_xrange($a)';
// Function: int gsl_histogram2d_get_yrange (const gsl_histogram2d * h, size_t j, double * ylower, double * yupper)
  fun gsl_histogram2d_get_yrange: &gsl_histogram2d * size * &double * &double -> int = 'gsl_histogram2d_get_yrange($a)';
// Function: double gsl_histogram2d_xmax (const gsl_histogram2d * h)
  fun gsl_histogram2d_xmax: &gsl_histogram2d -> double = 'gsl_histogram2d_xmax($a)';
// Function: double gsl_histogram2d_xmin (const gsl_histogram2d * h)
  fun gsl_histogram2d_xmin: &gsl_histogram2d -> double = 'gsl_histogram2d_xmin($a)';
// Function: size_t gsl_histogram2d_nx (const gsl_histogram2d * h)
  fun gsl_histogram2d_nx: &gsl_histogram2d -> size = 'gsl_histogram2d_nx($a)';
// Function: double gsl_histogram2d_ymax (const gsl_histogram2d * h)
  fun gsl_histogram2d_ymax: &gsl_histogram2d -> double = 'gsl_histogram2d_ymax($a)';
// Function: double gsl_histogram2d_ymin (const gsl_histogram2d * h)
  fun gsl_histogram2d_ymin: &gsl_histogram2d -> double = 'gsl_histogram2d_ymin($a)';
// Function: size_t gsl_histogram2d_ny (const gsl_histogram2d * h)
  fun gsl_histogram2d_ny: &gsl_histogram2d -> size = 'gsl_histogram2d_ny($a)';
// Function: void gsl_histogram2d_reset (gsl_histogram2d * h)
  proc gsl_histogram2d_reset: &gsl_histogram2d = 'gsl_histogram2d_reset($a);';
//*****
// 22.17.00 Searching-2D-histogram-ranges.
// Function: int gsl_histogram2d_find (const gsl_histogram2d * h, double x, double y, size_t * i, size_t * j)
  fun gsl_histogram2d_find: &gsl_histogram2d * double * double * &size * &size -> int = 'gsl_histogram2d_find($a)';
//*****
// 22.18.00 2D-Histogram-Statistics.
// Function: double gsl_histogram2d_max_val (const gsl_histogram2d * h)
  fun gsl_histogram2d_max_val: &gsl_histogram2d -> double = 'gsl_histogram2d_max_val($a)';
// Function: void gsl_histogram2d_max_bin (const gsl_histogram2d * h, size_t * i, size_t * j)
  proc gsl_histogram2d_max_bin: &gsl_histogram2d * &size * &size = 'gsl_histogram2d_max_bin($a);';
// Function: double gsl_histogram2d_min_val (const gsl_histogram2d * h)
  fun gsl_histogram2d_min_val: &gsl_histogram2d -> double = 'gsl_histogram2d_min_val($a)';
// Function: void gsl_histogram2d_min_bin (const gsl_histogram2d * h, size_t * i, size_t * j)
  proc gsl_histogram2d_min_bin: &gsl_histogram2d * &size * &size = 'gsl_histogram2d_min_bin($a);';
// Function: double gsl_histogram2d_xmean (const gsl_histogram2d * h)
  fun gsl_histogram2d_xmean: &gsl_histogram2d -> double = 'gsl_histogram2d_xmean($a)';
// Function: double gsl_histogram2d_ymean (const gsl_histogram2d * h)
  fun gsl_histogram2d_ymean: &gsl_histogram2d -> double = 'gsl_histogram2d_ymean($a)';
// Function: double gsl_histogram2d_xsigma (const gsl_histogram2d * h)
  fun gsl_histogram2d_xsigma: &gsl_histogram2d -> double = 'gsl_histogram2d_xsigma($a)';
// Function: double gsl_histogram2d_ysigma (const gsl_histogram2d * h)
  fun gsl_histogram2d_ysigma: &gsl_histogram2d -> double = 'gsl_histogram2d_ysigma($a)';
// Function: double gsl_histogram2d_cov (const gsl_histogram2d * h)
  fun gsl_histogram2d_cov: &gsl_histogram2d -> double = 'gsl_histogram2d_cov($a)';
// Function: double gsl_histogram2d_sum (const gsl_histogram2d * h)
  fun gsl_histogram2d_sum: &gsl_histogram2d -> double = 'gsl_histogram2d_sum($a)';
//*****
// 22.19.00 2D-Histogram-Operations.
// Function: int gsl_histogram2d_equal_bins_p (const gsl_histogram2d * h1, const gsl_histogram2d * h2)
  fun gsl_histogram2d_equal_bins_p: &gsl_histogram2d * &gsl_histogram2d -> int = 'gsl_histogram2d_equal_bins_p($a)';
// Function: int gsl_histogram2d_add (gsl_histogram2d * h1, const gsl_histogram2d * h2)
  fun gsl_histogram2d_add: &gsl_histogram2d * &gsl_histogram2d -> int = 'gsl_histogram2d_add($a)';
// Function: int gsl_histogram2d_sub (gsl_histogram2d * h1, const gsl_histogram2d * h2)
  fun gsl_histogram2d_sub: &gsl_histogram2d * &gsl_histogram2d -> int = 'gsl_histogram2d_sub($a)';
// Function: int gsl_histogram2d_mul (gsl_histogram2d * h1, const gsl_histogram2d * h2)
  fun gsl_histogram2d_mul: &gsl_histogram2d * &gsl_histogram2d -> int = 'gsl_histogram2d_mul($a)';
// Function: int gsl_histogram2d_div (gsl_histogram2d * h1, const gsl_histogram2d * h2)
  fun gsl_histogram2d_div: &gsl_histogram2d * &gsl_histogram2d -> int = 'gsl_histogram2d_div($a)';
// Function: int gsl_histogram2d_scale (gsl_histogram2d * h, double scale)
  fun gsl_histogram2d_scale: &gsl_histogram2d * double -> int = 'gsl_histogram2d_scale($a)';
// Function: int gsl_histogram2d_shift (gsl_histogram2d * h, double offset)
  fun gsl_histogram2d_shift: &gsl_histogram2d * double -> int = 'gsl_histogram2d_shift($a)';
//*****
// 22.20.00 Reading-and-writing-2D-histograms.
// Function: int gsl_histogram2d_fwrite (FILE * stream, const gsl_histogram2d * h)
  fun gsl_histogram2d_fwrite: &FILE * &gsl_histogram2d -> int = 'gsl_histogram2d_fwrite($a)';
// Function: int gsl_histogram2d_fread (FILE * stream, gsl_histogram2d * h)
  fun gsl_histogram2d_fread: &FILE * &gsl_histogram2d -> int = 'gsl_histogram2d_fread($a)';
// Function: int gsl_histogram2d_fprintf (FILE * stream, const gsl_histogram2d * h, const char * range_format, const char * bin_format)
  fun gsl_histogram2d_fprintf: &FILE * &gsl_histogram2d * &char * &char -> int = 'gsl_histogram2d_fprintf($a)';
// Function: int gsl_histogram2d_fscanf (FILE * stream, gsl_histogram2d * h)
  fun gsl_histogram2d_fscanf: &FILE * &gsl_histogram2d -> int = 'gsl_histogram2d_fscanf($a)';
//*****
// 22.21.00 Resampling-from-2D-histograms.
// Function: gsl_histogram2d_pdf * gsl_histogram2d_pdf_alloc (size_t nx, size_t ny)
  fun gsl_histogram2d_pdf_alloc: size * size -> &gsl_histogram2d_pdf = 'gsl_histogram2d_pdf_alloc($a)';
// Function: int gsl_histogram2d_pdf_init (gsl_histogram2d_pdf * p, const gsl_histogram2d * h)
  fun gsl_histogram2d_pdf_init: &gsl_histogram2d_pdf * &gsl_histogram2d -> int = 'gsl_histogram2d_pdf_init($a)';
// Function: void gsl_histogram2d_pdf_free (gsl_histogram2d_pdf * p)
  proc gsl_histogram2d_pdf_free: &gsl_histogram2d_pdf = 'gsl_histogram2d_pdf_free($a);';
// Function: int gsl_histogram2d_pdf_sample (const gsl_histogram2d_pdf * p, double r1, double r2, double * x, double * y)
  fun gsl_histogram2d_pdf_sample: &gsl_histogram2d_pdf * double * double * &double * &double -> int = 'gsl_histogram2d_pdf_sample($a)';
//*****
// 23.00.00 N-tuples.
//*****
// 23.01.00 The-ntuple-struct.
//*****
// 23.02.00 Creating-ntuples.
// Function: gsl_ntuple * gsl_ntuple_create (char * filename, void * ntuple_data, size_t size)
  fun gsl_ntuple_create: &char * &void * size -> &gsl_ntuple = 'gsl_ntuple_create($a)';
//*****
// 23.03.00 Opening-an-existing-ntuple-file.
// Function: gsl_ntuple * gsl_ntuple_open (char * filename, void * ntuple_data, size_t size)
  fun gsl_ntuple_open: &char * &void * size -> &gsl_ntuple = 'gsl_ntuple_open($a)';
//*****
// 23.04.00 Writing-ntuples.
// Function: int gsl_ntuple_write (gsl_ntuple * ntuple)
  fun gsl_ntuple_write: &gsl_ntuple -> int = 'gsl_ntuple_write($a)';
// Function: int gsl_ntuple_bookdata (gsl_ntuple * ntuple)
  fun gsl_ntuple_bookdata: &gsl_ntuple -> int = 'gsl_ntuple_bookdata($a)';
//*****
// 23.05.00 Reading-ntuples.
// Function: int gsl_ntuple_read (gsl_ntuple * ntuple)
  fun gsl_ntuple_read: &gsl_ntuple -> int = 'gsl_ntuple_read($a)';
//*****
// 23.06.00 Closing-an-ntuple-file.
// Function: int gsl_ntuple_close (gsl_ntuple * ntuple)
  fun gsl_ntuple_close: &gsl_ntuple -> int = 'gsl_ntuple_close($a)';
//*****
// 23.07.00 Histogramming-ntuple-values.
// Function: int gsl_ntuple_project (gsl_histogram * h, gsl_ntuple * ntuple, gsl_ntuple_value_fn * value_func, gsl_ntuple_select_fn * select_func)
  fun gsl_ntuple_project: &gsl_histogram * &gsl_ntuple * &gsl_ntuple_value_fn * &gsl_ntuple_select_fn -> int = 'gsl_ntuple_project($a)';
//*****
// 24.00.00 Monte-Carlo-Integration.
//*****
// 24.01.00 Interface.
//*****
// 24.02.00 PLAIN-Monte-Carlo.
// Function: gsl_monte_plain_state * gsl_monte_plain_alloc (size_t dim)
  fun gsl_monte_plain_alloc: size -> &gsl_monte_plain_state = 'gsl_monte_plain_alloc($a)';
// Function: int gsl_monte_plain_init (gsl_monte_plain_state* s)
  fun gsl_monte_plain_init: &gsl_monte_plain_state -> int = 'gsl_monte_plain_init($a)';
// Function: int gsl_monte_plain_integrate (gsl_monte_function * f, const double xl[], const double xu[], size_t dim, size_t calls, gsl_rng * r, gsl_monte_plain_state * s, double * result, double * abserr)
  fun gsl_monte_plain_integrate: &gsl_monte_function * +double * +double * size * size * &gsl_rng * &gsl_monte_plain_state * &double * &double -> int = 'gsl_monte_plain_integrate($a)';
// Function: void gsl_monte_plain_free (gsl_monte_plain_state * s)
  proc gsl_monte_plain_free: &gsl_monte_plain_state = 'gsl_monte_plain_free($a);';
//*****
// 24.03.00 MISER.
// Function: gsl_monte_miser_state * gsl_monte_miser_alloc (size_t dim)
  fun gsl_monte_miser_alloc: size -> &gsl_monte_miser_state = 'gsl_monte_miser_alloc($a)';
// Function: int gsl_monte_miser_init (gsl_monte_miser_state* s)
  fun gsl_monte_miser_init: &gsl_monte_miser_state -> int = 'gsl_monte_miser_init($a)';
// Function: int gsl_monte_miser_integrate (gsl_monte_function * f, const double xl[], const double xu[], size_t dim, size_t calls, gsl_rng * r, gsl_monte_miser_state * s, double * result, double * abserr)
  fun gsl_monte_miser_integrate: &gsl_monte_function * +double * +double * size * size * &gsl_rng * &gsl_monte_miser_state * &double * &double -> int = 'gsl_monte_miser_integrate($a)';
// Function: void gsl_monte_miser_free (gsl_monte_miser_state * s)
  proc gsl_monte_miser_free: &gsl_monte_miser_state = 'gsl_monte_miser_free($a);';
// Function: void gsl_monte_miser_params_get (const gsl_monte_miser_state * s, gsl_monte_miser_params * params)
  proc gsl_monte_miser_params_get: &gsl_monte_miser_state * &gsl_monte_miser_params = 'gsl_monte_miser_params_get($a);';
// Function: void gsl_monte_miser_params_set (gsl_monte_miser_state * s, const gsl_monte_miser_params * params)
  proc gsl_monte_miser_params_set: &gsl_monte_miser_state * &gsl_monte_miser_params = 'gsl_monte_miser_params_set($a);';
//*****
// 24.04.00 VEGAS.
// Function: gsl_monte_vegas_state * gsl_monte_vegas_alloc (size_t dim)
  fun gsl_monte_vegas_alloc: size -> &gsl_monte_vegas_state = 'gsl_monte_vegas_alloc($a)';
// Function: int gsl_monte_vegas_init (gsl_monte_vegas_state* s)
  fun gsl_monte_vegas_init: &gsl_monte_vegas_state -> int = 'gsl_monte_vegas_init($a)';
// Function: int gsl_monte_vegas_integrate (gsl_monte_function * f, double xl[], double xu[], size_t dim, size_t calls, gsl_rng * r, gsl_monte_vegas_state * s, double * result, double * abserr)
  fun gsl_monte_vegas_integrate: &gsl_monte_function * +double * +double * size * size * &gsl_rng * &gsl_monte_vegas_state * &double * &double -> int = 'gsl_monte_vegas_integrate($a)';
// Function: void gsl_monte_vegas_free (gsl_monte_vegas_state * s)
  proc gsl_monte_vegas_free: &gsl_monte_vegas_state = 'gsl_monte_vegas_free($a);';
// Function: double gsl_monte_vegas_chisq (const gsl_monte_vegas_state * s)
  fun gsl_monte_vegas_chisq: &gsl_monte_vegas_state -> double = 'gsl_monte_vegas_chisq($a)';
// Function: void gsl_monte_vegas_runval (const gsl_monte_vegas_state * s, double * result, double * sigma)
  proc gsl_monte_vegas_runval: &gsl_monte_vegas_state * &double * &double = 'gsl_monte_vegas_runval($a);';
// Function: void gsl_monte_vegas_params_get (const gsl_monte_vegas_state * s, gsl_monte_vegas_params * params)
  proc gsl_monte_vegas_params_get: &gsl_monte_vegas_state * &gsl_monte_vegas_params = 'gsl_monte_vegas_params_get($a);';
// Function: void gsl_monte_vegas_params_set (gsl_monte_vegas_state * s, const gsl_monte_vegas_params * params)
  proc gsl_monte_vegas_params_set: &gsl_monte_vegas_state * &gsl_monte_vegas_params = 'gsl_monte_vegas_params_set($a);';
//*****
// 25.00.00 Simulated-Annealing.
//*****
// 25.01.00 Simulated-Annealing-algorithm.
//*****
// 25.02.00 Simulated-Annealing-functions.
// Function: void gsl_siman_solve (const gsl_rng * r, void * x0_p, gsl_siman_Efunc_t Ef, gsl_siman_step_t take_step, gsl_siman_metric_t distance, gsl_siman_print_t print_position, gsl_siman_copy_t copyfunc, gsl_siman_copy_construct_t copy_constructor, gsl_siman_destroy_t destructor, size_t element_size, gsl_siman_params_t params)
  proc gsl_siman_solve: &gsl_rng * &void * gsl_siman_Efunc_t * gsl_siman_step_t * gsl_siman_metric_t * gsl_siman_print_t * gsl_siman_copy_t * gsl_siman_copy_construct_t * gsl_siman_destroy_t * size * gsl_siman_params_t = 'gsl_siman_solve($a);';
//*****
// 26.00.00 Orindary-Differential-Equations.
//*****
// 26.01.00 Defining-the-ODE-System.
//*****
// 26.02.00 Stepping-Functions.
// Function: gsl_odeiv2_step * gsl_odeiv2_step_alloc (const gsl_odeiv2_step_type * T, size_t dim)
  fun gsl_odeiv2_step_alloc: &gsl_odeiv2_step_type * size -> &gsl_odeiv2_step = 'gsl_odeiv2_step_alloc($a)';
// Function: int gsl_odeiv2_step_reset (gsl_odeiv2_step * s)
  fun gsl_odeiv2_step_reset: &gsl_odeiv2_step -> int = 'gsl_odeiv2_step_reset($a)';
// Function: void gsl_odeiv2_step_free (gsl_odeiv2_step * s)
  proc gsl_odeiv2_step_free: &gsl_odeiv2_step = 'gsl_odeiv2_step_free($a);';
// Function: const char * gsl_odeiv2_step_name (const gsl_odeiv2_step * s)
  fun gsl_odeiv2_step_name: &gsl_odeiv2_step -> &char = 'gsl_odeiv2_step_name($a)';
// Function: unsigned int gsl_odeiv2_step_order (const gsl_odeiv2_step * s)
  fun gsl_odeiv2_step_order: &gsl_odeiv2_step -> uint = 'gsl_odeiv2_step_order($a)';
// Function: int gsl_odeiv2_step_set_driver (gsl_odeiv2_step * s, const gsl_odeiv2_driver * d)
  fun gsl_odeiv2_step_set_driver: &gsl_odeiv2_step * &gsl_odeiv2_driver -> int = 'gsl_odeiv2_step_set_driver($a)';
// Function: int gsl_odeiv2_step_apply (gsl_odeiv2_step * s, double t, double h, double y[], double yerr[], const double dydt_in[], double dydt_out[], const gsl_odeiv2_system * sys)
  fun gsl_odeiv2_step_apply: &gsl_odeiv2_step * double * double * +double * +double * +double * +double * &gsl_odeiv2_system -> int = 'gsl_odeiv2_step_apply($a)';
//*****
// 26.03.00 Adaptive-Step-size-Control.
// Function: gsl_odeiv2_control * gsl_odeiv2_control_standard_new (double eps_abs, double eps_rel, double a_y, double a_dydt)
  fun gsl_odeiv2_control_standard_new: double * double * double * double -> &gsl_odeiv2_control = 'gsl_odeiv2_control_standard_new($a)';
// Function: gsl_odeiv2_control * gsl_odeiv2_control_y_new (double eps_abs, double eps_rel)
  fun gsl_odeiv2_control_y_new: double * double -> &gsl_odeiv2_control = 'gsl_odeiv2_control_y_new($a)';
// Function: gsl_odeiv2_control * gsl_odeiv2_control_yp_new (double eps_abs, double eps_rel)
  fun gsl_odeiv2_control_yp_new: double * double -> &gsl_odeiv2_control = 'gsl_odeiv2_control_yp_new($a)';
// Function: gsl_odeiv2_control * gsl_odeiv2_control_scaled_new (double eps_abs, double eps_rel, double a_y, double a_dydt, const double scale_abs[], size_t dim)
  fun gsl_odeiv2_control_scaled_new: double * double * double * double * +double * size -> &gsl_odeiv2_control = 'gsl_odeiv2_control_scaled_new($a)';
// Function: gsl_odeiv2_control * gsl_odeiv2_control_alloc (const gsl_odeiv2_control_type * T)
  fun gsl_odeiv2_control_alloc: &gsl_odeiv2_control_type -> &gsl_odeiv2_control = 'gsl_odeiv2_control_alloc($a)';
// Function: int gsl_odeiv2_control_init (gsl_odeiv2_control * c, double eps_abs, double eps_rel, double a_y, double a_dydt)
  fun gsl_odeiv2_control_init: &gsl_odeiv2_control * double * double * double * double -> int = 'gsl_odeiv2_control_init($a)';
// Function: void gsl_odeiv2_control_free (gsl_odeiv2_control * c)
  proc gsl_odeiv2_control_free: &gsl_odeiv2_control = 'gsl_odeiv2_control_free($a);';
// Function: int gsl_odeiv2_control_hadjust (gsl_odeiv2_control * c, gsl_odeiv2_step * s, const double y[], const double yerr[], const double dydt[], double * h)
  fun gsl_odeiv2_control_hadjust: &gsl_odeiv2_control * &gsl_odeiv2_step * +double * +double * +double * &double -> int = 'gsl_odeiv2_control_hadjust($a)';
// Function: const char * gsl_odeiv2_control_name (const gsl_odeiv2_control * c)
  fun gsl_odeiv2_control_name: &gsl_odeiv2_control -> &char = 'gsl_odeiv2_control_name($a)';
// Function: int gsl_odeiv2_control_errlevel (gsl_odeiv2_control * c, const double y, const double dydt, const double h, const size_t ind, double * errlev)
  fun gsl_odeiv2_control_errlevel: &gsl_odeiv2_control * double * double * double * size * &double -> int = 'gsl_odeiv2_control_errlevel($a)';
// Function: int gsl_odeiv2_control_set_driver (gsl_odeiv2_control * c, const gsl_odeiv2_driver * d)
  fun gsl_odeiv2_control_set_driver: &gsl_odeiv2_control * &gsl_odeiv2_driver -> int = 'gsl_odeiv2_control_set_driver($a)';
//*****
// 26.04.00 Evolution.
// Function: gsl_odeiv2_evolve * gsl_odeiv2_evolve_alloc (size_t dim)
  fun gsl_odeiv2_evolve_alloc: size -> &gsl_odeiv2_evolve = 'gsl_odeiv2_evolve_alloc($a)';
// Function: int gsl_odeiv2_evolve_apply (gsl_odeiv2_evolve * e, gsl_odeiv2_control * con, gsl_odeiv2_step * step, const gsl_odeiv2_system * sys, double * t, double t1, double * h, double y[])
  fun gsl_odeiv2_evolve_apply: &gsl_odeiv2_evolve * &gsl_odeiv2_control * &gsl_odeiv2_step * &gsl_odeiv2_system * &double * double * &double * +double -> int = 'gsl_odeiv2_evolve_apply($a)';
// Function: int gsl_odeiv2_evolve_apply_fixed_step (gsl_odeiv2_evolve * e, gsl_odeiv2_control * con, gsl_odeiv2_step * step, const gsl_odeiv2_system * sys, double * t, const double h, double y[])
  fun gsl_odeiv2_evolve_apply_fixed_step: &gsl_odeiv2_evolve * &gsl_odeiv2_control * &gsl_odeiv2_step * &gsl_odeiv2_system * &double * double * +double -> int = 'gsl_odeiv2_evolve_apply_fixed_step($a)';
// Function: int gsl_odeiv2_evolve_reset (gsl_odeiv2_evolve * e)
  fun gsl_odeiv2_evolve_reset: &gsl_odeiv2_evolve -> int = 'gsl_odeiv2_evolve_reset($a)';
// Function: void gsl_odeiv2_evolve_free (gsl_odeiv2_evolve * e)
  proc gsl_odeiv2_evolve_free: &gsl_odeiv2_evolve = 'gsl_odeiv2_evolve_free($a);';
// Function: int gsl_odeiv2_evolve_set_driver (gsl_odeiv2_evolve * e, const gsl_odeiv2_driver * d)
  fun gsl_odeiv2_evolve_set_driver: &gsl_odeiv2_evolve * &gsl_odeiv2_driver -> int = 'gsl_odeiv2_evolve_set_driver($a)';
//*****
// 26.05.00 Driver.
// Function: gsl_odeiv2_driver * gsl_odeiv2_driver_alloc_y_new (const gsl_odeiv2_system * sys, const gsl_odeiv2_step_type * T, const double hstart, const double epsabs, const double epsrel)
  fun gsl_odeiv2_driver_alloc_y_new: &gsl_odeiv2_system * &gsl_odeiv2_step_type * double * double * double -> &gsl_odeiv2_driver = 'gsl_odeiv2_driver_alloc_y_new($a)';
// Function: gsl_odeiv2_driver * gsl_odeiv2_driver_alloc_yp_new (const gsl_odeiv2_system * sys, const gsl_odeiv2_step_type * T, const double hstart, const double epsabs, const double epsrel)
  fun gsl_odeiv2_driver_alloc_yp_new: &gsl_odeiv2_system * &gsl_odeiv2_step_type * double * double * double -> &gsl_odeiv2_driver = 'gsl_odeiv2_driver_alloc_yp_new($a)';
// Function: gsl_odeiv2_driver * gsl_odeiv2_driver_alloc_standard_new (const gsl_odeiv2_system * sys, const gsl_odeiv2_step_type * T, const double hstart, const double epsabs, const double epsrel, const double a_y, const double a_dydt)
  fun gsl_odeiv2_driver_alloc_standard_new: &gsl_odeiv2_system * &gsl_odeiv2_step_type * double * double * double * double * double -> &gsl_odeiv2_driver = 'gsl_odeiv2_driver_alloc_standard_new($a)';
// Function: gsl_odeiv2_driver * gsl_odeiv2_driver_alloc_scaled_new (const gsl_odeiv2_system * sys, const gsl_odeiv2_step_type * T, const double hstart, const double epsabs, const double epsrel, const double a_y, const double a_dydt, const double scale_abs[])
  fun gsl_odeiv2_driver_alloc_scaled_new: &gsl_odeiv2_system * &gsl_odeiv2_step_type * double * double * double * double * double * +double -> &gsl_odeiv2_driver = 'gsl_odeiv2_driver_alloc_scaled_new($a)';
// Function: int gsl_odeiv2_driver_set_hmin (gsl_odeiv2_driver * d, const double hmin)
  fun gsl_odeiv2_driver_set_hmin: &gsl_odeiv2_driver * double -> int = 'gsl_odeiv2_driver_set_hmin($a)';
// Function: int gsl_odeiv2_driver_set_hmax (gsl_odeiv2_driver * d, const double hmax)
  fun gsl_odeiv2_driver_set_hmax: &gsl_odeiv2_driver * double -> int = 'gsl_odeiv2_driver_set_hmax($a)';
// Function: int gsl_odeiv2_driver_set_nmax (gsl_odeiv2_driver * d, const unsigned long int nmax)
  fun gsl_odeiv2_driver_set_nmax: &gsl_odeiv2_driver * ulong -> int = 'gsl_odeiv2_driver_set_nmax($a)';
// Function: int gsl_odeiv2_driver_apply (gsl_odeiv2_driver * d, double * t, const double t1, double y[])
  fun gsl_odeiv2_driver_apply: &gsl_odeiv2_driver * &double * double * +double -> int = 'gsl_odeiv2_driver_apply($a)';
// Function: int gsl_odeiv2_driver_apply_fixed_step (gsl_odeiv2_driver * d, double * t, const double h, const unsigned long int n, double y[])
  fun gsl_odeiv2_driver_apply_fixed_step: &gsl_odeiv2_driver * &double * double * ulong * +double -> int = 'gsl_odeiv2_driver_apply_fixed_step($a)';
// Function: int gsl_odeiv2_driver_reset (gsl_odeiv2_driver * d)
  fun gsl_odeiv2_driver_reset: &gsl_odeiv2_driver -> int = 'gsl_odeiv2_driver_reset($a)';
// Function: int gsl_odeiv2_driver_reset_hstart (gsl_odeiv2_driver * d, const double hstart)
  fun gsl_odeiv2_driver_reset_hstart: &gsl_odeiv2_driver * double -> int = 'gsl_odeiv2_driver_reset_hstart($a)';
// Function: int gsl_odeiv2_driver_free (gsl_odeiv2_driver * d)
  fun gsl_odeiv2_driver_free: &gsl_odeiv2_driver -> int = 'gsl_odeiv2_driver_free($a)';
//*****
// 27.00.00 Interpolation.
//*****
// 27.01.00 Introduction-Interpolation.
//*****
// 27.02.00 Interpolation-Functions.
// Function: gsl_interp * gsl_interp_alloc (const gsl_interp_type * T, size_t size)
  fun gsl_interp_alloc: &gsl_interp_type * size -> &gsl_interp = 'gsl_interp_alloc($a)';
// Function: int gsl_interp_init (gsl_interp * interp, const double xa[], const double ya[], size_t size)
  fun gsl_interp_init: &gsl_interp * +double * +double * size -> int = 'gsl_interp_init($a)';
// Function: void gsl_interp_free (gsl_interp * interp)
  proc gsl_interp_free: &gsl_interp = 'gsl_interp_free($a);';
//*****
// 27.03.00 Interpolation-Types.
// Function: const char * gsl_interp_name (const gsl_interp * interp)
  fun gsl_interp_name: &gsl_interp -> &char = 'gsl_interp_name($a)';
// Function: unsigned int gsl_interp_min_size (const gsl_interp * interp)
  fun gsl_interp_min_size: &gsl_interp -> uint = 'gsl_interp_min_size($a)';
// Function: unsigned int gsl_interp_type_min_size (const gsl_interp_type * T)
  fun gsl_interp_type_min_size: &gsl_interp_type -> uint = 'gsl_interp_type_min_size($a)';
//*****
// 27.04.00 Index-Loo-up-and-Acceleration.
// Function: size_t gsl_interp_bsearch (const double x_array[], double x, size_t index_lo, size_t index_hi)
  fun gsl_interp_bsearch: +double * double * size * size -> size = 'gsl_interp_bsearch($a)';
// Function: gsl_interp_accel * gsl_interp_accel_alloc (void)
  fun gsl_interp_accel_alloc: unit -> &gsl_interp_accel = 'gsl_interp_accel_alloc($a)';
// Function: size_t gsl_interp_accel_find (gsl_interp_accel * a, const double x_array[], size_t size, double x)
  fun gsl_interp_accel_find: &gsl_interp_accel * +double * size * double -> size = 'gsl_interp_accel_find($a)';
// Function: int gsl_interp_accel_reset (gsl_interp_accel * acc);
  fun gsl_interp_accel_reset: &gsl_interp_accel -> int = 'gsl_interp_accel_reset($a)';
// Function: void gsl_interp_accel_free (gsl_interp_accel* acc)
  proc gsl_interp_accel_free: &gsl_interp_accel = 'gsl_interp_accel_free($a);';
//*****
// 27.05.00 Evaluation-of-Interpolation-Functions.
// Function: double gsl_interp_eval (const gsl_interp * interp, const double xa[], const double ya[], double x, gsl_interp_accel * acc)
  fun gsl_interp_eval: &gsl_interp * +double * +double * double * &gsl_interp_accel -> double = 'gsl_interp_eval($a)';
// Function: int gsl_interp_eval_e (const gsl_interp * interp, const double xa[], const double ya[], double x, gsl_interp_accel * acc, double * y)
  fun gsl_interp_eval_e: &gsl_interp * +double * +double * double * &gsl_interp_accel * &double -> int = 'gsl_interp_eval_e($a)';
// Function: double gsl_interp_eval_deriv (const gsl_interp * interp, const double xa[], const double ya[], double x, gsl_interp_accel * acc)
  fun gsl_interp_eval_deriv: &gsl_interp * +double * +double * double * &gsl_interp_accel -> double = 'gsl_interp_eval_deriv($a)';
// Function: int gsl_interp_eval_deriv_e (const gsl_interp * interp, const double xa[], const double ya[], double x, gsl_interp_accel * acc, double * d)
  fun gsl_interp_eval_deriv_e: &gsl_interp * +double * +double * double * &gsl_interp_accel * &double -> int = 'gsl_interp_eval_deriv_e($a)';
// Function: double gsl_interp_eval_deriv2 (const gsl_interp * interp, const double xa[], const double ya[], double x, gsl_interp_accel * acc)
  fun gsl_interp_eval_deriv2: &gsl_interp * +double * +double * double * &gsl_interp_accel -> double = 'gsl_interp_eval_deriv2($a)';
// Function: int gsl_interp_eval_deriv2_e (const gsl_interp * interp, const double xa[], const double ya[], double x, gsl_interp_accel * acc, double * d2)
  fun gsl_interp_eval_deriv2_e: &gsl_interp * +double * +double * double * &gsl_interp_accel * &double -> int = 'gsl_interp_eval_deriv2_e($a)';
// Function: double gsl_interp_eval_integ (const gsl_interp * interp, const double xa[], const double ya[], double a, double b, gsl_interp_accel * acc)
  fun gsl_interp_eval_integ: &gsl_interp * +double * +double * double * double * &gsl_interp_accel -> double = 'gsl_interp_eval_integ($a)';
// Function: int gsl_interp_eval_integ_e (const gsl_interp * interp, const double xa[], const double ya[], double a, double b, gsl_interp_accel * acc, double * result)
  fun gsl_interp_eval_integ_e: &gsl_interp * +double * +double * double * double * &gsl_interp_accel * &double -> int = 'gsl_interp_eval_integ_e($a)';
//*****
// 27.06.00 Higher-level-Interface.
// Function: gsl_spline * gsl_spline_alloc (const gsl_interp_type * T, size_t size)
  fun gsl_spline_alloc: &gsl_interp_type * size -> &gsl_spline = 'gsl_spline_alloc($a)';
// Function: int gsl_spline_init (gsl_spline * spline, const double xa[], const double ya[], size_t size)
  fun gsl_spline_init: &gsl_spline * +double * +double * size -> int = 'gsl_spline_init($a)';
// Function: void gsl_spline_free (gsl_spline * spline)
  proc gsl_spline_free: &gsl_spline = 'gsl_spline_free($a);';
// Function: const char * gsl_spline_name (const gsl_spline * spline)
  fun gsl_spline_name: &gsl_spline -> &char = 'gsl_spline_name($a)';
// Function: unsigned int gsl_spline_min_size (const gsl_spline * spline)
  fun gsl_spline_min_size: &gsl_spline -> uint = 'gsl_spline_min_size($a)';
// Function: double gsl_spline_eval (const gsl_spline * spline, double x, gsl_interp_accel * acc)
  fun gsl_spline_eval: &gsl_spline * double * &gsl_interp_accel -> double = 'gsl_spline_eval($a)';
// Function: int gsl_spline_eval_e (const gsl_spline * spline, double x, gsl_interp_accel * acc, double * y)
  fun gsl_spline_eval_e: &gsl_spline * double * &gsl_interp_accel * &double -> int = 'gsl_spline_eval_e($a)';
// Function: double gsl_spline_eval_deriv (const gsl_spline * spline, double x, gsl_interp_accel * acc)
  fun gsl_spline_eval_deriv: &gsl_spline * double * &gsl_interp_accel -> double = 'gsl_spline_eval_deriv($a)';
// Function: int gsl_spline_eval_deriv_e (const gsl_spline * spline, double x, gsl_interp_accel * acc, double * d)
  fun gsl_spline_eval_deriv_e: &gsl_spline * double * &gsl_interp_accel * &double -> int = 'gsl_spline_eval_deriv_e($a)';
// Function: double gsl_spline_eval_deriv2 (const gsl_spline * spline, double x, gsl_interp_accel * acc)
  fun gsl_spline_eval_deriv2: &gsl_spline * double * &gsl_interp_accel -> double = 'gsl_spline_eval_deriv2($a)';
// Function: int gsl_spline_eval_deriv2_e (const gsl_spline * spline, double x, gsl_interp_accel * acc, double * d2)
  fun gsl_spline_eval_deriv2_e: &gsl_spline * double * &gsl_interp_accel * &double -> int = 'gsl_spline_eval_deriv2_e($a)';
// Function: double gsl_spline_eval_integ (const gsl_spline * spline, double a, double b, gsl_interp_accel * acc)
  fun gsl_spline_eval_integ: &gsl_spline * double * double * &gsl_interp_accel -> double = 'gsl_spline_eval_integ($a)';
// Function: int gsl_spline_eval_integ_e (const gsl_spline * spline, double a, double b, gsl_interp_accel * acc, double * result)
  fun gsl_spline_eval_integ_e: &gsl_spline * double * double * &gsl_interp_accel * &double -> int = 'gsl_spline_eval_integ_e($a)';
//*****
// 28.00.00 Numerical-Differentiation.
//*****
// 28.01.00 Numerical-Differentiation-Functions.
// Function: int gsl_deriv_central (const gsl_function * f, double x, double h, double * result, double * abserr)
  fun gsl_deriv_central: &gsl_function * double * double * &double * &double -> int = 'gsl_deriv_central($a)';
// Function: int gsl_deriv_forward (const gsl_function * f, double x, double h, double * result, double * abserr)
  fun gsl_deriv_forward: &gsl_function * double * double * &double * &double -> int = 'gsl_deriv_forward($a)';
// Function: int gsl_deriv_backward (const gsl_function * f, double x, double h, double * result, double * abserr)
  fun gsl_deriv_backward: &gsl_function * double * double * &double * &double -> int = 'gsl_deriv_backward($a)';
//*****
// 29.00.00 Chebyshev-Approximations.
//*****
// 29.01.00 Chebyshev-Definitions.
//*****
// 29.02.00 Creation-and-Calculation-of-Chebyshev-Series.
// Function: gsl_cheb_series * gsl_cheb_alloc (const size_t n)
  fun gsl_cheb_alloc: size -> &gsl_cheb_series = 'gsl_cheb_alloc($a)';
// Function: void gsl_cheb_free (gsl_cheb_series * cs)
  proc gsl_cheb_free: &gsl_cheb_series = 'gsl_cheb_free($a);';
// Function: int gsl_cheb_init (gsl_cheb_series * cs, const gsl_function * f, const double a, const double b)
  fun gsl_cheb_init: &gsl_cheb_series * &gsl_function * double * double -> int = 'gsl_cheb_init($a)';
//*****
// 29.03.00 Chebyshev-Auxilliary-Functions.
// Function: size_t gsl_cheb_order (const gsl_cheb_series * cs)
  fun gsl_cheb_order: &gsl_cheb_series -> size = 'gsl_cheb_order($a)';
// Function: size_t gsl_cheb_size (const gsl_cheb_series * cs)
  fun gsl_cheb_size: &gsl_cheb_series -> size = 'gsl_cheb_size($a)';
// Function: double * gsl_cheb_coeffs (const gsl_cheb_series * cs)
  fun gsl_cheb_coeffs: &gsl_cheb_series -> &double = 'gsl_cheb_coeffs($a)';
//*****
// 29.04.00 Chebyshev-Series-Evaluation.
// Function: double gsl_cheb_eval (const gsl_cheb_series * cs, double x)
  fun gsl_cheb_eval: &gsl_cheb_series * double -> double = 'gsl_cheb_eval($a)';
// Function: int gsl_cheb_eval_err (const gsl_cheb_series * cs, const double x, double * result, double * abserr)
  fun gsl_cheb_eval_err: &gsl_cheb_series * double * &double * &double -> int = 'gsl_cheb_eval_err($a)';
// Function: double gsl_cheb_eval_n (const gsl_cheb_series * cs, size_t order, double x)
  fun gsl_cheb_eval_n: &gsl_cheb_series * size * double -> double = 'gsl_cheb_eval_n($a)';
// Function: int gsl_cheb_eval_n_err (const gsl_cheb_series * cs, const size_t order, const double x, double * result, double * abserr)
  fun gsl_cheb_eval_n_err: &gsl_cheb_series * size * double * &double * &double -> int = 'gsl_cheb_eval_n_err($a)';
//*****
// 29.05.00 Chebyshev-Derivatives-and-Integrals.
// Function: int gsl_cheb_calc_deriv (gsl_cheb_series * deriv, const gsl_cheb_series * cs)
  fun gsl_cheb_calc_deriv: &gsl_cheb_series * &gsl_cheb_series -> int = 'gsl_cheb_calc_deriv($a)';
// Function: int gsl_cheb_calc_integ (gsl_cheb_series * integ, const gsl_cheb_series * cs)
  fun gsl_cheb_calc_integ: &gsl_cheb_series * &gsl_cheb_series -> int = 'gsl_cheb_calc_integ($a)';
//*****
// 30.00.00 Series-Acceleration.
//*****
// 30.01.00 Series-Acceleration-Functions.
// Function: gsl_sum_levin_u_workspace * gsl_sum_levin_u_alloc (size_t n)
  fun gsl_sum_levin_u_alloc: size -> &gsl_sum_levin_u_workspace = 'gsl_sum_levin_u_alloc($a)';
// Function: void gsl_sum_levin_u_free (gsl_sum_levin_u_workspace * w)
  proc gsl_sum_levin_u_free: &gsl_sum_levin_u_workspace = 'gsl_sum_levin_u_free($a);';
// Function: int gsl_sum_levin_u_accel (const double * array, size_t array_size, gsl_sum_levin_u_workspace * w, double * sum_accel, double * abserr)
  fun gsl_sum_levin_u_accel: &double * size * &gsl_sum_levin_u_workspace * &double * &double -> int = 'gsl_sum_levin_u_accel($a)';
//*****
// 30.02.00 Acceleration-functions-with-error-estimates.
// Function: gsl_sum_levin_utrunc_workspace * gsl_sum_levin_utrunc_alloc (size_t n)
  fun gsl_sum_levin_utrunc_alloc: size -> &gsl_sum_levin_utrunc_workspace = 'gsl_sum_levin_utrunc_alloc($a)';
// Function: void gsl_sum_levin_utrunc_free (gsl_sum_levin_utrunc_workspace * w)
  proc gsl_sum_levin_utrunc_free: &gsl_sum_levin_utrunc_workspace = 'gsl_sum_levin_utrunc_free($a);';
// Function: int gsl_sum_levin_utrunc_accel (const double * array, size_t array_size, gsl_sum_levin_utrunc_workspace * w, double * sum_accel, double * abserr_trunc)
  fun gsl_sum_levin_utrunc_accel: &double * size * &gsl_sum_levin_utrunc_workspace * &double * &double -> int = 'gsl_sum_levin_utrunc_accel($a)';
//*****
// 31.00.00 Wavelet-Transforms.
//*****
// 31.01.00 Wavelet-Transforms-Definitions.
//*****
// 31.02.00 DWT-Initialisation.
// Function: gsl_wavelet * gsl_wavelet_alloc (const gsl_wavelet_type * T, size_t k)
  fun gsl_wavelet_alloc: &gsl_wavelet_type * size -> &gsl_wavelet = 'gsl_wavelet_alloc($a)';
// Function: const char * gsl_wavelet_name (const gsl_wavelet * w)
  fun gsl_wavelet_name: &gsl_wavelet -> &char = 'gsl_wavelet_name($a)';
// Function: void gsl_wavelet_free (gsl_wavelet * w)
  proc gsl_wavelet_free: &gsl_wavelet = 'gsl_wavelet_free($a);';
// Function: gsl_wavelet_workspace * gsl_wavelet_workspace_alloc (size_t n)
  fun gsl_wavelet_workspace_alloc: size -> &gsl_wavelet_workspace = 'gsl_wavelet_workspace_alloc($a)';
// Function: void gsl_wavelet_workspace_free (gsl_wavelet_workspace * work)
  proc gsl_wavelet_workspace_free: &gsl_wavelet_workspace = 'gsl_wavelet_workspace_free($a);';
//*****
// 31.03.00 DWT-Transform-Functions.
//*****
// 31.03.01 DWT-Transforms-in-one-dimension.
// Function: int gsl_wavelet_transform (const gsl_wavelet * w, double * data, size_t stride, size_t n, gsl_wavelet_direction dir, gsl_wavelet_workspace * work)
  fun gsl_wavelet_transform: &gsl_wavelet * &double * size * size * gsl_wavelet_direction * &gsl_wavelet_workspace -> int = 'gsl_wavelet_transform($a)';
// Function: int gsl_wavelet_transform_forward (const gsl_wavelet * w, double * data, size_t stride, size_t n, gsl_wavelet_workspace * work)
  fun gsl_wavelet_transform_forward: &gsl_wavelet * &double * size * size * &gsl_wavelet_workspace -> int = 'gsl_wavelet_transform_forward($a)';
// Function: int gsl_wavelet_transform_inverse (const gsl_wavelet * w, double * data, size_t stride, size_t n, gsl_wavelet_workspace * work)
  fun gsl_wavelet_transform_inverse: &gsl_wavelet * &double * size * size * &gsl_wavelet_workspace -> int = 'gsl_wavelet_transform_inverse($a)';
//*****
// 31.03.02 DWT-Transforms-in-two-dimensions.
// Function: int gsl_wavelet2d_transform (const gsl_wavelet * w, double * data, size_t tda, size_t size1, size_t size2, gsl_wavelet_direction dir, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_transform: &gsl_wavelet * &double * size * size * size * gsl_wavelet_direction * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_transform($a)';
// Function: int gsl_wavelet2d_transform_forward (const gsl_wavelet * w, double * data, size_t tda, size_t size1, size_t size2, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_transform_forward: &gsl_wavelet * &double * size * size * size * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_transform_forward($a)';
// Function: int gsl_wavelet2d_transform_inverse (const gsl_wavelet * w, double * data, size_t tda, size_t size1, size_t size2, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_transform_inverse: &gsl_wavelet * &double * size * size * size * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_transform_inverse($a)';
// Function: int gsl_wavelet2d_transform_matrix (const gsl_wavelet * w, gsl_matrix * m, gsl_wavelet_direction dir, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_transform_matrix: &gsl_wavelet * &gsl_matrix * gsl_wavelet_direction * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_transform_matrix($a)';
// Function: int gsl_wavelet2d_transform_matrix_forward (const gsl_wavelet * w, gsl_matrix * m, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_transform_matrix_forward: &gsl_wavelet * &gsl_matrix * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_transform_matrix_forward($a)';
// Function: int gsl_wavelet2d_transform_matrix_inverse (const gsl_wavelet * w, gsl_matrix * m, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_transform_matrix_inverse: &gsl_wavelet * &gsl_matrix * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_transform_matrix_inverse($a)';
// Function: int gsl_wavelet2d_nstransform (const gsl_wavelet * w, double * data, size_t tda, size_t size1, size_t size2, gsl_wavelet_direction dir, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_nstransform: &gsl_wavelet * &double * size * size * size * gsl_wavelet_direction * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_nstransform($a)';
// Function: int gsl_wavelet2d_nstransform_forward (const gsl_wavelet * w, double * data, size_t tda, size_t size1, size_t size2, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_nstransform_forward: &gsl_wavelet * &double * size * size * size * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_nstransform_forward($a)';
// Function: int gsl_wavelet2d_nstransform_inverse (const gsl_wavelet * w, double * data, size_t tda, size_t size1, size_t size2, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_nstransform_inverse: &gsl_wavelet * &double * size * size * size * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_nstransform_inverse($a)';
// Function: int gsl_wavelet2d_nstransform_matrix (const gsl_wavelet * w, gsl_matrix * m, gsl_wavelet_direction dir, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_nstransform_matrix: &gsl_wavelet * &gsl_matrix * gsl_wavelet_direction * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_nstransform_matrix($a)';
// Function: int gsl_wavelet2d_nstransform_matrix_forward (const gsl_wavelet * w, gsl_matrix * m, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_nstransform_matrix_forward: &gsl_wavelet * &gsl_matrix * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_nstransform_matrix_forward($a)';
// Function: int gsl_wavelet2d_nstransform_matrix_inverse (const gsl_wavelet * w, gsl_matrix * m, gsl_wavelet_workspace * work)
  fun gsl_wavelet2d_nstransform_matrix_inverse: &gsl_wavelet * &gsl_matrix * &gsl_wavelet_workspace -> int = 'gsl_wavelet2d_nstransform_matrix_inverse($a)';
//*****
// 32.00.00 Discrete-Hankel-Transforms.
//*****
// 32.01.00 Discrete-Hankel-Definition.
//*****
// 32.02.00 Discrete-Hankel-Functions.
// Function: gsl_dht * gsl_dht_alloc (size_t size)
  fun gsl_dht_alloc: size -> &gsl_dht = 'gsl_dht_alloc($a)';
// Function: int gsl_dht_init (gsl_dht * t, double nu, double xmax)
  fun gsl_dht_init: &gsl_dht * double * double -> int = 'gsl_dht_init($a)';
// Function: gsl_dht * gsl_dht_new (size_t size, double nu, double xmax)
  fun gsl_dht_new: size * double * double -> &gsl_dht = 'gsl_dht_new($a)';
// Function: void gsl_dht_free (gsl_dht * t)
  proc gsl_dht_free: &gsl_dht = 'gsl_dht_free($a);';
// Function: int gsl_dht_apply (const gsl_dht * t, double * f_in, double * f_out)
  fun gsl_dht_apply: &gsl_dht * &double * &double -> int = 'gsl_dht_apply($a)';
// Function: double gsl_dht_x_sample (const gsl_dht * t, int n)
  fun gsl_dht_x_sample: &gsl_dht * int -> double = 'gsl_dht_x_sample($a)';
// Function: double gsl_dht_k_sample (const gsl_dht * t, int n)
  fun gsl_dht_k_sample: &gsl_dht * int -> double = 'gsl_dht_k_sample($a)';
//*****
// 33.00.00 One-Dimensional-Root-Finding.
//*****
// 33.01.00 One-Dimensional-Root-Finding-Overview.
//*****
// 33.02.00 One-Dimensional-Root-Finding-Caveats.
//*****
// 33.03.00 Initialising-the-Solver.
// Function: gsl_root_fsolver * gsl_root_fsolver_alloc (const gsl_root_fsolver_type * T)
  fun gsl_root_fsolver_alloc: &gsl_root_fsolver_type -> &gsl_root_fsolver = 'gsl_root_fsolver_alloc($a)';
// Function: gsl_root_fdfsolver * gsl_root_fdfsolver_alloc (const gsl_root_fdfsolver_type * T)
  fun gsl_root_fdfsolver_alloc: &gsl_root_fdfsolver_type -> &gsl_root_fdfsolver = 'gsl_root_fdfsolver_alloc($a)';
// Function: int gsl_root_fsolver_set (gsl_root_fsolver * s, gsl_function * f, double x_lower, double x_upper)
  fun gsl_root_fsolver_set: &gsl_root_fsolver * &gsl_function * double * double -> int = 'gsl_root_fsolver_set($a)';
// Function: int gsl_root_fdfsolver_set (gsl_root_fdfsolver * s, gsl_function_fdf * fdf, double root)
  fun gsl_root_fdfsolver_set: &gsl_root_fdfsolver * &gsl_function_fdf * double -> int = 'gsl_root_fdfsolver_set($a)';
// Function: void gsl_root_fsolver_free (gsl_root_fsolver * s)
  proc gsl_root_fsolver_free: &gsl_root_fsolver = 'gsl_root_fsolver_free($a);';
// Function: void gsl_root_fdfsolver_free (gsl_root_fdfsolver * s)
  proc gsl_root_fdfsolver_free: &gsl_root_fdfsolver = 'gsl_root_fdfsolver_free($a);';
// Function: const char * gsl_root_fsolver_name (const gsl_root_fsolver * s)
  fun gsl_root_fsolver_name: &gsl_root_fsolver -> &char = 'gsl_root_fsolver_name($a)';
// Function: const char * gsl_root_fdfsolver_name (const gsl_root_fdfsolver * s)
  fun gsl_root_fdfsolver_name: &gsl_root_fdfsolver -> &char = 'gsl_root_fdfsolver_name($a)';
//*****
// 33.04.00 Providing-the-function-to-solve.
//*****
// 33.05.00 Search-Bounds-and-Guesses.
//*****
// 33.06.00 Iteration.
// Function: int gsl_root_fsolver_iterate (gsl_root_fsolver * s)
  fun gsl_root_fsolver_iterate: &gsl_root_fsolver -> int = 'gsl_root_fsolver_iterate($a)';
// Function: int gsl_root_fdfsolver_iterate (gsl_root_fdfsolver * s)
  fun gsl_root_fdfsolver_iterate: &gsl_root_fdfsolver -> int = 'gsl_root_fdfsolver_iterate($a)';
// Function: double gsl_root_fsolver_root (const gsl_root_fsolver * s)
  fun gsl_root_fsolver_root: &gsl_root_fsolver -> double = 'gsl_root_fsolver_root($a)';
// Function: double gsl_root_fdfsolver_root (const gsl_root_fdfsolver * s)
  fun gsl_root_fdfsolver_root: &gsl_root_fdfsolver -> double = 'gsl_root_fdfsolver_root($a)';
// Function: double gsl_root_fsolver_x_lower (const gsl_root_fsolver * s)
  fun gsl_root_fsolver_x_lower: &gsl_root_fsolver -> double = 'gsl_root_fsolver_x_lower($a)';
// Function: double gsl_root_fsolver_x_upper (const gsl_root_fsolver * s)
  fun gsl_root_fsolver_x_upper: &gsl_root_fsolver -> double = 'gsl_root_fsolver_x_upper($a)';
//*****
// 33.07.00 Search-Stopping-Parameters.
// Function: int gsl_root_test_interval (double x_lower, double x_upper, double epsabs, double epsrel)
  fun gsl_root_test_interval: double * double * double * double -> int = 'gsl_root_test_interval($a)';
// Function: int gsl_root_test_delta (double x1, double x0, double epsabs, double epsrel)
  fun gsl_root_test_delta: double * double * double * double -> int = 'gsl_root_test_delta($a)';
// Function: int gsl_root_test_residual (double f, double epsabs)
  fun gsl_root_test_residual: double * double -> int = 'gsl_root_test_residual($a)';
//*****
// 33.08.00 Root-Bracketing-Algorithms.
//*****
// 33.09.00 Root-Finding-Algorithms-using-Derivaties.
//*****
// 34.00.00 One-Dimensional-Minimisation.
//*****
// 34.01.00 One-Dimensional-Minimisation-Overview.
//*****
// 34.02.00 One-Dimensional-Minimisation-Caveats.
//*****
// 34.03.00 Initialising-the-Minimiser.
// Function: gsl_min_fminimizer * gsl_min_fminimizer_alloc (const gsl_min_fminimizer_type * T)
  fun gsl_min_fminimizer_alloc: &gsl_min_fminimizer_type -> &gsl_min_fminimizer = 'gsl_min_fminimizer_alloc($a)';
// Function: int gsl_min_fminimizer_set (gsl_min_fminimizer * s, gsl_function * f, double x_minimum, double x_lower, double x_upper)
  fun gsl_min_fminimizer_set: &gsl_min_fminimizer * &gsl_function * double * double * double -> int = 'gsl_min_fminimizer_set($a)';
// Function: int gsl_min_fminimizer_set_with_values (gsl_min_fminimizer * s, gsl_function * f, double x_minimum, double f_minimum, double x_lower, double f_lower, double x_upper, double f_upper)
  fun gsl_min_fminimizer_set_with_values: &gsl_min_fminimizer * &gsl_function * double * double * double * double * double * double -> int = 'gsl_min_fminimizer_set_with_values($a)';
// Function: void gsl_min_fminimizer_free (gsl_min_fminimizer * s)
  proc gsl_min_fminimizer_free: &gsl_min_fminimizer = 'gsl_min_fminimizer_free($a);';
// Function: const char * gsl_min_fminimizer_name (const gsl_min_fminimizer * s)
  fun gsl_min_fminimizer_name: &gsl_min_fminimizer -> &char = 'gsl_min_fminimizer_name($a)';
//*****
// 34.04.00 Providing-the-function-to-minimise.
//*****
// 34.05.00 Minimiser-Iteration.
// Function: int gsl_min_fminimizer_iterate (gsl_min_fminimizer * s)
  fun gsl_min_fminimizer_iterate: &gsl_min_fminimizer -> int = 'gsl_min_fminimizer_iterate($a)';
// Function: double gsl_min_fminimizer_x_minimum (const gsl_min_fminimizer * s)
  fun gsl_min_fminimizer_x_minimum: &gsl_min_fminimizer -> double = 'gsl_min_fminimizer_x_minimum($a)';
// Function: double gsl_min_fminimizer_x_upper (const gsl_min_fminimizer * s)
  fun gsl_min_fminimizer_x_upper: &gsl_min_fminimizer -> double = 'gsl_min_fminimizer_x_upper($a)';
// Function: double gsl_min_fminimizer_x_lower (const gsl_min_fminimizer * s)
  fun gsl_min_fminimizer_x_lower: &gsl_min_fminimizer -> double = 'gsl_min_fminimizer_x_lower($a)';
// Function: double gsl_min_fminimizer_f_minimum (const gsl_min_fminimizer * s)
  fun gsl_min_fminimizer_f_minimum: &gsl_min_fminimizer -> double = 'gsl_min_fminimizer_f_minimum($a)';
// Function: double gsl_min_fminimizer_f_upper (const gsl_min_fminimizer * s)
  fun gsl_min_fminimizer_f_upper: &gsl_min_fminimizer -> double = 'gsl_min_fminimizer_f_upper($a)';
// Function: double gsl_min_fminimizer_f_lower (const gsl_min_fminimizer * s)
  fun gsl_min_fminimizer_f_lower: &gsl_min_fminimizer -> double = 'gsl_min_fminimizer_f_lower($a)';
//*****
// 34.06.00 Minimiser-Stopping-Parameters.
// Function: int gsl_min_test_interval (double x_lower, double x_upper, double epsabs, double epsrel)
  fun gsl_min_test_interval: double * double * double * double -> int = 'gsl_min_test_interval($a)';
//*****
// 34.07.00 Minimisation-Algorithms.
//*****
// 35.00.00 Multidimensional-Root-Finding.
//*****
// 35.01.00 Multidimensional-Root-Finding-Overview.
//*****
// 35.02.00 Multidimensional-Root-Finding-Initialising-the-Solver.
// Function: gsl_multiroot_fsolver * gsl_multiroot_fsolver_alloc (const gsl_multiroot_fsolver_type * T, size_t n)
  fun gsl_multiroot_fsolver_alloc: &gsl_multiroot_fsolver_type * size -> &gsl_multiroot_fsolver = 'gsl_multiroot_fsolver_alloc($a)';
// Function: gsl_multiroot_fdfsolver * gsl_multiroot_fdfsolver_alloc (const gsl_multiroot_fdfsolver_type * T, size_t n)
  fun gsl_multiroot_fdfsolver_alloc: &gsl_multiroot_fdfsolver_type * size -> &gsl_multiroot_fdfsolver = 'gsl_multiroot_fdfsolver_alloc($a)';
// Function: int gsl_multiroot_fsolver_set (gsl_multiroot_fsolver * s, gsl_multiroot_function * f, const gsl_vector * x)
  fun gsl_multiroot_fsolver_set: &gsl_multiroot_fsolver * &gsl_multiroot_function * &gsl_vector -> int = 'gsl_multiroot_fsolver_set($a)';
// Function: int gsl_multiroot_fdfsolver_set (gsl_multiroot_fdfsolver * s, gsl_multiroot_function_fdf * fdf, const gsl_vector * x)
  fun gsl_multiroot_fdfsolver_set: &gsl_multiroot_fdfsolver * &gsl_multiroot_function_fdf * &gsl_vector -> int = 'gsl_multiroot_fdfsolver_set($a)';
// Function: void gsl_multiroot_fsolver_free (gsl_multiroot_fsolver * s)
  proc gsl_multiroot_fsolver_free: &gsl_multiroot_fsolver = 'gsl_multiroot_fsolver_free($a);';
// Function: void gsl_multiroot_fdfsolver_free (gsl_multiroot_fdfsolver * s)
  proc gsl_multiroot_fdfsolver_free: &gsl_multiroot_fdfsolver = 'gsl_multiroot_fdfsolver_free($a);';
// Function: const char * gsl_multiroot_fsolver_name (const gsl_multiroot_fsolver * s)
  fun gsl_multiroot_fsolver_name: &gsl_multiroot_fsolver -> &char = 'gsl_multiroot_fsolver_name($a)';
// Function: const char * gsl_multiroot_fdfsolver_name (const gsl_multiroot_fdfsolver * s)
  fun gsl_multiroot_fdfsolver_name: &gsl_multiroot_fdfsolver -> &char = 'gsl_multiroot_fdfsolver_name($a)';
//*****
// 35.03.00 Multidimensional-Root-Finding-Providing-the-function-to-solve.
//*****
// 35.04.00 Multidimensional-Root-Finding-Iteration.
// Function: int gsl_multiroot_fsolver_iterate (gsl_multiroot_fsolver * s)
  fun gsl_multiroot_fsolver_iterate: &gsl_multiroot_fsolver -> int = 'gsl_multiroot_fsolver_iterate($a)';
// Function: int gsl_multiroot_fdfsolver_iterate (gsl_multiroot_fdfsolver * s)
  fun gsl_multiroot_fdfsolver_iterate: &gsl_multiroot_fdfsolver -> int = 'gsl_multiroot_fdfsolver_iterate($a)';
// Function: gsl_vector * gsl_multiroot_fsolver_root (const gsl_multiroot_fsolver * s)
  fun gsl_multiroot_fsolver_root: &gsl_multiroot_fsolver -> &gsl_vector = 'gsl_multiroot_fsolver_root($a)';
// Function: gsl_vector * gsl_multiroot_fdfsolver_root (const gsl_multiroot_fdfsolver * s)
  fun gsl_multiroot_fdfsolver_root: &gsl_multiroot_fdfsolver -> &gsl_vector = 'gsl_multiroot_fdfsolver_root($a)';
// Function: gsl_vector * gsl_multiroot_fsolver_f (const gsl_multiroot_fsolver * s)
  fun gsl_multiroot_fsolver_f: &gsl_multiroot_fsolver -> &gsl_vector = 'gsl_multiroot_fsolver_f($a)';
// Function: gsl_vector * gsl_multiroot_fdfsolver_f (const gsl_multiroot_fdfsolver * s)
  fun gsl_multiroot_fdfsolver_f: &gsl_multiroot_fdfsolver -> &gsl_vector = 'gsl_multiroot_fdfsolver_f($a)';
// Function: gsl_vector * gsl_multiroot_fsolver_dx (const gsl_multiroot_fsolver * s)
  fun gsl_multiroot_fsolver_dx: &gsl_multiroot_fsolver -> &gsl_vector = 'gsl_multiroot_fsolver_dx($a)';
// Function: gsl_vector * gsl_multiroot_fdfsolver_dx (const gsl_multiroot_fdfsolver * s)
  fun gsl_multiroot_fdfsolver_dx: &gsl_multiroot_fdfsolver -> &gsl_vector = 'gsl_multiroot_fdfsolver_dx($a)';
//*****
// 35.05.00 Multidimensional-Root-Finding-Stopping-Parameters.
// Function: int gsl_multiroot_test_delta (const gsl_vector * dx, const gsl_vector * x, double epsabs, double epsrel)
  fun gsl_multiroot_test_delta: &gsl_vector * &gsl_vector * double * double -> int = 'gsl_multiroot_test_delta($a)';
// Function: int gsl_multiroot_test_residual (const gsl_vector * f, double epsabs)
  fun gsl_multiroot_test_residual: &gsl_vector * double -> int = 'gsl_multiroot_test_residual($a)';
//*****
// 35.06.00 Multidimensional-Root-Finding-Algorithms-using-Derivatives.
//*****
// 35.07.00 Multidimensional-Root-Finding-Algorithms-without-Derivatives.
//*****
// 36.00.00 Multidimensional-Minimisation.
//*****
// 36.01.00 Multidimensional-Minimisation-Overview.
//*****
// 36.02.00 Multidimensional-Minimisation-Caveats.
//*****
// 36.03.00 Multidimensional-Minimisation-Initialisation.
// Function: gsl_multimin_fdfminimizer * gsl_multimin_fdfminimizer_alloc (const gsl_multimin_fdfminimizer_type * T, size_t n)
  fun gsl_multimin_fdfminimizer_alloc: &gsl_multimin_fdfminimizer_type * size -> &gsl_multimin_fdfminimizer = 'gsl_multimin_fdfminimizer_alloc($a)';
// Function: gsl_multimin_fminimizer * gsl_multimin_fminimizer_alloc (const gsl_multimin_fminimizer_type * T, size_t n)
  fun gsl_multimin_fminimizer_alloc: &gsl_multimin_fminimizer_type * size -> &gsl_multimin_fminimizer = 'gsl_multimin_fminimizer_alloc($a)';
// Function: int gsl_multimin_fdfminimizer_set (gsl_multimin_fdfminimizer * s, gsl_multimin_function_fdf * fdf, const gsl_vector * x, double step_size, double tol)
  fun gsl_multimin_fdfminimizer_set: &gsl_multimin_fdfminimizer * &gsl_multimin_function_fdf * &gsl_vector * double * double -> int = 'gsl_multimin_fdfminimizer_set($a)';
// Function: int gsl_multimin_fminimizer_set (gsl_multimin_fminimizer * s, gsl_multimin_function * f, const gsl_vector * x, const gsl_vector * step_size)
  fun gsl_multimin_fminimizer_set: &gsl_multimin_fminimizer * &gsl_multimin_function * &gsl_vector * &gsl_vector -> int = 'gsl_multimin_fminimizer_set($a)';
// Function: void gsl_multimin_fdfminimizer_free (gsl_multimin_fdfminimizer * s)
  proc gsl_multimin_fdfminimizer_free: &gsl_multimin_fdfminimizer = 'gsl_multimin_fdfminimizer_free($a);';
// Function: void gsl_multimin_fminimizer_free (gsl_multimin_fminimizer * s)
  proc gsl_multimin_fminimizer_free: &gsl_multimin_fminimizer = 'gsl_multimin_fminimizer_free($a);';
// Function: const char * gsl_multimin_fdfminimizer_name (const gsl_multimin_fdfminimizer * s)
  fun gsl_multimin_fdfminimizer_name: &gsl_multimin_fdfminimizer -> &char = 'gsl_multimin_fdfminimizer_name($a)';
// Function: const char * gsl_multimin_fminimizer_name (const gsl_multimin_fminimizer * s)
  fun gsl_multimin_fminimizer_name: &gsl_multimin_fminimizer -> &char = 'gsl_multimin_fminimizer_name($a)';
//*****
// 36.04.00 Multidimensional-Minimisation-Providing-function-to-minimise.
//*****
// 36.05.00 Multidimensional-Minimisation-Iteration.
// Function: int gsl_multimin_fdfminimizer_iterate (gsl_multimin_fdfminimizer * s)
  fun gsl_multimin_fdfminimizer_iterate: &gsl_multimin_fdfminimizer -> int = 'gsl_multimin_fdfminimizer_iterate($a)';
// Function: int gsl_multimin_fminimizer_iterate (gsl_multimin_fminimizer * s)
  fun gsl_multimin_fminimizer_iterate: &gsl_multimin_fminimizer -> int = 'gsl_multimin_fminimizer_iterate($a)';
// Function: gsl_vector * gsl_multimin_fdfminimizer_x (const gsl_multimin_fdfminimizer * s)
  fun gsl_multimin_fdfminimizer_x: &gsl_multimin_fdfminimizer -> &gsl_vector = 'gsl_multimin_fdfminimizer_x($a)';
// Function: gsl_vector * gsl_multimin_fminimizer_x (const gsl_multimin_fminimizer * s)
  fun gsl_multimin_fminimizer_x: &gsl_multimin_fminimizer -> &gsl_vector = 'gsl_multimin_fminimizer_x($a)';
// Function: double gsl_multimin_fdfminimizer_minimum (const gsl_multimin_fdfminimizer * s)
  fun gsl_multimin_fdfminimizer_minimum: &gsl_multimin_fdfminimizer -> double = 'gsl_multimin_fdfminimizer_minimum($a)';
// Function: double gsl_multimin_fminimizer_minimum (const gsl_multimin_fminimizer * s)
  fun gsl_multimin_fminimizer_minimum: &gsl_multimin_fminimizer -> double = 'gsl_multimin_fminimizer_minimum($a)';
// Function: gsl_vector * gsl_multimin_fdfminimizer_gradient (const gsl_multimin_fdfminimizer * s)
  fun gsl_multimin_fdfminimizer_gradient: &gsl_multimin_fdfminimizer -> &gsl_vector = 'gsl_multimin_fdfminimizer_gradient($a)';
// Function: double gsl_multimin_fminimizer_size (const gsl_multimin_fminimizer * s)
  fun gsl_multimin_fminimizer_size: &gsl_multimin_fminimizer -> double = 'gsl_multimin_fminimizer_size($a)';
// Function: int gsl_multimin_fdfminimizer_restart (gsl_multimin_fdfminimizer * s)
  fun gsl_multimin_fdfminimizer_restart: &gsl_multimin_fdfminimizer -> int = 'gsl_multimin_fdfminimizer_restart($a)';
//*****
// 36.06.00 Multidimensional-Minimisation-Stopping.
// Function: int gsl_multimin_test_gradient (const gsl_vector * g, double epsabs)
  fun gsl_multimin_test_gradient: &gsl_vector * double -> int = 'gsl_multimin_test_gradient($a)';
// Function: int gsl_multimin_test_size (const double size, double epsabs)
  fun gsl_multimin_test_size: double * double -> int = 'gsl_multimin_test_size($a)';
//*****
// 36.07.00 Multidimensional-Minimisation-Algorithms-with-Derivatives.
//*****
// 36.08.00 Multidimensional-Minimisation-Algorithms-without-Derivatives.
//*****
// 37.00.00 Least-Squres-Fitting.
//*****
// 37.01.00 Least-Squres-Fitting-Overview.
//*****
// 37.02.00 Least-Squres-Fitting-Linear-Regression.
// Function: int gsl_fit_linear (const double * x, const size_t xstride, const double * y, const size_t ystride, size_t n, double * c0, double * c1, double * cov00, double * cov01, double * cov11, double * sumsq)
  fun gsl_fit_linear: &double * size * &double * size * size * &double * &double * &double * &double * &double * &double -> int = 'gsl_fit_linear($a)';
// Function: int gsl_fit_wlinear (const double * x, const size_t xstride, const double * w, const size_t wstride, const double * y, const size_t ystride, size_t n, double * c0, double * c1, double * cov00, double * cov01, double * cov11, double * chisq)
  fun gsl_fit_wlinear: &double * size * &double * size * &double * size * size * &double * &double * &double * &double * &double * &double -> int = 'gsl_fit_wlinear($a)';
// Function: int gsl_fit_linear_est (double x, double c0, double c1, double cov00, double cov01, double cov11, double * y, double * y_err)
  fun gsl_fit_linear_est: double * double * double * double * double * double * &double * &double -> int = 'gsl_fit_linear_est($a)';
//*****
// 37.03.00 Least-Squres-Fitting-Linear-fitting-without-a-constant-term.
// Function: int gsl_fit_mul (const double * x, const size_t xstride, const double * y, const size_t ystride, size_t n, double * c1, double * cov11, double * sumsq)
  fun gsl_fit_mul: &double * size * &double * size * size * &double * &double * &double -> int = 'gsl_fit_mul($a)';
// Function: int gsl_fit_wmul (const double * x, const size_t xstride, const double * w, const size_t wstride, const double * y, const size_t ystride, size_t n, double * c1, double * cov11, double * sumsq)
  fun gsl_fit_wmul: &double * size * &double * size * &double * size * size * &double * &double * &double -> int = 'gsl_fit_wmul($a)';
// Function: int gsl_fit_mul_est (double x, double c1, double cov11, double * y, double * y_err)
  fun gsl_fit_mul_est: double * double * double * &double * &double -> int = 'gsl_fit_mul_est($a)';
//*****
// 37.04.00 Multi-parameter-fitting.
// Function: gsl_multifit_linear_workspace * gsl_multifit_linear_alloc (size_t n, size_t p)
  fun gsl_multifit_linear_alloc: size * size -> &gsl_multifit_linear_workspace = 'gsl_multifit_linear_alloc($a)';
// Function: void gsl_multifit_linear_free (gsl_multifit_linear_workspace * work)
  proc gsl_multifit_linear_free: &gsl_multifit_linear_workspace = 'gsl_multifit_linear_free($a);';
// Function: int gsl_multifit_linear (const gsl_matrix * X, const gsl_vector * y, gsl_vector * c, gsl_matrix * cov, double * chisq, gsl_multifit_linear_workspace * work)
  fun gsl_multifit_linear: &gsl_matrix * &gsl_vector * &gsl_vector * &gsl_matrix * &double * &gsl_multifit_linear_workspace -> int = 'gsl_multifit_linear($a)';
// Function: int gsl_multifit_wlinear (const gsl_matrix * X, const gsl_vector * w, const gsl_vector * y, gsl_vector * c, gsl_matrix * cov, double * chisq, gsl_multifit_linear_workspace * work)
  fun gsl_multifit_wlinear: &gsl_matrix * &gsl_vector * &gsl_vector * &gsl_vector * &gsl_matrix * &double * &gsl_multifit_linear_workspace -> int = 'gsl_multifit_wlinear($a)';
// Function: int gsl_multifit_linear_svd (const gsl_matrix * X, const gsl_vector * y, double tol, size_t * rank, gsl_vector * c, gsl_matrix * cov, double * chisq, gsl_multifit_linear_workspace * work)
  fun gsl_multifit_linear_svd: &gsl_matrix * &gsl_vector * double * &size * &gsl_vector * &gsl_matrix * &double * &gsl_multifit_linear_workspace -> int = 'gsl_multifit_linear_svd($a)';
// Function: int gsl_multifit_wlinear_svd (const gsl_matrix * X, const gsl_vector * w, const gsl_vector * y, double tol, size_t * rank, gsl_vector * c, gsl_matrix * cov, double * chisq, gsl_multifit_linear_workspace * work)
  fun gsl_multifit_wlinear_svd: &gsl_matrix * &gsl_vector * &gsl_vector * double * &size * &gsl_vector * &gsl_matrix * &double * &gsl_multifit_linear_workspace -> int = 'gsl_multifit_wlinear_svd($a)';
// Function: int gsl_multifit_linear_usvd (const gsl_matrix * X, const gsl_vector * y, double tol, size_t * rank, gsl_vector * c, gsl_matrix * cov, double * chisq, gsl_multifit_linear_workspace * work)
  fun gsl_multifit_linear_usvd: &gsl_matrix * &gsl_vector * double * &size * &gsl_vector * &gsl_matrix * &double * &gsl_multifit_linear_workspace -> int = 'gsl_multifit_linear_usvd($a)';
// Function: int gsl_multifit_wlinear_usvd (const gsl_matrix * X, const gsl_vector * w, const gsl_vector * y, double tol, size_t * rank, gsl_vector * c, gsl_matrix * cov, double * chisq, gsl_multifit_linear_workspace * work)
  fun gsl_multifit_wlinear_usvd: &gsl_matrix * &gsl_vector * &gsl_vector * double * &size * &gsl_vector * &gsl_matrix * &double * &gsl_multifit_linear_workspace -> int = 'gsl_multifit_wlinear_usvd($a)';
// Function: int gsl_multifit_linear_est (const gsl_vector * x, const gsl_vector * c, const gsl_matrix * cov, double * y, double * y_err)
  fun gsl_multifit_linear_est: &gsl_vector * &gsl_vector * &gsl_matrix * &double * &double -> int = 'gsl_multifit_linear_est($a)';
// Function: int gsl_multifit_linear_residuals (const gsl_matrix * X, const gsl_vector * y, const gsl_vector * c, gsl_vector * r)
  fun gsl_multifit_linear_residuals: &gsl_matrix * &gsl_vector * &gsl_vector * &gsl_vector -> int = 'gsl_multifit_linear_residuals($a)';
//*****
// 37.05.00 Robust-Linear-Regression.
// Function: gsl_multifit_robust_workspace * gsl_multifit_robust_alloc (const gsl_multifit_robust_type * T, const size_t n, const size_t p)
  fun gsl_multifit_robust_alloc: &gsl_multifit_robust_type * size * size -> &gsl_multifit_robust_workspace = 'gsl_multifit_robust_alloc($a)';
// Function: void gsl_multifit_robust_free (gsl_multifit_robust_workspace * w)
  proc gsl_multifit_robust_free: &gsl_multifit_robust_workspace = 'gsl_multifit_robust_free($a);';
// Function: const char * gsl_multifit_robust_name (const gsl_multifit_robust_workspace * w)
  fun gsl_multifit_robust_name: &gsl_multifit_robust_workspace -> &char = 'gsl_multifit_robust_name($a)';
// Function: int gsl_multifit_robust_tune (const double tune, gsl_multifit_robust_workspace * w)
  fun gsl_multifit_robust_tune: double * &gsl_multifit_robust_workspace -> int = 'gsl_multifit_robust_tune($a)';
// Function: int gsl_multifit_robust (const gsl_matrix * X, const gsl_vector * y, gsl_vector * c, gsl_matrix * cov, gsl_multifit_robust_workspace * w)
  fun gsl_multifit_robust: &gsl_matrix * &gsl_vector * &gsl_vector * &gsl_matrix * &gsl_multifit_robust_workspace -> int = 'gsl_multifit_robust($a)';
// Function: int gsl_multifit_robust_est (const gsl_vector * x, const gsl_vector * c, const gsl_matrix * cov, double * y, double * y_err)
  fun gsl_multifit_robust_est: &gsl_vector * &gsl_vector * &gsl_matrix * &double * &double -> int = 'gsl_multifit_robust_est($a)';
// Function: gsl_multifit_robust_stats gsl_multifit_robust_statistics (const gsl_multifit_robust_workspace * w)
  fun gsl_multifit_robust_statistics: &gsl_multifit_robust_workspace -> gsl_multifit_robust_stats = 'gsl_multifit_robust_statistics($a)';
//*****
// 38.00.00 Nonlinear-Least-Squares-Fitting.
//*****
// 38.01.00 Nonlinear-Least-Squares-Fitting-Overview.
//*****
// 38.02.00 Nonlinear-Least-Squares-Fitting-Initialisation.
// Function: gsl_multifit_fsolver * gsl_multifit_fsolver_alloc (const gsl_multifit_fsolver_type * T, size_t n, size_t p)
  fun gsl_multifit_fsolver_alloc: &gsl_multifit_fsolver_type * size * size -> &gsl_multifit_fsolver = 'gsl_multifit_fsolver_alloc($a)';
// Function: gsl_multifit_fdfsolver * gsl_multifit_fdfsolver_alloc (const gsl_multifit_fdfsolver_type * T, size_t n, size_t p)
  fun gsl_multifit_fdfsolver_alloc: &gsl_multifit_fdfsolver_type * size * size -> &gsl_multifit_fdfsolver = 'gsl_multifit_fdfsolver_alloc($a)';
// Function: int gsl_multifit_fsolver_set (gsl_multifit_fsolver * s, gsl_multifit_function * f, const gsl_vector * x)
  fun gsl_multifit_fsolver_set: &gsl_multifit_fsolver * &gsl_multifit_function * &gsl_vector -> int = 'gsl_multifit_fsolver_set($a)';
// Function: int gsl_multifit_fdfsolver_set (gsl_multifit_fdfsolver * s, gsl_multifit_function_fdf * fdf, const gsl_vector * x)
  fun gsl_multifit_fdfsolver_set: &gsl_multifit_fdfsolver * &gsl_multifit_function_fdf * &gsl_vector -> int = 'gsl_multifit_fdfsolver_set($a)';
// Function: void gsl_multifit_fsolver_free (gsl_multifit_fsolver * s)
  proc gsl_multifit_fsolver_free: &gsl_multifit_fsolver = 'gsl_multifit_fsolver_free($a);';
// Function: void gsl_multifit_fdfsolver_free (gsl_multifit_fdfsolver * s)
  proc gsl_multifit_fdfsolver_free: &gsl_multifit_fdfsolver = 'gsl_multifit_fdfsolver_free($a);';
// Function: const char * gsl_multifit_fsolver_name (const gsl_multifit_fsolver * s)
  fun gsl_multifit_fsolver_name: &gsl_multifit_fsolver -> &char = 'gsl_multifit_fsolver_name($a)';
// Function: const char * gsl_multifit_fdfsolver_name (const gsl_multifit_fdfsolver * s)
  fun gsl_multifit_fdfsolver_name: &gsl_multifit_fdfsolver -> &char = 'gsl_multifit_fdfsolver_name($a)';
//*****
// 38.03.00 Nonlinear-Least-Squares-Fitting-Providing-the-Functon-to-be-Minimised.
//*****
// 38.04.00 Nonlinear-Least-Squares-Fitting-Finite-Difference-Jacobian.
// Function: int gsl_multifit_fdfsolver_dif_df (const gsl_vector * x, gsl_multifit_function_fdf * fdf, const gsl_vector * f, gsl_matrix * J)
  fun gsl_multifit_fdfsolver_dif_df: &gsl_vector * &gsl_multifit_function_fdf * &gsl_vector * &gsl_matrix -> int = 'gsl_multifit_fdfsolver_dif_df($a)';
// Function: int gsl_multifit_fdfsolver_dif_fdf (const gsl_vector * x, gsl_multifit_function_fdf * fdf, gsl_vector * f, gsl_matrix * J)
  fun gsl_multifit_fdfsolver_dif_fdf: &gsl_vector * &gsl_multifit_function_fdf * &gsl_vector * &gsl_matrix -> int = 'gsl_multifit_fdfsolver_dif_fdf($a)';
//*****
// 38.05.00 Nonlinear-Least-Squares-Fitting-Iteration.
// Function: int gsl_multifit_fsolver_iterate (gsl_multifit_fsolver * s)
  fun gsl_multifit_fsolver_iterate: &gsl_multifit_fsolver -> int = 'gsl_multifit_fsolver_iterate($a)';
// Function: int gsl_multifit_fdfsolver_iterate (gsl_multifit_fdfsolver * s)
  fun gsl_multifit_fdfsolver_iterate: &gsl_multifit_fdfsolver -> int = 'gsl_multifit_fdfsolver_iterate($a)';
// Function: gsl_vector * gsl_multifit_fsolver_position (const gsl_multifit_fsolver * s)
  fun gsl_multifit_fsolver_position: &gsl_multifit_fsolver -> &gsl_vector = 'gsl_multifit_fsolver_position($a)';
// Function: gsl_vector * gsl_multifit_fdfsolver_position (const gsl_multifit_fdfsolver * s)
  fun gsl_multifit_fdfsolver_position: &gsl_multifit_fdfsolver -> &gsl_vector = 'gsl_multifit_fdfsolver_position($a)';
//*****
// 38.06.00 Nonlinear-Least-Squares-Fitting-Stopping.
// Function: int gsl_multifit_test_delta (const gsl_vector * dx, const gsl_vector * x, double epsabs, double epsrel)
  fun gsl_multifit_test_delta: &gsl_vector * &gsl_vector * double * double -> int = 'gsl_multifit_test_delta($a)';
// Function: int gsl_multifit_test_gradient (const gsl_vector * g, double epsabs)
  fun gsl_multifit_test_gradient: &gsl_vector * double -> int = 'gsl_multifit_test_gradient($a)';
// Function: int gsl_multifit_gradient (const gsl_matrix * J, const gsl_vector * f, gsl_vector * g)
  fun gsl_multifit_gradient: &gsl_matrix * &gsl_vector * &gsl_vector -> int = 'gsl_multifit_gradient($a)';
//*****
// 38.07.00 Nonlinear-Least-Squares-Fitting-Driver.
// Function: int gsl_multifit_fsolver_driver (gsl_multifit_fsolver * s, const size_t maxiter, const double epsabs, const double epsrel)
  fun gsl_multifit_fsolver_driver: &gsl_multifit_fsolver * size * double * double -> int = 'gsl_multifit_fsolver_driver($a)';
// Function: int gsl_multifit_fdfsolver_driver (gsl_multifit_fdfsolver * s, const size_t maxiter, const double epsabs, const double epsrel)
  fun gsl_multifit_fdfsolver_driver: &gsl_multifit_fdfsolver * size * double * double -> int = 'gsl_multifit_fdfsolver_driver($a)';
//*****
// 38.08.00 Nonlinear-Least-Squares-Fitting-Minimisation-using-Derivatives.
//*****
// 38.09.00 Nonlinear-Least-Squares-Fitting-Minimisation-without-Derivatives.
//*****
// 38.10.00 Nonlinear-Least-Squares-Fitting-Computing-the-covariance-matrix-of-best-fit-parameters.
// Function: int gsl_multifit_covar (const gsl_matrix * J, double epsrel, gsl_matrix * covar)
  fun gsl_multifit_covar: &gsl_matrix * double * &gsl_matrix -> int = 'gsl_multifit_covar($a)';
//*****
// 39.00.00 Basis-Splines.
//*****
// 39.01.00 Basis-Splines-Overview.
//*****
// 39.02.00 Basis-Splines-Initialisation.
// Function: gsl_bspline_workspace * gsl_bspline_alloc (const size_t k, const size_t nbreak)
  fun gsl_bspline_alloc: size * size -> &gsl_bspline_workspace = 'gsl_bspline_alloc($a)';
// Function: void gsl_bspline_free (gsl_bspline_workspace * w)
  proc gsl_bspline_free: &gsl_bspline_workspace = 'gsl_bspline_free($a);';
// Function: gsl_bspline_deriv_workspace * gsl_bspline_deriv_alloc (const size_t k)
  fun gsl_bspline_deriv_alloc: size -> &gsl_bspline_deriv_workspace = 'gsl_bspline_deriv_alloc($a)';
// Function: void gsl_bspline_deriv_free (gsl_bspline_deriv_workspace * w)
  proc gsl_bspline_deriv_free: &gsl_bspline_deriv_workspace = 'gsl_bspline_deriv_free($a);';
//*****
// 39.03.00 Basis-Splines-Constructing-the-knots-vector.
// Function: int gsl_bspline_knots (const gsl_vector * breakpts, gsl_bspline_workspace * w)
  fun gsl_bspline_knots: &gsl_vector * &gsl_bspline_workspace -> int = 'gsl_bspline_knots($a)';
// Function: int gsl_bspline_knots_uniform (const double a, const double b, gsl_bspline_workspace * w)
  fun gsl_bspline_knots_uniform: double * double * &gsl_bspline_workspace -> int = 'gsl_bspline_knots_uniform($a)';
//*****
// 39.04.00 Basis-Splines-Evaluation.
// Function: int gsl_bspline_eval (const double x, gsl_vector * B, gsl_bspline_workspace * w)
  fun gsl_bspline_eval: double * &gsl_vector * &gsl_bspline_workspace -> int = 'gsl_bspline_eval($a)';
// Function: int gsl_bspline_eval_nonzero (const double x, gsl_vector * Bk, size_t * istart, size_t * iend, gsl_bspline_workspace * w)
  fun gsl_bspline_eval_nonzero: double * &gsl_vector * &size * &size * &gsl_bspline_workspace -> int = 'gsl_bspline_eval_nonzero($a)';
// Function: size_t gsl_bspline_ncoeffs (gsl_bspline_workspace * w)
  fun gsl_bspline_ncoeffs: &gsl_bspline_workspace -> size = 'gsl_bspline_ncoeffs($a)';
//*****
// 39.05.00 Basis-Splines-Evaluation-Derivatives.
// Function: int gsl_bspline_deriv_eval (const double x, const size_t nderiv, gsl_matrix * dB, gsl_bspline_workspace * w, gsl_bspline_deriv_workspace * dw)
  fun gsl_bspline_deriv_eval: double * size * &gsl_matrix * &gsl_bspline_workspace * &gsl_bspline_deriv_workspace -> int = 'gsl_bspline_deriv_eval($a)';
// Function: int gsl_bspline_deriv_eval_nonzero (const double x, const size_t nderiv, gsl_matrix * dB, size_t * istart, size_t * iend, gsl_bspline_workspace * w, gsl_bspline_deriv_workspace * dw)
  fun gsl_bspline_deriv_eval_nonzero: double * size * &gsl_matrix * &size * &size * &gsl_bspline_workspace * &gsl_bspline_deriv_workspace -> int = 'gsl_bspline_deriv_eval_nonzero($a)';
//*****
// 39.06.00 Basis-Splines-Greville-abscissae.
// Function: double gsl_bspline_greville_abscissa (size_t i, gsl_bspline_workspace *w);
  fun gsl_bspline_greville_abscissa: size * gsl_bspline_workspace -> double = 'gsl_bspline_greville_abscissa($a)';
//*****
// 40.00.00 Physical-Constants.
//*****
// 40.01.00 Physical-Constants-Fundamental.
//*****
// 40.02.00 Physical-Constants-Astronomy.
//*****
// 40.03.00 Physical-Constants-Nuclear.
//*****
// 40.04.00 Physical-Constants-Time.
//*****
// 40.05.00 Physical-Constants-Imperial.
//*****
// 40.06.00 Physical-Constants-Nautical.
//*****
// 40.07.00 Physical-Constants-Printer.
//*****
// 40.08.00 Physical-Constants-Spatial.
//*****
// 40.09.00 Physical-Constants-Mass.
//*****
// 40.10.00 Physical-Constants-Thermal-Energy.
//*****
// 40.11.00 Physical-Constants-Pressure.
//*****
// 40.12.00 Physical-Constants-Viscosity.
//*****
// 40.13.00 Physical-Constants-Light.
//*****
// 40.14.00 Physical-Constants-Radioactivity.
//*****
// 40.15.00 Physical-Constants-Force.
//*****
// 40.16.00 Physical-Constants-Prefixes.
//*****
// 41.00.00 IEEE-floats.
//*****
// 41.01.00 IEEE-floats-representation.
// Function: void gsl_ieee_fprintf_float (FILE * stream, const float * x)
  proc gsl_ieee_fprintf_float: &FILE * &float = 'gsl_ieee_fprintf_float($a);';
// Function: void gsl_ieee_fprintf_double (FILE * stream, const double * x)
  proc gsl_ieee_fprintf_double: &FILE * &double = 'gsl_ieee_fprintf_double($a);';
// Function: void gsl_ieee_printf_float (const float * x)
  proc gsl_ieee_printf_float: &float = 'gsl_ieee_printf_float($a);';
// Function: void gsl_ieee_printf_double (const double * x)
  proc gsl_ieee_printf_double: &double = 'gsl_ieee_printf_double($a);';
//*****
// 41.02.00 IEEE-floats-environment.
// Function: void gsl_ieee_env_setup ()
  proc gsl_ieee_env_setup: unit = 'gsl_ieee_env_setup($a);';
@

@h1 CBLAS interface
To be moved, since it doesn't really belong inside GSL.

@tangle cblas.flx

//*****
// D .00.00 GSL-CBLAS.
//*****
// D .01.00 GSL-CBLAS-Level-1.
// Function: float cblas_sdsdot (const int N, const float alpha, const float * x, const int incx, const float * y, const int incy)
  fun cblas_sdsdot: int * float * &float * int * &float * int -> float = 'cblas_sdsdot($a)';
// Function: double cblas_dsdot (const int N, const float * x, const int incx, const float * y, const int incy)
  fun cblas_dsdot: int * &float * int * &float * int -> double = 'cblas_dsdot($a)';
// Function: float cblas_sdot (const int N, const float * x, const int incx, const float * y, const int incy)
  fun cblas_sdot: int * &float * int * &float * int -> float = 'cblas_sdot($a)';
// Function: double cblas_ddot (const int N, const double * x, const int incx, const double * y, const int incy)
  fun cblas_ddot: int * &double * int * &double * int -> double = 'cblas_ddot($a)';
// Function: void cblas_cdotu_sub (const int N, const void * x, const int incx, const void * y, const int incy, void * dotu)
  proc cblas_cdotu_sub: int * &void * int * &void * int * &void = 'cblas_cdotu_sub($a);';
// Function: void cblas_cdotc_sub (const int N, const void * x, const int incx, const void * y, const int incy, void * dotc)
  proc cblas_cdotc_sub: int * &void * int * &void * int * &void = 'cblas_cdotc_sub($a);';
// Function: void cblas_zdotu_sub (const int N, const void * x, const int incx, const void * y, const int incy, void * dotu)
  proc cblas_zdotu_sub: int * &void * int * &void * int * &void = 'cblas_zdotu_sub($a);';
// Function: void cblas_zdotc_sub (const int N, const void * x, const int incx, const void * y, const int incy, void * dotc)
  proc cblas_zdotc_sub: int * &void * int * &void * int * &void = 'cblas_zdotc_sub($a);';
// Function: float cblas_snrm2 (const int N, const float * x, const int incx)
  fun cblas_snrm2: int * &float * int -> float = 'cblas_snrm2($a)';
// Function: float cblas_sasum (const int N, const float * x, const int incx)
  fun cblas_sasum: int * &float * int -> float = 'cblas_sasum($a)';
// Function: double cblas_dnrm2 (const int N, const double * x, const int incx)
  fun cblas_dnrm2: int * &double * int -> double = 'cblas_dnrm2($a)';
// Function: double cblas_dasum (const int N, const double * x, const int incx)
  fun cblas_dasum: int * &double * int -> double = 'cblas_dasum($a)';
// Function: float cblas_scnrm2 (const int N, const void * x, const int incx)
  fun cblas_scnrm2: int * &void * int -> float = 'cblas_scnrm2($a)';
// Function: float cblas_scasum (const int N, const void * x, const int incx)
  fun cblas_scasum: int * &void * int -> float = 'cblas_scasum($a)';
// Function: double cblas_dznrm2 (const int N, const void * x, const int incx)
  fun cblas_dznrm2: int * &void * int -> double = 'cblas_dznrm2($a)';
// Function: double cblas_dzasum (const int N, const void * x, const int incx)
  fun cblas_dzasum: int * &void * int -> double = 'cblas_dzasum($a)';
// Function: CBLAS_INDEX cblas_isamax (const int N, const float * x, const int incx)
  fun cblas_isamax: int * &float * int -> CBLAS_INDEX = 'cblas_isamax($a)';
// Function: CBLAS_INDEX cblas_idamax (const int N, const double * x, const int incx)
  fun cblas_idamax: int * &double * int -> CBLAS_INDEX = 'cblas_idamax($a)';
// Function: CBLAS_INDEX cblas_icamax (const int N, const void * x, const int incx)
  fun cblas_icamax: int * &void * int -> CBLAS_INDEX = 'cblas_icamax($a)';
// Function: CBLAS_INDEX cblas_izamax (const int N, const void * x, const int incx)
  fun cblas_izamax: int * &void * int -> CBLAS_INDEX = 'cblas_izamax($a)';
// Function: void cblas_sswap (const int N, float * x, const int incx, float * y, const int incy)
  proc cblas_sswap: int * &float * int * &float * int = 'cblas_sswap($a);';
// Function: void cblas_scopy (const int N, const float * x, const int incx, float * y, const int incy)
  proc cblas_scopy: int * &float * int * &float * int = 'cblas_scopy($a);';
// Function: void cblas_saxpy (const int N, const float alpha, const float * x, const int incx, float * y, const int incy)
  proc cblas_saxpy: int * float * &float * int * &float * int = 'cblas_saxpy($a);';
// Function: void cblas_dswap (const int N, double * x, const int incx, double * y, const int incy)
  proc cblas_dswap: int * &double * int * &double * int = 'cblas_dswap($a);';
// Function: void cblas_dcopy (const int N, const double * x, const int incx, double * y, const int incy)
  proc cblas_dcopy: int * &double * int * &double * int = 'cblas_dcopy($a);';
// Function: void cblas_daxpy (const int N, const double alpha, const double * x, const int incx, double * y, const int incy)
  proc cblas_daxpy: int * double * &double * int * &double * int = 'cblas_daxpy($a);';
// Function: void cblas_cswap (const int N, void * x, const int incx, void * y, const int incy)
  proc cblas_cswap: int * &void * int * &void * int = 'cblas_cswap($a);';
// Function: void cblas_ccopy (const int N, const void * x, const int incx, void * y, const int incy)
  proc cblas_ccopy: int * &void * int * &void * int = 'cblas_ccopy($a);';
// Function: void cblas_caxpy (const int N, const void * alpha, const void * x, const int incx, void * y, const int incy)
  proc cblas_caxpy: int * &void * &void * int * &void * int = 'cblas_caxpy($a);';
// Function: void cblas_zswap (const int N, void * x, const int incx, void * y, const int incy)
  proc cblas_zswap: int * &void * int * &void * int = 'cblas_zswap($a);';
// Function: void cblas_zcopy (const int N, const void * x, const int incx, void * y, const int incy)
  proc cblas_zcopy: int * &void * int * &void * int = 'cblas_zcopy($a);';
// Function: void cblas_zaxpy (const int N, const void * alpha, const void * x, const int incx, void * y, const int incy)
  proc cblas_zaxpy: int * &void * &void * int * &void * int = 'cblas_zaxpy($a);';
// Function: void cblas_srotg (float * a, float * b, float * c, float * s)
  proc cblas_srotg: &float * &float * &float * &float = 'cblas_srotg($a);';
// Function: void cblas_srotmg (float * d1, float * d2, float * b1, const float b2, float * P)
  proc cblas_srotmg: &float * &float * &float * float * &float = 'cblas_srotmg($a);';
// Function: void cblas_srot (const int N, float * x, const int incx, float * y, const int incy, const float c, const float s)
  proc cblas_srot: int * &float * int * &float * int * float * float = 'cblas_srot($a);';
// Function: void cblas_srotm (const int N, float * x, const int incx, float * y, const int incy, const float * P)
  proc cblas_srotm: int * &float * int * &float * int * &float = 'cblas_srotm($a);';
// Function: void cblas_drotg (double * a, double * b, double * c, double * s)
  proc cblas_drotg: &double * &double * &double * &double = 'cblas_drotg($a);';
// Function: void cblas_drotmg (double * d1, double * d2, double * b1, const double b2, double * P)
  proc cblas_drotmg: &double * &double * &double * double * &double = 'cblas_drotmg($a);';
// Function: void cblas_drot (const int N, double * x, const int incx, double * y, const int incy, const double c, const double s)
  proc cblas_drot: int * &double * int * &double * int * double * double = 'cblas_drot($a);';
// Function: void cblas_drotm (const int N, double * x, const int incx, double * y, const int incy, const double * P)
  proc cblas_drotm: int * &double * int * &double * int * &double = 'cblas_drotm($a);';
// Function: void cblas_sscal (const int N, const float alpha, float * x, const int incx)
  proc cblas_sscal: int * float * &float * int = 'cblas_sscal($a);';
// Function: void cblas_dscal (const int N, const double alpha, double * x, const int incx)
  proc cblas_dscal: int * double * &double * int = 'cblas_dscal($a);';
// Function: void cblas_cscal (const int N, const void * alpha, void * x, const int incx)
  proc cblas_cscal: int * &void * &void * int = 'cblas_cscal($a);';
// Function: void cblas_zscal (const int N, const void * alpha, void * x, const int incx)
  proc cblas_zscal: int * &void * &void * int = 'cblas_zscal($a);';
// Function: void cblas_csscal (const int N, const float alpha, void * x, const int incx)
  proc cblas_csscal: int * float * &void * int = 'cblas_csscal($a);';
// Function: void cblas_zdscal (const int N, const double alpha, void * x, const int incx)
  proc cblas_zdscal: int * double * &void * int = 'cblas_zdscal($a);';
//*****
// D .02.00 GSL-CBLAS-Level-2.
// Function: void cblas_sgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const int M, const int N, const float alpha, const float * A, const int lda, const float * x, const int incx, const float beta, float * y, const int incy)
  proc cblas_sgemv: CBLAS_ORDER * CBLAS_TRANSPOSE * int * int * float * &float * int * &float * int * float * &float * int = 'cblas_sgemv($a);';
// Function: void cblas_sgbmv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const int M, const int N, const int KL, const int KU, const float alpha, const float * A, const int lda, const float * x, const int incx, const float beta, float * y, const int incy)
  proc cblas_sgbmv: CBLAS_ORDER * CBLAS_TRANSPOSE * int * int * int * int * float * &float * int * &float * int * float * &float * int = 'cblas_sgbmv($a);';
// Function: void cblas_strmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const float * A, const int lda, float * x, const int incx)
  proc cblas_strmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &float * int * &float * int = 'cblas_strmv($a);';
// Function: void cblas_stbmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const int K, const float * A, const int lda, float * x, const int incx)
  proc cblas_stbmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &float * int * &float * int = 'cblas_stbmv($a);';
// Function: void cblas_stpmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const float * Ap, float * x, const int incx)
  proc cblas_stpmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &float * &float * int = 'cblas_stpmv($a);';
// Function: void cblas_strsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const float * A, const int lda, float * x, const int incx)
  proc cblas_strsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &float * int * &float * int = 'cblas_strsv($a);';
// Function: void cblas_stbsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const int K, const float * A, const int lda, float * x, const int incx)
  proc cblas_stbsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &float * int * &float * int = 'cblas_stbsv($a);';
// Function: void cblas_stpsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const float * Ap, float * x, const int incx)
  proc cblas_stpsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &float * &float * int = 'cblas_stpsv($a);';
// Function: void cblas_dgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const int M, const int N, const double alpha, const double * A, const int lda, const double * x, const int incx, const double beta, double * y, const int incy)
  proc cblas_dgemv: CBLAS_ORDER * CBLAS_TRANSPOSE * int * int * double * &double * int * &double * int * double * &double * int = 'cblas_dgemv($a);';
// Function: void cblas_dgbmv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const int M, const int N, const int KL, const int KU, const double alpha, const double * A, const int lda, const double * x, const int incx, const double beta, double * y, const int incy)
  proc cblas_dgbmv: CBLAS_ORDER * CBLAS_TRANSPOSE * int * int * int * int * double * &double * int * &double * int * double * &double * int = 'cblas_dgbmv($a);';
// Function: void cblas_dtrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const double * A, const int lda, double * x, const int incx)
  proc cblas_dtrmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &double * int * &double * int = 'cblas_dtrmv($a);';
// Function: void cblas_dtbmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const int K, const double * A, const int lda, double * x, const int incx)
  proc cblas_dtbmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &double * int * &double * int = 'cblas_dtbmv($a);';
// Function: void cblas_dtpmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const double * Ap, double * x, const int incx)
  proc cblas_dtpmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &double * &double * int = 'cblas_dtpmv($a);';
// Function: void cblas_dtrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const double * A, const int lda, double * x, const int incx)
  proc cblas_dtrsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &double * int * &double * int = 'cblas_dtrsv($a);';
// Function: void cblas_dtbsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const int K, const double * A, const int lda, double * x, const int incx)
  proc cblas_dtbsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &double * int * &double * int = 'cblas_dtbsv($a);';
// Function: void cblas_dtpsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const double * Ap, double * x, const int incx)
  proc cblas_dtpsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &double * &double * int = 'cblas_dtpsv($a);';
// Function: void cblas_cgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const int M, const int N, const void * alpha, const void * A, const int lda, const void * x, const int incx, const void * beta, void * y, const int incy)
  proc cblas_cgemv: CBLAS_ORDER * CBLAS_TRANSPOSE * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_cgemv($a);';
// Function: void cblas_cgbmv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const int M, const int N, const int KL, const int KU, const void * alpha, const void * A, const int lda, const void * x, const int incx, const void * beta, void * y, const int incy)
  proc cblas_cgbmv: CBLAS_ORDER * CBLAS_TRANSPOSE * int * int * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_cgbmv($a);';
// Function: void cblas_ctrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const void * A, const int lda, void * x, const int incx)
  proc cblas_ctrmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &void * int * &void * int = 'cblas_ctrmv($a);';
// Function: void cblas_ctbmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const int K, const void * A, const int lda, void * x, const int incx)
  proc cblas_ctbmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &void * int * &void * int = 'cblas_ctbmv($a);';
// Function: void cblas_ctpmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const void * Ap, void * x, const int incx)
  proc cblas_ctpmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &void * &void * int = 'cblas_ctpmv($a);';
// Function: void cblas_ctrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const void * A, const int lda, void * x, const int incx)
  proc cblas_ctrsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &void * int * &void * int = 'cblas_ctrsv($a);';
// Function: void cblas_ctbsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const int K, const void * A, const int lda, void * x, const int incx)
  proc cblas_ctbsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &void * int * &void * int = 'cblas_ctbsv($a);';
// Function: void cblas_ctpsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const void * Ap, void * x, const int incx)
  proc cblas_ctpsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &void * &void * int = 'cblas_ctpsv($a);';
// Function: void cblas_zgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const int M, const int N, const void * alpha, const void * A, const int lda, const void * x, const int incx, const void * beta, void * y, const int incy)
  proc cblas_zgemv: CBLAS_ORDER * CBLAS_TRANSPOSE * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_zgemv($a);';
// Function: void cblas_zgbmv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const int M, const int N, const int KL, const int KU, const void * alpha, const void * A, const int lda, const void * x, const int incx, const void * beta, void * y, const int incy)
  proc cblas_zgbmv: CBLAS_ORDER * CBLAS_TRANSPOSE * int * int * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_zgbmv($a);';
// Function: void cblas_ztrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const void * A, const int lda, void * x, const int incx)
  proc cblas_ztrmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &void * int * &void * int = 'cblas_ztrmv($a);';
// Function: void cblas_ztbmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const int K, const void * A, const int lda, void * x, const int incx)
  proc cblas_ztbmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &void * int * &void * int = 'cblas_ztbmv($a);';
// Function: void cblas_ztpmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const void * Ap, void * x, const int incx)
  proc cblas_ztpmv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &void * &void * int = 'cblas_ztpmv($a);';
// Function: void cblas_ztrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const void * A, const int lda, void * x, const int incx)
  proc cblas_ztrsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &void * int * &void * int = 'cblas_ztrsv($a);';
// Function: void cblas_ztbsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const int K, const void * A, const int lda, void * x, const int incx)
  proc cblas_ztbsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &void * int * &void * int = 'cblas_ztbsv($a);';
// Function: void cblas_ztpsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int N, const void * Ap, void * x, const int incx)
  proc cblas_ztpsv: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * &void * &void * int = 'cblas_ztpsv($a);';
// Function: void cblas_ssymv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const float alpha, const float * A, const int lda, const float * x, const int incx, const float beta, float * y, const int incy)
  proc cblas_ssymv: CBLAS_ORDER * CBLAS_UPLO * int * float * &float * int * &float * int * float * &float * int = 'cblas_ssymv($a);';
// Function: void cblas_ssbmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const int K, const float alpha, const float * A, const int lda, const float * x, const int incx, const float beta, float * y, const int incy)
  proc cblas_ssbmv: CBLAS_ORDER * CBLAS_UPLO * int * int * float * &float * int * &float * int * float * &float * int = 'cblas_ssbmv($a);';
// Function: void cblas_sspmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const float alpha, const float * Ap, const float * x, const int incx, const float beta, float * y, const int incy)
  proc cblas_sspmv: CBLAS_ORDER * CBLAS_UPLO * int * float * &float * &float * int * float * &float * int = 'cblas_sspmv($a);';
// Function: void cblas_sger (const enum CBLAS_ORDER order, const int M, const int N, const float alpha, const float * x, const int incx, const float * y, const int incy, float * A, const int lda)
  proc cblas_sger: CBLAS_ORDER * int * int * float * &float * int * &float * int * &float * int = 'cblas_sger($a);';
// Function: void cblas_ssyr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const float alpha, const float * x, const int incx, float * A, const int lda)
  proc cblas_ssyr: CBLAS_ORDER * CBLAS_UPLO * int * float * &float * int * &float * int = 'cblas_ssyr($a);';
// Function: void cblas_sspr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const float alpha, const float * x, const int incx, float * Ap)
  proc cblas_sspr: CBLAS_ORDER * CBLAS_UPLO * int * float * &float * int * &float = 'cblas_sspr($a);';
// Function: void cblas_ssyr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const float alpha, const float * x, const int incx, const float * y, const int incy, float * A, const int lda)
  proc cblas_ssyr2: CBLAS_ORDER * CBLAS_UPLO * int * float * &float * int * &float * int * &float * int = 'cblas_ssyr2($a);';
// Function: void cblas_sspr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const float alpha, const float * x, const int incx, const float * y, const int incy, float * A)
  proc cblas_sspr2: CBLAS_ORDER * CBLAS_UPLO * int * float * &float * int * &float * int * &float = 'cblas_sspr2($a);';
// Function: void cblas_dsymv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const double alpha, const double * A, const int lda, const double * x, const int incx, const double beta, double * y, const int incy)
  proc cblas_dsymv: CBLAS_ORDER * CBLAS_UPLO * int * double * &double * int * &double * int * double * &double * int = 'cblas_dsymv($a);';
// Function: void cblas_dsbmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const int K, const double alpha, const double * A, const int lda, const double * x, const int incx, const double beta, double * y, const int incy)
  proc cblas_dsbmv: CBLAS_ORDER * CBLAS_UPLO * int * int * double * &double * int * &double * int * double * &double * int = 'cblas_dsbmv($a);';
// Function: void cblas_dspmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const double alpha, const double * Ap, const double * x, const int incx, const double beta, double * y, const int incy)
  proc cblas_dspmv: CBLAS_ORDER * CBLAS_UPLO * int * double * &double * &double * int * double * &double * int = 'cblas_dspmv($a);';
// Function: void cblas_dger (const enum CBLAS_ORDER order, const int M, const int N, const double alpha, const double * x, const int incx, const double * y, const int incy, double * A, const int lda)
  proc cblas_dger: CBLAS_ORDER * int * int * double * &double * int * &double * int * &double * int = 'cblas_dger($a);';
// Function: void cblas_dsyr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const double alpha, const double * x, const int incx, double * A, const int lda)
  proc cblas_dsyr: CBLAS_ORDER * CBLAS_UPLO * int * double * &double * int * &double * int = 'cblas_dsyr($a);';
// Function: void cblas_dspr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const double alpha, const double * x, const int incx, double * Ap)
  proc cblas_dspr: CBLAS_ORDER * CBLAS_UPLO * int * double * &double * int * &double = 'cblas_dspr($a);';
// Function: void cblas_dsyr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const double alpha, const double * x, const int incx, const double * y, const int incy, double * A, const int lda)
  proc cblas_dsyr2: CBLAS_ORDER * CBLAS_UPLO * int * double * &double * int * &double * int * &double * int = 'cblas_dsyr2($a);';
// Function: void cblas_dspr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const double alpha, const double * x, const int incx, const double * y, const int incy, double * A)
  proc cblas_dspr2: CBLAS_ORDER * CBLAS_UPLO * int * double * &double * int * &double * int * &double = 'cblas_dspr2($a);';
// Function: void cblas_chemv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const void * alpha, const void * A, const int lda, const void * x, const int incx, const void * beta, void * y, const int incy)
  proc cblas_chemv: CBLAS_ORDER * CBLAS_UPLO * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_chemv($a);';
// Function: void cblas_chbmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const int K, const void * alpha, const void * A, const int lda, const void * x, const int incx, const void * beta, void * y, const int incy)
  proc cblas_chbmv: CBLAS_ORDER * CBLAS_UPLO * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_chbmv($a);';
// Function: void cblas_chpmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const void * alpha, const void * Ap, const void * x, const int incx, const void * beta, void * y, const int incy)
  proc cblas_chpmv: CBLAS_ORDER * CBLAS_UPLO * int * &void * &void * &void * int * &void * &void * int = 'cblas_chpmv($a);';
// Function: void cblas_cgeru (const enum CBLAS_ORDER order, const int M, const int N, const void * alpha, const void * x, const int incx, const void * y, const int incy, void * A, const int lda)
  proc cblas_cgeru: CBLAS_ORDER * int * int * &void * &void * int * &void * int * &void * int = 'cblas_cgeru($a);';
// Function: void cblas_cgerc (const enum CBLAS_ORDER order, const int M, const int N, const void * alpha, const void * x, const int incx, const void * y, const int incy, void * A, const int lda)
  proc cblas_cgerc: CBLAS_ORDER * int * int * &void * &void * int * &void * int * &void * int = 'cblas_cgerc($a);';
// Function: void cblas_cher (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const float alpha, const void * x, const int incx, void * A, const int lda)
  proc cblas_cher: CBLAS_ORDER * CBLAS_UPLO * int * float * &void * int * &void * int = 'cblas_cher($a);';
// Function: void cblas_chpr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const float alpha, const void * x, const int incx, void * A)
  proc cblas_chpr: CBLAS_ORDER * CBLAS_UPLO * int * float * &void * int * &void = 'cblas_chpr($a);';
// Function: void cblas_cher2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const void * alpha, const void * x, const int incx, const void * y, const int incy, void * A, const int lda)
  proc cblas_cher2: CBLAS_ORDER * CBLAS_UPLO * int * &void * &void * int * &void * int * &void * int = 'cblas_cher2($a);';
// Function: void cblas_chpr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const void * alpha, const void * x, const int incx, const void * y, const int incy, void * Ap)
  proc cblas_chpr2: CBLAS_ORDER * CBLAS_UPLO * int * &void * &void * int * &void * int * &void = 'cblas_chpr2($a);';
// Function: void cblas_zhemv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const void * alpha, const void * A, const int lda, const void * x, const int incx, const void * beta, void * y, const int incy)
  proc cblas_zhemv: CBLAS_ORDER * CBLAS_UPLO * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_zhemv($a);';
// Function: void cblas_zhbmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const int K, const void * alpha, const void * A, const int lda, const void * x, const int incx, const void * beta, void * y, const int incy)
  proc cblas_zhbmv: CBLAS_ORDER * CBLAS_UPLO * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_zhbmv($a);';
// Function: void cblas_zhpmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const void * alpha, const void * Ap, const void * x, const int incx, const void * beta, void * y, const int incy)
  proc cblas_zhpmv: CBLAS_ORDER * CBLAS_UPLO * int * &void * &void * &void * int * &void * &void * int = 'cblas_zhpmv($a);';
// Function: void cblas_zgeru (const enum CBLAS_ORDER order, const int M, const int N, const void * alpha, const void * x, const int incx, const void * y, const int incy, void * A, const int lda)
  proc cblas_zgeru: CBLAS_ORDER * int * int * &void * &void * int * &void * int * &void * int = 'cblas_zgeru($a);';
// Function: void cblas_zgerc (const enum CBLAS_ORDER order, const int M, const int N, const void * alpha, const void * x, const int incx, const void * y, const int incy, void * A, const int lda)
  proc cblas_zgerc: CBLAS_ORDER * int * int * &void * &void * int * &void * int * &void * int = 'cblas_zgerc($a);';
// Function: void cblas_zher (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const double alpha, const void * x, const int incx, void * A, const int lda)
  proc cblas_zher: CBLAS_ORDER * CBLAS_UPLO * int * double * &void * int * &void * int = 'cblas_zher($a);';
// Function: void cblas_zhpr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const double alpha, const void * x, const int incx, void * A)
  proc cblas_zhpr: CBLAS_ORDER * CBLAS_UPLO * int * double * &void * int * &void = 'cblas_zhpr($a);';
// Function: void cblas_zher2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const void * alpha, const void * x, const int incx, const void * y, const int incy, void * A, const int lda)
  proc cblas_zher2: CBLAS_ORDER * CBLAS_UPLO * int * &void * &void * int * &void * int * &void * int = 'cblas_zher2($a);';
// Function: void cblas_zhpr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N, const void * alpha, const void * x, const int incx, const void * y, const int incy, void * Ap)
  proc cblas_zhpr2: CBLAS_ORDER * CBLAS_UPLO * int * &void * &void * int * &void * int * &void = 'cblas_zhpr2($a);';
//*****
// D .03.00 GSL-CBLAS-Level-3.
// Function: void cblas_sgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const int M, const int N, const int K, const float alpha, const float * A, const int lda, const float * B, const int ldb, const float beta, float * C, const int ldc)
  proc cblas_sgemm: CBLAS_ORDER * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * int * int * int * float * &float * int * &float * int * float * &float * int = 'cblas_sgemm($a);';
// Function: void cblas_ssymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const int M, const int N, const float alpha, const float * A, const int lda, const float * B, const int ldb, const float beta, float * C, const int ldc)
  proc cblas_ssymm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * int * int * float * &float * int * &float * int * float * &float * int = 'cblas_ssymm($a);';
// Function: void cblas_ssyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const float alpha, const float * A, const int lda, const float beta, float * C, const int ldc)
  proc cblas_ssyrk: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * float * &float * int * float * &float * int = 'cblas_ssyrk($a);';
// Function: void cblas_ssyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const float alpha, const float * A, const int lda, const float * B, const int ldb, const float beta, float * C, const int ldc)
  proc cblas_ssyr2k: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * float * &float * int * &float * int * float * &float * int = 'cblas_ssyr2k($a);';
// Function: void cblas_strmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int M, const int N, const float alpha, const float * A, const int lda, float * B, const int ldb)
  proc cblas_strmm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * float * &float * int * &float * int = 'cblas_strmm($a);';
// Function: void cblas_strsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int M, const int N, const float alpha, const float * A, const int lda, float * B, const int ldb)
  proc cblas_strsm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * float * &float * int * &float * int = 'cblas_strsm($a);';
// Function: void cblas_dgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const int M, const int N, const int K, const double alpha, const double * A, const int lda, const double * B, const int ldb, const double beta, double * C, const int ldc)
  proc cblas_dgemm: CBLAS_ORDER * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * int * int * int * double * &double * int * &double * int * double * &double * int = 'cblas_dgemm($a);';
// Function: void cblas_dsymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const int M, const int N, const double alpha, const double * A, const int lda, const double * B, const int ldb, const double beta, double * C, const int ldc)
  proc cblas_dsymm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * int * int * double * &double * int * &double * int * double * &double * int = 'cblas_dsymm($a);';
// Function: void cblas_dsyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const double alpha, const double * A, const int lda, const double beta, double * C, const int ldc)
  proc cblas_dsyrk: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * double * &double * int * double * &double * int = 'cblas_dsyrk($a);';
// Function: void cblas_dsyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const double alpha, const double * A, const int lda, const double * B, const int ldb, const double beta, double * C, const int ldc)
  proc cblas_dsyr2k: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * double * &double * int * &double * int * double * &double * int = 'cblas_dsyr2k($a);';
// Function: void cblas_dtrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int M, const int N, const double alpha, const double * A, const int lda, double * B, const int ldb)
  proc cblas_dtrmm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * double * &double * int * &double * int = 'cblas_dtrmm($a);';
// Function: void cblas_dtrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int M, const int N, const double alpha, const double * A, const int lda, double * B, const int ldb)
  proc cblas_dtrsm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * double * &double * int * &double * int = 'cblas_dtrsm($a);';
// Function: void cblas_cgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const int M, const int N, const int K, const void * alpha, const void * A, const int lda, const void * B, const int ldb, const void * beta, void * C, const int ldc)
  proc cblas_cgemm: CBLAS_ORDER * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * int * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_cgemm($a);';
// Function: void cblas_csymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const int M, const int N, const void * alpha, const void * A, const int lda, const void * B, const int ldb, const void * beta, void * C, const int ldc)
  proc cblas_csymm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_csymm($a);';
// Function: void cblas_csyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const void * alpha, const void * A, const int lda, const void * beta, void * C, const int ldc)
  proc cblas_csyrk: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * &void * &void * int * &void * &void * int = 'cblas_csyrk($a);';
// Function: void cblas_csyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const void * alpha, const void * A, const int lda, const void * B, const int ldb, const void * beta, void * C, const int ldc)
  proc cblas_csyr2k: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_csyr2k($a);';
// Function: void cblas_ctrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int M, const int N, const void * alpha, const void * A, const int lda, void * B, const int ldb)
  proc cblas_ctrmm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &void * &void * int * &void * int = 'cblas_ctrmm($a);';
// Function: void cblas_ctrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int M, const int N, const void * alpha, const void * A, const int lda, void * B, const int ldb)
  proc cblas_ctrsm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &void * &void * int * &void * int = 'cblas_ctrsm($a);';
// Function: void cblas_zgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const int M, const int N, const int K, const void * alpha, const void * A, const int lda, const void * B, const int ldb, const void * beta, void * C, const int ldc)
  proc cblas_zgemm: CBLAS_ORDER * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * int * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_zgemm($a);';
// Function: void cblas_zsymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const int M, const int N, const void * alpha, const void * A, const int lda, const void * B, const int ldb, const void * beta, void * C, const int ldc)
  proc cblas_zsymm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_zsymm($a);';
// Function: void cblas_zsyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const void * alpha, const void * A, const int lda, const void * beta, void * C, const int ldc)
  proc cblas_zsyrk: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * &void * &void * int * &void * &void * int = 'cblas_zsyrk($a);';
// Function: void cblas_zsyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const void * alpha, const void * A, const int lda, const void * B, const int ldb, const void * beta, void * C, const int ldc)
  proc cblas_zsyr2k: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_zsyr2k($a);';
// Function: void cblas_ztrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int M, const int N, const void * alpha, const void * A, const int lda, void * B, const int ldb)
  proc cblas_ztrmm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &void * &void * int * &void * int = 'cblas_ztrmm($a);';
// Function: void cblas_ztrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const int M, const int N, const void * alpha, const void * A, const int lda, void * B, const int ldb)
  proc cblas_ztrsm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * CBLAS_TRANSPOSE * CBLAS_DIAG * int * int * &void * &void * int * &void * int = 'cblas_ztrsm($a);';
// Function: void cblas_chemm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const int M, const int N, const void * alpha, const void * A, const int lda, const void * B, const int ldb, const void * beta, void * C, const int ldc)
  proc cblas_chemm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_chemm($a);';
// Function: void cblas_cherk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const float alpha, const void * A, const int lda, const float beta, void * C, const int ldc)
  proc cblas_cherk: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * float * &void * int * float * &void * int = 'cblas_cherk($a);';
// Function: void cblas_cher2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const void * alpha, const void * A, const int lda, const void * B, const int ldb, const float beta, void * C, const int ldc)
  proc cblas_cher2k: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * &void * &void * int * &void * int * float * &void * int = 'cblas_cher2k($a);';
// Function: void cblas_zhemm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const int M, const int N, const void * alpha, const void * A, const int lda, const void * B, const int ldb, const void * beta, void * C, const int ldc)
  proc cblas_zhemm: CBLAS_ORDER * CBLAS_SIDE * CBLAS_UPLO * int * int * &void * &void * int * &void * int * &void * &void * int = 'cblas_zhemm($a);';
// Function: void cblas_zherk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const double alpha, const void * A, const int lda, const double beta, void * C, const int ldc)
  proc cblas_zherk: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * double * &void * int * double * &void * int = 'cblas_zherk($a);';
// Function: void cblas_zher2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const int N, const int K, const void * alpha, const void * A, const int lda, const void * B, const int ldb, const double beta, void * C, const int ldc)
  proc cblas_zher2k: CBLAS_ORDER * CBLAS_UPLO * CBLAS_TRANSPOSE * int * int * &void * &void * int * &void * int * double * &void * int = 'cblas_zher2k($a);';
// Function: void cblas_xerbla (int p, const char * rout, const char * form, ...)
  proc cblas_xerbla: int * &char * &char * ... = 'cblas_xerbla($a);';
//*****
